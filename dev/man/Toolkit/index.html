<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Toolkit · QuantumLattices.jl</title><meta name="title" content="Toolkit · QuantumLattices.jl"/><meta property="og:title" content="Toolkit · QuantumLattices.jl"/><meta property="twitter:title" content="Toolkit · QuantumLattices.jl"/><meta name="description" content="Documentation for QuantumLattices.jl."/><meta property="og:description" content="Documentation for QuantumLattices.jl."/><meta property="twitter:description" content="Documentation for QuantumLattices.jl."/><meta property="og:url" content="https://quantum-many-body.github.io/QuantumLattices.jl/latest/man/Toolkit/"/><meta property="twitter:url" content="https://quantum-many-body.github.io/QuantumLattices.jl/latest/man/Toolkit/"/><link rel="canonical" href="https://quantum-many-body.github.io/QuantumLattices.jl/latest/man/Toolkit/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-89508993-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-89508993-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="QuantumLattices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumLattices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Unitcell Description Framework</span><ul><li><a class="tocitem" href="../../unitcell description framework/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../unitcell description framework/SpatialInfoOfAUnitcell/">Spatial information of a unitcell</a></li><li><a class="tocitem" href="../../unitcell description framework/InternalDegreesOfFreedom/">Internal degrees of freedom</a></li><li><a class="tocitem" href="../../unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/">Couplings among different degrees of freedom</a></li><li><a class="tocitem" href="../../unitcell description framework/GeneratorOfOperators/">Generator of operators</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../../advanced topics/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../advanced topics/LaTeXFormattedOutputs/">LaTeX formatted outputs</a></li><li><a class="tocitem" href="../../advanced topics/IndexOrders/">Index orders</a></li><li><a class="tocitem" href="../../advanced topics/BoundaryConditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../advanced topics/HybridSystems/">Hybrid systems</a></li><li><a class="tocitem" href="../../advanced topics/Transformations/">Transformations</a></li><li><a class="tocitem" href="../../advanced topics/ManageProjects/">Manage projects</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Toolkit</a><ul class="internal"><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Combinatorics"><span>Combinatorics</span></a></li><li><a class="tocitem" href="#Traits"><span>Traits</span></a></li><li><a class="tocitem" href="#Composite-structures"><span>Composite structures</span></a></li><li><a class="tocitem" href="#Named-vectors"><span>Named vectors</span></a></li><li><a class="tocitem" href="#Vector-spaces"><span>Vector spaces</span></a></li><li><a class="tocitem" href="#Simple-trees"><span>Simple trees</span></a></li></ul></li><li><a class="tocitem" href="../QuantumOperators/">Quantum operators</a></li><li><a class="tocitem" href="../QuantumNumbers/">Quantum numbers</a></li><li><a class="tocitem" href="../Spatials/">Spatials</a></li><li><a class="tocitem" href="../DegreesOfFreedom/">Degrees of freedom</a></li><li><a class="tocitem" href="../QuantumSystems/">Quantum Systems</a></li><li><a class="tocitem" href="../Frameworks/">Frameworks</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Toolkit</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Toolkit</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/master/docs/src/man/Toolkit.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Toolkit"><a class="docs-heading-anchor" href="#Toolkit">Toolkit</a><a id="Toolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Toolkit" title="Permalink"></a></h1><p><em>This module contains the toolkit of the package.</em></p><p>The constants, types, macros, functions defined in this module will <strong>not</strong> be exported by the package. Instead, they serve as the prerequisites. The range of the contents are quite wide, but basically, they fall into two categories:</p><ul><li>Utilities, such as global constants and miscellaneous tiny useful functions;</li><li>Basic data structures as supplements to the <code>Julia.Base</code> and other common packages.</li></ul><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.atol" href="#QuantumLattices.Toolkit.atol"><code>QuantumLattices.Toolkit.atol</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Absolute tolerance for float numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.rtol" href="#QuantumLattices.Toolkit.rtol"><code>QuantumLattices.Toolkit.rtol</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Relative tolerance for float numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.Float" href="#QuantumLattices.Toolkit.Float"><code>QuantumLattices.Toolkit.Float</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default float type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.concatenate" href="#QuantumLattices.Toolkit.concatenate"><code>QuantumLattices.Toolkit.concatenate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">concatenate(ts::Tuple...) -&gt; Tuple</code></pre><p>Concatenate tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.decimaltostr" href="#QuantumLattices.Toolkit.decimaltostr"><code>QuantumLattices.Toolkit.decimaltostr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decimaltostr(number, ::Int=5)
decimaltostr(number::Integer, n::Int=5)
decimaltostr(number::Rational, n::Int=5)
decimaltostr(number::AbstractFloat, n::Int=5)
decimaltostr(number::Complex, n::Int=5)</code></pre><p>Convert a number to a string with at most <code>n</code> decimal places.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.delta" href="#QuantumLattices.Toolkit.delta"><code>QuantumLattices.Toolkit.delta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delta(i, j) -&gt; Int</code></pre><p>Kronecker delta function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.ordinal" href="#QuantumLattices.Toolkit.ordinal"><code>QuantumLattices.Toolkit.ordinal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ordinal(number::Integer)</code></pre><p>Convert a positive number to its corresponding ordinal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.Segment" href="#QuantumLattices.Toolkit.Segment"><code>QuantumLattices.Toolkit.Segment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Segment{S} &lt;: AbstractVector{S}</code></pre><p>A segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1149-L1153">source</a></section></article><h2 id="Combinatorics"><a class="docs-heading-anchor" href="#Combinatorics">Combinatorics</a><a id="Combinatorics-1"></a><a class="docs-heading-anchor-permalink" href="#Combinatorics" title="Permalink"></a></h2><p>The combinations and permutations of an indexable object are implemented, with duplicate elements allowed or not. Compared to another Julia package <a href="https://github.com/JuliaMath/Combinatorics.jl">Combinatorics</a>, the iterators return tuples instead of vectors, which could greatly decrease the memory allocation times and improves the code efficiency.</p><p><a href="#QuantumLattices.Toolkit.Combinatorics"><code>Combinatorics{M, C}</code></a> is the abstract type of all combinatorial algorithms. It has two type parameters:</p><ul><li><code>M</code>: the number of elements to be taken</li><li><code>C</code>: the type of the collection of candidate elements</li></ul><p>To avoid memory allocation, the iteration of a concrete combinatorial algorithm returns a tuple, whose length is <code>M</code> and eltype is <code>eltype(C)</code>.</p><h3 id="Combinations-and-DuplicateCombinations"><a class="docs-heading-anchor" href="#Combinations-and-DuplicateCombinations">Combinations and DuplicateCombinations</a><a id="Combinations-and-DuplicateCombinations-1"></a><a class="docs-heading-anchor-permalink" href="#Combinations-and-DuplicateCombinations" title="Permalink"></a></h3><p><a href="#QuantumLattices.Toolkit.Combinations"><code>Combinations{M, C}</code></a> and <a href="#QuantumLattices.Toolkit.DuplicateCombinations"><code>DuplicateCombinations{M, C}</code></a> generate all the combinations of <code>M</code> elements from an indexable collection whose type is <code>C</code>, with the differences being that the former forbids duplicate elements in the combinations while the latter allows.</p><p>All combinations of 2 integers taken from 1 to 3 without duplicate:</p><pre><code class="language-julia hljs">Combinations{2}(1:3) |&gt; collect</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Tuple{Int64, Int64}}:
 (1, 2)
 (1, 3)
 (2, 3)</code></pre><p>All combinations of 2 integers taken from 1 to 3 with duplicate allowed:</p><pre><code class="language-julia hljs">DuplicateCombinations{2}(1:3) |&gt; collect</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (1, 2)
 (1, 3)
 (2, 2)
 (2, 3)
 (3, 3)</code></pre><h3 id="Permutations-and-DuplicatePermutations"><a class="docs-heading-anchor" href="#Permutations-and-DuplicatePermutations">Permutations and DuplicatePermutations</a><a id="Permutations-and-DuplicatePermutations-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-and-DuplicatePermutations" title="Permalink"></a></h3><p><a href="#QuantumLattices.Toolkit.Permutations"><code>Permutations{M, C}</code></a> and <a href="#QuantumLattices.Toolkit.DuplicatePermutations"><code>DuplicatePermutations{M, C}</code></a> generate all the permutations of <code>M</code> elements from an indexable collection whose type is <code>C</code>, with the differences being that the former forbids duplicate elements in the permutations while the latter allows.</p><p>All permutations of 2 integers taken from 1 to 3 without duplicate:</p><pre><code class="language-julia hljs">Permutations{2}(1:3) |&gt; collect</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Tuple{Int64, Int64}}:
 (1, 2)
 (1, 3)
 (2, 1)
 (2, 3)
 (3, 1)
 (3, 2)</code></pre><p>All permutations of 2 integers taken from 1 to 3 with duplicate allowed:</p><pre><code class="language-julia hljs">DuplicatePermutations{2}(1:3) |&gt; collect</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (1, 2)
 (1, 3)
 (2, 1)
 (2, 2)
 (2, 3)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><h3 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.Combinatorics" href="#QuantumLattices.Toolkit.Combinatorics"><code>QuantumLattices.Toolkit.Combinatorics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Combinatorics{M, C}</code></pre><p>Abstract combinatorial algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.Combinations" href="#QuantumLattices.Toolkit.Combinations"><code>QuantumLattices.Toolkit.Combinations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Combinations{M}(contents::C) where {M, C}</code></pre><p>Combinations of M elements from contents. Duplicates are not allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.DuplicateCombinations" href="#QuantumLattices.Toolkit.DuplicateCombinations"><code>QuantumLattices.Toolkit.DuplicateCombinations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DuplicateCombinations{M}(contents::C) where {M, C}</code></pre><p>Combinations of M elements from contents. Duplicates are allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.Permutations" href="#QuantumLattices.Toolkit.Permutations"><code>QuantumLattices.Toolkit.Permutations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Permutations{M}(contents::C) where {M, C}</code></pre><p>Permutations of M elements from contents. Duplicates are not allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.DuplicatePermutations" href="#QuantumLattices.Toolkit.DuplicatePermutations"><code>QuantumLattices.Toolkit.DuplicatePermutations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DuplicatePermutations{M}(contents::C) where {M, C}</code></pre><p>Permutations of M elements from contents. Duplicates are allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L224-L228">source</a></section></article><h2 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h2><p>Trait functions and trait types that are useful to the package are defined.</p><p>Generally speaking, traits in Julia could fall into two categories according to their usages, the first may be term as &quot;type helpers&quot; and the second are usually called &quot;Holy traits&quot; named after <a href="https://github.com/timholy">Tim Holy</a>. Type helpers aim at the inquiry, alteration and computation of the compile-time information of types, while Holy traits can be applied as an alternative to multi-inheritance by use of the Julia multidispatch feature.</p><h3 id="Type-helpers"><a class="docs-heading-anchor" href="#Type-helpers">Type helpers</a><a id="Type-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Type-helpers" title="Permalink"></a></h3><p>Type helpers are important for the generic programming in Julia, especially in the design of generic interfaces and abstract types.</p><p>Let&#39;s see a simple situation, i.e. the elemental addition of two vectors of numbers. The numbers can assume different types and the type of the result depends on both of them, for example, the result between two vectors of integers is a vector of integers while that between a vector of integers and a vector of floats is a vector of floats. Of course, one can explicitly define every elemental addition function between any two different types of vectors of numbers, like this:</p><pre><code class="language-julia hljs"># wrong design pattern

function elementaladdition(v₁::Vector{Int64}, v₂::Vector{Int64})
    result = Int[]
    ...
end
function elementaladdition(v₁::Vector{Int64}, v₂::Vector{Float64})
    result = Float64[]
    ...
end
...
...</code></pre><p>Writing down all such methods is already a heavy repetition. What&#39;s worse, you will quickly find that a lot more functions, such as the elemental subtraction, elemental multiplication and elemental division, are waiting for you to implement. This is a total disaster.</p><p>The correct strategy is to define the promotion rule of any two types of numbers and use it to define the type of the result:</p><pre><code class="language-julia hljs"># correct design pattern

promotion(::Type{Int64}, ::Type{Int64}) = Int64
promotion(::Type{Int64}, ::Type{Float64}) = Float64
...
...

function elementaladdition(v₁::Vector{T₁}, v₂::Vector{T₂}) where {T₁&lt;:Number, T₂&lt;:Number}
    result = promotion(T₁, T₂)[]
    ...
end
function elementalsubtraction(v₁::Vector{T₁}, v₂::Vector{T₂}) where {T₁&lt;:Number, T₂&lt;:Number}
    result = promotion(T₁, T₂)[]
    ...
end
...
...</code></pre><p>The promotion rule applies equally to all the arithmetic operations on numbers. Therefore, tedious code repetition could be avoided with it. In fact, similar promotion rules have already been defined in Julia base, and the default implementations of arithmetic operations in Julia are indeed based on them (see <a href="https://docs.julialang.org/en/v1/base/base/#Base.promote_type"><code>Base.promote_rule</code></a> and <a href="https://docs.julialang.org/en/v1/base/base/#Base.promote_rule"><code>Base.promote_type</code></a>). When new user-defined numeric types are introduced, the only things you need to do is to add new promotion rules and implement a few basic arithmetic functions for these new types. Then quite a lot of generic codes could apply to them without any modification.</p><h4 id="Type-helpers-with-type-parameters"><a class="docs-heading-anchor" href="#Type-helpers-with-type-parameters">Type helpers with type parameters</a><a id="Type-helpers-with-type-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Type-helpers-with-type-parameters" title="Permalink"></a></h4><p>The input and output types of a promotion rule are known at compile time, thus, the promotion rule is a trait function aiming at the computation of compile-time information of types. Trait functions dealing with the inquiries of compile-time information of types are also widely used in Julia, such as the <a href="https://docs.julialang.org/en/v1/base/collections/#Base.eltype"><code>eltype</code></a> function of <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.Vector"><code>Vector</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; eltype(Vector{String})
String</code></pre><p>For a user-defined parametric type, it is also useful to provide an inquiry function to access to the type parameters:</p><pre><code class="language-julia-repl hljs">julia&gt; struct Hi{T&lt;:Number}
           content::T
       end
       contenttype(::Type{Hi{T}}) where T&lt;:Number = T
       contenttype(Hi{Int64})
Int64</code></pre><p>However, the above defined function <code>contenttype</code> could not apply to a <a href="https://docs.julialang.org/en/v1/manual/types/#UnionAll-Types"><code>UnionAll</code></a> type, such as <code>Hi{&lt;:Real}</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; contenttype(Hi{&lt;:Real})
ERROR: MethodError: no method matching contenttype(::Type{Hi{&lt;:Real}})
[...]</code></pre><p>In fact in Julia base, all such inquiry functions, e.g., the <code>eltype</code> function, work poor for the <code>UnionAll</code> types:</p><pre><code class="language-julia-repl hljs">julia&gt; eltype(Vector{&lt;:Real})
Any</code></pre><p>In concept, <code>eltype(Vector{&lt;:Real}</code> should return <code>Real</code> instead of <code>Any</code> as every element in <code>Vector{&lt;:Real}</code> is indeed a real number. Similarly, we expect that <code>contenttype(Hi{&lt;:Real})</code> should also give us <code>Real</code>. Unfortunately, functions defined in the similar form like this could never achieve such goals. Julia base doesn&#39;t provide generic functions to access or change the information of the parameters of a type. In this module, we try to fill this gap with a set of generic trait functions.</p><h5 id="Access-or-change-the-type-parameters-by-their-position-orders"><a class="docs-heading-anchor" href="#Access-or-change-the-type-parameters-by-their-position-orders">Access or change the type parameters by their position orders</a><a id="Access-or-change-the-type-parameters-by-their-position-orders-1"></a><a class="docs-heading-anchor-permalink" href="#Access-or-change-the-type-parameters-by-their-position-orders" title="Permalink"></a></h5><p>The most direct information of the parameters of a type is their position orders. We provide <a href="#QuantumLattices.Toolkit.parametertype"><code>parametertype</code></a> to access to them by such information:</p><pre><code class="language-julia-repl hljs">julia&gt; parametertype(Hi{&lt;:Real}, 1)
Real

julia&gt; parametertype(Vector{&lt;:Real}, 1)
Real

julia&gt; parametertype(Vector{&lt;:Real}, 2)
1</code></pre><p>You can use <a href="#QuantumLattices.Toolkit.parametercount"><code>parametercount</code></a> to inquire the total number of the parameters of a type:</p><pre><code class="language-julia-repl hljs">julia&gt; parametercount(Hi)
1

julia&gt; parametercount(Vector)
2</code></pre><p>It is noted that <code>Vector</code> has 2 type parameters because it is just a type alias for <code>Array{T, 1} where T</code>.</p><p>To change the parameters of a type, <a href="#QuantumLattices.Toolkit.reparameter"><code>reparameter</code></a> can be used:</p><pre><code class="language-julia-repl hljs">julia&gt; reparameter(Hi{Int64}, 1, Real)
Hi{Real}

julia&gt; reparameter(Vector{Int64}, 1, Real)
Vector{Real} (alias for Array{Real, 1})

julia&gt; reparameter(Vector{&lt;:Real}, 2, 3)
Array{&lt;:Real, 3}

julia&gt; reparameter(Hi{Int64}, 1, Real, false)
Hi{Real}

julia&gt; reparameter(Hi{Int64}, 1, Real, true)
Hi{&lt;:Real}</code></pre><p>We want to remark that by providing the fourth positional argument with the <code>true</code> value, a <code>UnionAll</code> type could be generated. When the fourth positional argument is omitted, it is actually determined by another trait function, i.e., <a href="#QuantumLattices.Toolkit.isparameterbound"><code>isparameterbound</code></a>. This function judges whether an input type should be considered as the upper bound of the new parameter of a type. By default, it is always defined to be <code>false</code>. This function can be overloaded to change the behavior for a certain type:</p><pre><code class="language-julia-repl hljs">julia&gt; isparameterbound(::Type{&lt;:Hi}, ::Val{1}, D) = !isconcretetype(D);

julia&gt; reparameter(Hi, 1, Real)
Hi{&lt;:Real}</code></pre><p>The second positional argument of <a href="#QuantumLattices.Toolkit.isparameterbound"><code>isparameterbound</code></a> must be of type <code>Val</code> because in principle you should be able to assign different behaviors for different parameters of a type separately. If it is of type <code>Integer</code>, a single overloading would change the behaviors for all.</p><p>Besides, you can inquire all the parameters of a type by <a href="#QuantumLattices.Toolkit.parametertypes"><code>parametertypes</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; parametertypes(Hi{&lt;:Real})
Tuple{Real}

julia&gt; parametertypes(Vector{Int64})
Tuple{Int64, 1}</code></pre><p>The obtained type parameters are stored as those of a <code>Tuple</code>.</p><p>At the same time, you can change all the parameters of a type by <a href="#QuantumLattices.Toolkit.fulltype"><code>fulltype</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; fulltype(Hi{Int64}, Tuple{Real})
Hi{&lt;:Real}

julia&gt; fulltype(Hi{Int64}, Tuple{Real}, (false,))
Hi{Real}

julia&gt; fulltype(Vector{Int64}, Tuple{Real, 2})
Matrix{Real} (alias for Array{Real, 2})

julia&gt; fulltype(Vector{Int64}, Tuple{Real, 2}, (true, false))
Matrix{&lt;:Real} (alias for Array{&lt;:Real, 2})</code></pre><p>Like <a href="#QuantumLattices.Toolkit.reparameter"><code>reparameter</code></a>, the last positional argument of <a href="#QuantumLattices.Toolkit.fulltype"><code>fulltype</code></a> could determine whether the corresponding types specified by the type parameters of the input <code>Tuple</code> should be considered as the upper bounds of the new parameters of a type. When this argument is omitted, it is determined by another trait function <a href="#QuantumLattices.Toolkit.isparameterbounds"><code>isparameterbounds</code></a>, which successively calls the <a href="#QuantumLattices.Toolkit.isparameterbound"><code>isparameterbound</code></a> function to determine the behaviors for all the parameters of a type as the literal indicates.</p><h5 id="Associate-type-parameters-with-names"><a class="docs-heading-anchor" href="#Associate-type-parameters-with-names">Associate type parameters with names</a><a id="Associate-type-parameters-with-names-1"></a><a class="docs-heading-anchor-permalink" href="#Associate-type-parameters-with-names" title="Permalink"></a></h5><p>Sometimes, it is more convenient to associate names with the parameters of a type, and then access or change them by their names. This can be done by overloading the <a href="#QuantumLattices.Toolkit.parameternames"><code>parameternames</code></a> trait function for a certain type:</p><pre><code class="language-julia-repl hljs">julia&gt; parameternames(::Type{&lt;:Hi}) = (:content,)
parameternames (generic function with 3 methods)</code></pre><p>Now, you can inquire the name of a type parameter by <a href="#QuantumLattices.Toolkit.parametername"><code>parametername</code></a> with the given position order or vice versa by <a href="#QuantumLattices.Toolkit.parameterorder"><code>parameterorder</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; parametername(Hi, 1)
:content

julia&gt; parameterorder(Hi, :content)
1</code></pre><p>You can also inquire whether a type has a parameter with the given name by <a href="#QuantumLattices.Toolkit.hasparameter"><code>hasparameter</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; hasparameter(Hi, :content)
true

julia&gt; hasparameter(Hi, :others)
false</code></pre><p>And <a href="#QuantumLattices.Toolkit.parametertype"><code>parametertype</code></a> and <a href="#QuantumLattices.Toolkit.reparameter"><code>reparameter</code></a> can be applied by the name of a type parameter instead of its position order:</p><pre><code class="language-julia-repl hljs">julia&gt; parametertype(Hi{&lt;:Real}, :content)
Real

julia&gt; reparameter(Hi{Int}, :content, Real)
Hi{Real}

julia&gt; reparameter(Hi{Int}, :content, Real, true)
Hi{&lt;:Real}</code></pre><p>To change the <a href="#QuantumLattices.Toolkit.reparameter"><code>reparameter</code></a> behavior when its last positional argument is omitted, you should overload the <a href="#QuantumLattices.Toolkit.isparameterbound"><code>isparameterbound</code></a> function accordingly, e.g.:</p><pre><code class="language-julia-repl hljs">julia&gt; isparameterbound(::Type{&lt;:Hi}, ::Val{:content}, D) = !isconcretetype(D);

julia&gt; reparameter(Hi{Int}, :content, Real)
Hi{&lt;:Real}</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Accessing or altering a parameter of a type by its name is independent from that by its position order. Thus, even the following method</p><pre><code class="language-julia hljs">isparameterbound(::Type{&lt;:Hi}, ::Val{1}, D)</code></pre><p>has been overloaded, it doesn&#39;t affect the result of the function call like</p><pre><code class="language-julia hljs">reparameter(Hi{Int}, :content, Real)</code></pre><p>Rather, it only affect the result of the function call like</p><pre><code class="language-julia hljs">reparameter(Hi{Int}, 1, Real)</code></pre><p>To change the default behavior of the former function call, you must overload the following method manually as well</p><pre><code class="language-julia hljs">isparameterbound(::Type{&lt;:Hi}, ::Val{:content}, D)</code></pre></div></div><p>A new trait function <a href="#QuantumLattices.Toolkit.parameterpair"><code>parameterpair</code></a> is provided to inquire the name-type pair of a parameter of a type:</p><pre><code class="language-julia-repl hljs">julia&gt; parameterpair(Hi{&lt;:Real}, 1)
Pair{:content, Real}

julia&gt; parameterpair(Hi{&lt;:Real}, :content)
Pair{:content, Real}</code></pre><p>And a new trait function <a href="#QuantumLattices.Toolkit.parameterpairs"><code>parameterpairs</code></a> can be used to inquire all the name-type pairs of the parameters of a type:</p><pre><code class="language-julia-repl hljs">julia&gt; parameterpairs(Hi{&lt;:Real})
NamedTuple{(:content,), Tuple{Real}}</code></pre><p>The parameters of a type can be altered all at once by giving the name-type pairs to <a href="#QuantumLattices.Toolkit.fulltype"><code>fulltype</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}}, (false,))
Hi{Real}

julia&gt; fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}}, (true,))
Hi{&lt;:Real}

julia&gt; fulltype(Hi{Int}, NamedTuple{(:content,),Tuple{Real}})
Hi{&lt;:Real}</code></pre><p>Here, the last positional argument can be omitted whose default value would be determined by the <a href="#QuantumLattices.Toolkit.isparameterbounds"><code>isparameterbounds</code></a> function which successively calls the <a href="#QuantumLattices.Toolkit.isparameterbound"><code>isparameterbound</code></a> function on each of the named parameter. Note that similar to the situation of the <a href="#QuantumLattices.Toolkit.reparameter"><code>reparameter</code></a> function in this subsubsection, the <a href="#QuantumLattices.Toolkit.isparameterbound"><code>isparameterbound</code></a> function called here is also the version that takes the parameter name as the input rather than that of the position order.</p><h4 id="Type-helpers-with-predefined-contents"><a class="docs-heading-anchor" href="#Type-helpers-with-predefined-contents">Type helpers with predefined contents</a><a id="Type-helpers-with-predefined-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Type-helpers-with-predefined-contents" title="Permalink"></a></h4><p>Julia abstract types don&#39;t have any field or attribute. They are only tags on the type tree. However, we may expect sometimes an abstract type to possess some kind of predefined content so that the design of some methods could be highly simplified. For example, we may need an abstract type that describes a composite vector. Apparently, it should have a field that is the vector contained in it. Of course, we can appoint a fixed field name with it and force every concrete subtype must contain such a field. In such a design pattern, the name of this field in every concrete subtype must be kept unchanged, which may be annoying when it conflicts with that of another field. What&#39;s worse, a predefined content of an abstract type is not always limited to a certain field. Maybe we need more than one fields to construct such a content. The just mentioned design pattern cannot deal with such situations.</p><p>Here, we provide a set of trait functions to help the design of abstract types with predefined contents. We take the case of composite vector for illustration, and the generalization to other situations is straightforward. First, the trait function <a href="#QuantumLattices.Toolkit.contentnames"><code>contentnames</code></a> should be overloaded to define the names of the predefined contents:</p><pre><code class="language-julia-repl hljs">julia&gt; abstract type CompositeVector{T} end
       contentnames(::Type{&lt;:CompositeVector}) = (:content,);</code></pre><p>Then you can inquire the total number of predefined contents by <a href="#QuantumLattices.Toolkit.contentcount"><code>contentcount</code></a>, inquire the name of a predefined content with its position order by <a href="#QuantumLattices.Toolkit.contentname"><code>contentname</code></a>, and judge whether a type has a predefined content with a given name by <a href="#QuantumLattices.Toolkit.hascontent"><code>hascontent</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; contentcount(CompositeVector)
1

julia&gt; contentname(CompositeVector, 1)
:content

julia&gt; hascontent(CompositeVector, :content)
true

julia&gt; hascontent(CompositeVector, :value)
false</code></pre><p>The key is the interface <a href="#QuantumLattices.Toolkit.getcontent"><code>getcontent</code></a>, which defines how to get the value of the predefined content. For the simple case when the predefined content just corresponds to a field, and also the field name of the predefined content coincides with the content name, the overloading of <a href="#QuantumLattices.Toolkit.getcontent"><code>getcontent</code></a> can be omitted, e.g.:</p><pre><code class="language-julia-repl hljs">julia&gt; struct AnotherCompositeVector{T} &lt;: CompositeVector{T}
           content::Vector{T}
       end;

julia&gt; v = AnotherCompositeVector([1, 2, 3])
       getcontent(v, :content)
3-element Vector{Int64}:
 1
 2
 3</code></pre><p>For the cases when a predefined contents does not share the same name with a certain field, or even it is not limited to only one certain field, you must implement your own <a href="#QuantumLattices.Toolkit.getcontent"><code>getcontent</code></a> manually. Let&#39;s see two typical examples:</p><pre><code class="language-julia-repl hljs">julia&gt; struct DifferentFieldName{T} &lt;: CompositeVector{T}
           data::Vector{T}
       end
       getcontent(v::DifferentFieldName, ::Val{:content}) = v.data;

julia&gt; struct BeyondSingleField{T} &lt;: CompositeVector{T}
           firsthalf::Vector{T}
           secondhalf::Vector{T}
       end
       getcontent(v::BeyondSingleField, ::Val{:content}) = [v.firsthalf; v.secondhalf];

julia&gt; v = DifferentFieldName([1, 2, 3])
       getcontent(v, :content)
3-element Vector{Int64}:
 1
 2
 3

julia&gt; v = BeyondSingleField([1, 2, 3], [4, 5, 6])
       getcontent(v, :content)
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre><p>Note that for the method overloading of <a href="#QuantumLattices.Toolkit.getcontent"><code>getcontent</code></a>, the second argument is of type <code>Val{:content}</code>. This is convenient because in principle an abstract type could have more than only one predefined content, thus, the behaviors of the <a href="#QuantumLattices.Toolkit.getcontent"><code>getcontent</code></a> function could be defined separately for different predefined contents in this way. In fact, the function call <code>getcontent(m, contentname)</code> is just an alias for <code>getcontent(m, contentname|&gt;Val)</code>.</p><h3 id="Holy-traits"><a class="docs-heading-anchor" href="#Holy-traits">Holy traits</a><a id="Holy-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Holy-traits" title="Permalink"></a></h3><p>As an emergent feature of Julia, basically speaking, a Holy trait is a Julia type that could direct the generic function of a user-defined type to a certain implementation based on the Julia multi-dispatch mechanism. For different user-defined types, they could be assigned with different Holy traits, leading to different implementations of the same generic interface. Since the information of Holy traits are known at compile time, such design pattern doesn&#39;t affect the runtime efficiency as long as type stability is ensured.</p><h4 id="Alternative-of-multi-inheritance"><a class="docs-heading-anchor" href="#Alternative-of-multi-inheritance">Alternative of multi-inheritance</a><a id="Alternative-of-multi-inheritance-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-of-multi-inheritance" title="Permalink"></a></h4><p>Maybe the most common application of Holy traits is to serve as the alternative of multi-inheritance. Let&#39;s see a simple scenario. You have defined an abstract type. It is natural to demand that for every concrete subtype of it, a pair of instances could be compared and judge whether they are equivalent to each other by the value. Unfortunately, for a new user-defined type, the default <code>==</code> function in Julia actually judges whether they are the same object, but not equal to each other by the value. Therefore, you need to define your own <code>==</code> function for this abstract type. However, you may need define a lot of abstract types when you are developing a Julia package. It is annoying if such simple functions must be written for each of them. In other languages like Python, this could be solved with the help of multi-inheritance. But Julia does not support multi-inheritance. The common way is to use Holy traits. For example, the above issue could be solved like this:</p><pre><code class="language-julia hljs">struct Equivalence end
const equivalence = Equivalence()
function Base.:(==)(::Equivalence, o₁, o₂)
    n₁, n₂ = fieldcount(typeof(o₁)), fieldcount(typeof(o₂))
    n₁≠n₂ &amp;&amp; return false
    for i = 1:n₁
        getfield(o₁, i)≠getfield(o₂, i) &amp;&amp; return false
    end
    return true
end

abstract type TypeWithEquivalence end
Base.:(==)(o₁::TypeWithEquivalence, o₂::TypeWithEquivalence) = ==(equivalence, o₁, o₂);

struct ConcreteTypeWithEquivalence{F₁, F₂} &lt;: TypeWithEquivalence
    f₁::F₁
    f₂::F₂
end;

a₁ = ConcreteTypeWithEquivalence((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), [1, 2, 3])
a₂ = ConcreteTypeWithEquivalence((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), [1.0, 2.0, 3.0])
a₁ == a₂</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Here, the type <code>Equivalence</code> is the Holy trait that helps the abstract type <code>TypeWithEquivalence</code> to implement the <code>==</code> function, which applies equally to any other types.</p><h4 id="Type-stability-and-the-generated-function-trick"><a class="docs-heading-anchor" href="#Type-stability-and-the-generated-function-trick">Type stability and the generated function trick</a><a id="Type-stability-and-the-generated-function-trick-1"></a><a class="docs-heading-anchor-permalink" href="#Type-stability-and-the-generated-function-trick" title="Permalink"></a></h4><p>However, the story does not end up here. If you are concerned about the code efficiency, you may find that the above implementation is not type stable:</p><pre><code class="language-julia hljs">using BenchmarkTools
@benchmark $a₁ == $a₂</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 972 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">73.852 ns</span></span> … <span class="sgr35">  5.206 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span> 0.00% … 59.47%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">79.098 ns               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span> 0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">97.315 ns</span></span> ± <span class="sgr32">229.354 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>16.90% ±  7.04%

  ▄▇█<span class="sgr34">█</span>▅▂▂  ▁▁  <span class="sgr32"> </span>                                               ▂
  ███<span class="sgr34">█</span>███████▇▆<span class="sgr32">▆</span>▅▅▅▄▃▄▄▁▃▄▄▃▃▃▃▁▃▁▁▁▁▁▁▁▁▄▁▁▄▆█▇▅▅▃▃▁▃▄▁▁▁▁▅▇▇ █
  73.9 ns<span class="sgr90">       Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>       179 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">256 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">6</span>.</code></pre><p>The memory allocation occurs when the <code>==</code> function tries to compare the values of <code>getfield(o₁, i)</code> and <code>getfield(o₂, i)</code> because in principle the types of these values depend on the runtime value of the variable <code>i</code>. To ensure type stability, the generated function trick can be utilized:</p><pre><code class="language-julia hljs">struct EfficientEquivalence end
const efficientequivalence = EfficientEquivalence()
@generated function Base.:(==)(::EfficientEquivalence, o₁, o₂)
    n₁, n₂ = fieldcount(o₁), fieldcount(o₂)
    n₁≠n₂ &amp;&amp; return false
    expr = :(getfield(o₁, 1) == getfield(o₂, 1))
    for i = 2:n₁
        expr = Expr(:&amp;&amp;, expr, :(getfield(o₁, $i) == getfield(o₂, $i)))
    end
    return expr
end

abstract type TypeWithEfficientEquivalence end
function Base.:(==)(o₁::TypeWithEfficientEquivalence, o₂::TypeWithEfficientEquivalence)
    return ==(efficientequivalence, o₁, o₂)
end

struct ConcreteTypeWithEfficientEquivalence{F₁, F₂} &lt;: TypeWithEfficientEquivalence
    f₁::F₁
    f₂::F₂
end

a₁ = ConcreteTypeWithEfficientEquivalence((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), [1, 2, 3])
a₂ = ConcreteTypeWithEfficientEquivalence((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), [1.0, 2.0, 3.0])
a₁ == a₂</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">@benchmark $a₁ == $a₂</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 997 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">18.499 ns</span></span> … <span class="sgr35">37.965 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">18.530 ns              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">18.594 ns</span></span> ± <span class="sgr32"> 0.657 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

   ▆<span class="sgr34">█</span>  ▂ <span class="sgr32"> </span>                                                     
  ██<span class="sgr34">█</span>▃▃█▆<span class="sgr32">▃</span>▂▁▁▁▁▁▁▁▁▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▂▁▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▂▁▂ ▂
  18.5 ns<span class="sgr90">         Histogram: frequency by time</span>        19.3 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><p>At runtime of the generated <code>==</code> function, it compares the values of <code>getfield(o₁, 1)</code> and <code>getfield(o₂, 1)</code>, <code>getfield(o₁, 2)</code> and <code>getfield(o₂, 2)</code>, etc., whose types are known at compile time. Therefore, type stability could be ensured.</p><h4 id="EfficientOperations"><a class="docs-heading-anchor" href="#EfficientOperations">EfficientOperations</a><a id="EfficientOperations-1"></a><a class="docs-heading-anchor-permalink" href="#EfficientOperations" title="Permalink"></a></h4><p><code>EfficientOperations</code> is a Holy trait defined in this module that packs several common operations, such as <code>==/isequal</code>, <code>&lt;/isless</code>, <code>isapprox</code> and <code>replace</code>, to help other (abstract) types to implement such functions by passing <a href="#QuantumLattices.Toolkit.efficientoperations"><code>efficientoperations</code></a> as the first argument, just as illustrated above. See the manual for more detailed information.</p><h3 id="Manual-2"><a class="docs-heading-anchor" href="#Manual-2">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-2" title="Permalink"></a></h3><p>For traits with types themselves:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.commontype" href="#QuantumLattices.Toolkit.commontype"><code>QuantumLattices.Toolkit.commontype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">commontype(f::Function, types, ::Type{T}=Any) where T</code></pre><p>Find the common return type of a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.fulltype" href="#QuantumLattices.Toolkit.fulltype"><code>QuantumLattices.Toolkit.fulltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fulltype(::Type{T}, ::Type{PS}, ubs::Tuple{Vararg{Bool}}=isparameterbounds(T, PS)) where {T, PS&lt;:Tuple}
fulltype(::Type{T}, ::Type{PS}, ubs::Tuple{Vararg{Bool}}=isparameterbounds(T, PS)) where {T, PS&lt;:NamedTuple}</code></pre><p>Get the full type of type <code>T</code> with the type parameters replaced by those of <code>PS</code>.</p><p>Here, <code>ubs</code> determines whether the new type parameter should be considered as the upper bound accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L471-L478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.rawtype" href="#QuantumLattices.Toolkit.rawtype"><code>QuantumLattices.Toolkit.rawtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rawtype(::Type{T}) where T -&gt; DataType/UnionAll</code></pre><p>Get the &quot;raw part&quot; of a type. That is, the type without all its type parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.DataType" href="#Core.DataType"><code>Core.DataType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataType &lt;: Type{T}</code></pre><p><code>DataType</code> represents explicitly declared types that have names, explicitly declared supertypes, and, optionally, parameters.  Every concrete value in the system is an instance of some <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; typeof(Real)
DataType

julia&gt; typeof(Int)
DataType

julia&gt; struct Point
           x::Int
           y
       end

julia&gt; typeof(Point)
DataType</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/bed2cd540a11544ed4be381d471bbf590f0b745e/base/docs/basedocs.jl#L1485-L1508">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.supertype" href="#Base.supertype"><code>Base.supertype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">supertype(T::DataType)</code></pre><p>Return the supertype of DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; supertype(Int32)
Signed</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/bed2cd540a11544ed4be381d471bbf590f0b745e/base/operators.jl#L32-L42">source</a></section><section><div><pre><code class="language-julia hljs">supertype(T, termination::Symbol) -&gt; DataType</code></pre><p>Get the supertype of <code>T</code> till termination.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L274-L278">source</a></section></article><p>For traits with type parameters:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.hasparameter" href="#QuantumLattices.Toolkit.hasparameter"><code>QuantumLattices.Toolkit.hasparameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hasparameter(::Type{T}, name::Symbol) where T -&gt; Bool</code></pre><p>For type <code>T</code>, judge whether it has a type parameter specified by <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L364-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.isparameterbound" href="#QuantumLattices.Toolkit.isparameterbound"><code>QuantumLattices.Toolkit.isparameterbound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isparameterbound(::Type{T}, i::Integer, D) where T -&gt; Bool
isparameterbound(::Type{T}, name::Symbol, D) where T -&gt; Bool
isparameterbound(::Type{}, ::Val{}, ::Any) -&gt; Bool</code></pre><p>For a type <code>T</code>, judge whether a type <code>D</code> should be considered as the upper bound of one of its type parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L353-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.isparameterbounds" href="#QuantumLattices.Toolkit.isparameterbounds"><code>QuantumLattices.Toolkit.isparameterbounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isparameterbounds(::Type{T}, ::Type{PS}) where {T, PS&lt;:Tuple} -&gt; Tuple{Vararg{Bool}}
isparameterbounds(::Type{T}, ::Type{PS}) where {T, PS&lt;:NamedTuple} -&gt; Tuple{Vararg{Bool}}</code></pre><p>For a type <code>T</code>, judge whether the types specified by <code>PS</code> should be considered as the upper bounds of its corresponding type parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L404-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.parametercount" href="#QuantumLattices.Toolkit.parametercount"><code>QuantumLattices.Toolkit.parametercount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parametercount(::Type{T}) where T -&gt; Int</code></pre><p>For a type <code>T</code>, get the number of its type parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L306-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.parametername" href="#QuantumLattices.Toolkit.parametername"><code>QuantumLattices.Toolkit.parametername</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parametername(::Type{T}, i::Integer) where T -&gt; Symbol</code></pre><p>For a type <code>T</code>, get the name of its ith type parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.parameternames" href="#QuantumLattices.Toolkit.parameternames"><code>QuantumLattices.Toolkit.parameternames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parameternames(::Type{T}) where T -&gt; Tuple{Vararg{Symbol}}</code></pre><p>For a type <code>T</code>, get the names of all its type parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.parameterorder" href="#QuantumLattices.Toolkit.parameterorder"><code>QuantumLattices.Toolkit.parameterorder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parameterorder(::Type{T}, name::Symbol) where T -&gt; Int</code></pre><p>For a type <code>T</code>, get the order of one of its type parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L321-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.parameterpair" href="#QuantumLattices.Toolkit.parameterpair"><code>QuantumLattices.Toolkit.parameterpair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parameterpair(::Type{T}, name::Symbol) where T
parameterpair(::Type{T}, i::Integer) where T</code></pre><p>For type <code>T</code>, get the name-type pair of one of its type parameters.</p><p>The result is stored in the type parameters of a <code>Pair</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L342-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.parameterpairs" href="#QuantumLattices.Toolkit.parameterpairs"><code>QuantumLattices.Toolkit.parameterpairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parameterpairs(::Type{T}) where T</code></pre><p>For a type <code>T</code>, get the name-type pairs of all its type parameters.</p><p>The return types are stored in the type parameters of a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L395-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.parametertype" href="#QuantumLattices.Toolkit.parametertype"><code>QuantumLattices.Toolkit.parametertype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parametertype(::Type{T}, name::Symbol) where T
parametertype(::Type{T}, i::Integer) where T</code></pre><p>For a type <code>T</code>, get the type of one of its type parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L329-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.parametertypes" href="#QuantumLattices.Toolkit.parametertypes"><code>QuantumLattices.Toolkit.parametertypes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parametertypes(::Type{T}) where T</code></pre><p>For a type <code>T</code>, get the types of all its type parameters.</p><p>The returned types are stored in the type parameters of a <code>Tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L379-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.promoteparameters" href="#QuantumLattices.Toolkit.promoteparameters"><code>QuantumLattices.Toolkit.promoteparameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">promoteparameters(::Type{T1}, ::Type{T2}) where {T1&lt;:NamedTuple, T2&lt;:NamedTuple}</code></pre><p>Promote the types specified by two named tuples with the same names accordingly.</p><p>The result is stored in the type parameters of a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L449-L455">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.reparameter" href="#QuantumLattices.Toolkit.reparameter"><code>QuantumLattices.Toolkit.reparameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reparameter(::Type{T}, i::Integer, P, ub::Bool=isparameterbound(T, i, P)) where T
reparameter(::Type{T}, name::Symbol, P, ub::Bool=isparameterbound(T, name, P)) where T</code></pre><p>For a type <code>T</code>, replace the type of its ith type parameter with <code>P</code>. Here, <code>ub</code> determines whether <code>P</code> should be considered as the upper bound. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L431-L436">source</a></section></article><p>For traits with type contents:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.contentcount" href="#QuantumLattices.Toolkit.contentcount"><code>QuantumLattices.Toolkit.contentcount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contentcount(::Type{T}) where T -&gt; Int</code></pre><p>For a type <code>T</code>, get the number of its predefined contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L504-L508">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.contentname" href="#QuantumLattices.Toolkit.contentname"><code>QuantumLattices.Toolkit.contentname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contentname(::Type{T}, i::Integer) where T -&gt; Symbol</code></pre><p>For a type <code>T</code>, get the name of its ith predefined content.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L511-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.contentnames" href="#QuantumLattices.Toolkit.contentnames"><code>QuantumLattices.Toolkit.contentnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contentnames(::Type{T}) where T -&gt; Tuple{Vararg{Symbol}}</code></pre><p>For a type <code>T</code>, define the names of its predefined contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L553-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.contentorder" href="#QuantumLattices.Toolkit.contentorder"><code>QuantumLattices.Toolkit.contentorder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contentorder(::Type{T}, name::Symbol) where T -&gt; Int</code></pre><p>For a type <code>T</code>, get the position order of a predefined content by the name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L518-L522">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.contenttype" href="#QuantumLattices.Toolkit.contenttype"><code>QuantumLattices.Toolkit.contenttype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contenttype(::Type{T}, name::Symbol) where T
contenttype(::Type{T}, ::Val{name}) where {T, name}</code></pre><p>For a type <code>T</code>, get the type of a predefined content by the name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L525-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.contenttypes" href="#QuantumLattices.Toolkit.contenttypes"><code>QuantumLattices.Toolkit.contenttypes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contenttypes(::Type{T}) where T</code></pre><p>For a type <code>T</code>, get the types of its predefined contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L560-L564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.getcontent" href="#QuantumLattices.Toolkit.getcontent"><code>QuantumLattices.Toolkit.getcontent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getcontent(m, i::Integer)
getcontent(m, name::Symbol)
getcontent(m, ::Val{name}) where name</code></pre><p>Get the value of the predefined content of <code>m</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L542-L548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.hascontent" href="#QuantumLattices.Toolkit.hascontent"><code>QuantumLattices.Toolkit.hascontent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hascontent(::Type{T}, name::Symbol) where T -&gt; Bool</code></pre><p>For a type <code>T</code>, judge whether it has a predefined content specified by <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L534-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.dissolve" href="#QuantumLattices.Toolkit.dissolve"><code>QuantumLattices.Toolkit.dissolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dissolve(m, f::Function=identity, args::Tuple=(), kwargs::NamedTuple=NamedTuple()) -&gt; Tuple</code></pre><p>Convert <code>m</code> to a tuple by the function <code>f</code> applied elementally to its contents with the extra positional arguments (<code>args</code>) and keyword arguments (<code>kwargs</code>). </p><p>The underlying called interface is the <code>dissolve</code> function when <code>f</code> is applied to each content of <code>m</code>:</p><pre><code class="language-julia hljs">dissolve(m, Val(name), f, args, kwargs)</code></pre><p>Here, <code>name</code> is the name of a content of <code>m</code>.</p><p>Basically, the rule of how <code>f</code> operates on each field of <code>m</code> can be overridden by redefining the above <code>dissolve</code> function. !!!note    The default <code>dissolve</code> function ignores the operation of function <code>f</code> and just return the content value of <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L574-L588">source</a></section><section><div><pre><code class="language-julia hljs">dissolve(m, ::Val{name}, f::Function, args::Tuple, kwargs::NamedTuple) where name</code></pre><p>Dissolve the content specified by <code>name</code> of <code>m</code> by the function <code>f</code> applied with the extra positional arguments (<code>args</code>) and keyword arguments (<code>kwargs</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L601-L605">source</a></section></article><p>For traits with type operations:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.efficientoperations" href="#QuantumLattices.Toolkit.efficientoperations"><code>QuantumLattices.Toolkit.efficientoperations</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">efficientoperations</code></pre><p>Indicate that the efficient operations, i.e. &quot;==&quot;/&quot;isequal&quot;, &quot;&lt;&quot;/&quot;isless&quot; or &quot;replace&quot;, will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L610-L614">source</a></section></article><h2 id="Composite-structures"><a class="docs-heading-anchor" href="#Composite-structures">Composite structures</a><a id="Composite-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-structures" title="Permalink"></a></h2><p>In principle, Julia is not an object-oriented programming language. For example, only abstract types can be inherited so that subtype cannot inherit fields from their parents. Therefore, Julia prefers composition over inheritance. However, to make a new concrete type behaves much alike another one, tedious repetitions of redefining the generic interfaces are usually not avoidable, especially for the basic types in Julia base. In this module, we implement three such composited types, <a href="#QuantumLattices.Toolkit.CompositeTuple"><code>CompositeTuple</code></a>, <a href="#QuantumLattices.Toolkit.CompositeVector"><code>CompositeVector</code></a> and <a href="#QuantumLattices.Toolkit.CompositeDict"><code>CompositeDict</code></a>, for the sake of future usages. Besides, <a href="#QuantumLattices.Toolkit.NamedContainer"><code>NamedContainer</code></a>, as a wrapper of Julia <code>NamedTuple</code>, is also provided here so that the construction of a Julia <code>NamedTuple</code> can be more flexible over the standard <code>(name=value, ... )</code> syntax.</p><h3 id="CompositeTuple-and-CompositeNTuple"><a class="docs-heading-anchor" href="#CompositeTuple-and-CompositeNTuple">CompositeTuple and CompositeNTuple</a><a id="CompositeTuple-and-CompositeNTuple-1"></a><a class="docs-heading-anchor-permalink" href="#CompositeTuple-and-CompositeNTuple" title="Permalink"></a></h3><p>A composite tuple (ntuple) can be considered as a tuple (ntuple) that is implemented by including an ordinary <a href="https://docs.julialang.org/en/v1/base/base/#Core.Tuple"><code>Tuple</code></a>(<a href="https://docs.julialang.org/en/v1/manual/types/#Vararg-Tuple-Types"><code>NTuple</code></a>) as its data attribute.</p><p>To take full advantages of the Julia base, the following interfaces are defined:</p><ul><li>inquiry of info: <code>length</code>, <code>eltype</code>, <code>hash</code></li><li>comparison between objects: <code>==</code>, <code>isequal</code></li><li>obtainment of old elements: <code>getindex</code></li><li>iteration: <code>iterate</code>, <code>keys</code>, <code>values</code>, <code>pairs</code></li><li>construction of new objects: <code>reverse</code></li></ul><p>Note that arithmetic operations and logical operations excluding <code>==</code> and <code>isequal</code> are not supported. Besides, a composite tuple is <strong>not</strong> a tuple since Julia has no abstract tuples.</p><h3 id="CompositeVector"><a class="docs-heading-anchor" href="#CompositeVector">CompositeVector</a><a id="CompositeVector-1"></a><a class="docs-heading-anchor-permalink" href="#CompositeVector" title="Permalink"></a></h3><p>A composite vector can be considered as a vector that is implemented by including a concrete subtype of <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.AbstractVector"><code>AbstractVector</code></a> as its data attribute, and it itself is a subtype of <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.AbstractVector"><code>AbstractVector</code></a>.</p><p>To take full advantages of the Julia base, the following interfaces are redefined:</p><ul><li>inquiry of info: <code>size</code>, <code>length</code></li><li>comparison between objects: <code>==</code>, <code>isequal</code></li><li>obtainment of old elements: <code>getindex</code></li><li>operation of old elements: <code>setindex!</code></li><li>addition of new elements: <code>push!</code>, <code>pushfirst!</code>, <code>insert!</code>, <code>append!</code>, <code>prepend!</code></li><li>removal of old elements: <code>splice!</code>, <code>deleteat!</code>, <code>pop!</code>, <code>popfirst!</code>, <code>empty!</code></li><li>construction of new objects: <code>empty</code>, <code>reverse</code>, <code>similar</code></li><li>iteration: <code>iterate</code>, <code>keys</code>, <code>values</code>, <code>pairs</code></li></ul><p>Note that arithmetic operations and logical operations excluding <code>==</code> and <code>isequal</code> are not supported.</p><h3 id="CompositeDict"><a class="docs-heading-anchor" href="#CompositeDict">CompositeDict</a><a id="CompositeDict-1"></a><a class="docs-heading-anchor-permalink" href="#CompositeDict" title="Permalink"></a></h3><p>A composite dict can be considered as a dict that is implemented by including a concrete subtype of <a href="https://docs.julialang.org/en/v1/base/collections/#Base.AbstractDict"><code>AbstractDict</code></a> as its data attribute and it itself is a subtype of <a href="https://docs.julialang.org/en/v1/base/collections/#Base.AbstractDict"><code>AbstractDict</code></a>.</p><p>To take full advantages of the Julia base, the following interfaces are redefined:</p><ul><li>inquiry of info: <code>isempty</code>, <code>length</code>, <code>haskey</code>, <code>in</code></li><li>comparison between objects: <code>==</code>, <code>isequal</code></li><li>obtainment of old elements: <code>get</code>, <code>getkey</code>, <code>getindex</code></li><li>operation and addition of elements: <code>push!</code>, <code>get!</code>, <code>setindex!</code></li><li>removal of old elements: <code>pop!</code>, <code>delete!</code>, <code>empty!</code></li><li>construction of new objects: <code>merge</code>, <code>empty</code></li><li>iteration: <code>iterate</code>, <code>keys</code>, <code>values</code>, <code>pairs</code></li></ul><h3 id="NamedContainer"><a class="docs-heading-anchor" href="#NamedContainer">NamedContainer</a><a id="NamedContainer-1"></a><a class="docs-heading-anchor-permalink" href="#NamedContainer" title="Permalink"></a></h3><p><a href="#QuantumLattices.Toolkit.NamedContainer"><code>NamedContainer</code></a> is just a wrapper (type alias) of Julia NamedTuple, but not a composite type.</p><p>Julia NamedTuple is useful to keep type stability of codes when we deal with inhomogeneous immutable dict-like objects, but its default constructor is not so convenient because the names and contents must be assigned pair by pair in a pair of parentheses explicitly. Therefore, we define a type alias of NamedTuple under the name of <a href="#QuantumLattices.Toolkit.NamedContainer"><code>NamedContainer</code></a>, so that we can construct a NamedTuple by the usual-formed constructor <a href="#QuantumLattices.Toolkit.NamedContainer"><code>NamedContainer</code></a>, e.g.</p><pre><code class="language-julia hljs">NamedContainer{(:a, :b)}((1, 2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(a = 1, b = 2)</code></pre><h3 id="Manual-3"><a class="docs-heading-anchor" href="#Manual-3">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.CompositeDict" href="#QuantumLattices.Toolkit.CompositeDict"><code>QuantumLattices.Toolkit.CompositeDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeDict{K, V}</code></pre><p>A composite dict can be considered as a dict that is implemented by including a concrete subtype of <code>AbstractDict</code> as its data attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L807-L811">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.CompositeNTuple" href="#QuantumLattices.Toolkit.CompositeNTuple"><code>QuantumLattices.Toolkit.CompositeNTuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeNTuple{N, T}</code></pre><p>A composite ntuple can be considered as a ntuple that is implemented by including an ordinary <code>NTuple</code> as its data attribute.</p><p>Alias for <code>CompositeTuple{NTuple{N, T}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L761-L767">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.CompositeTuple" href="#QuantumLattices.Toolkit.CompositeTuple"><code>QuantumLattices.Toolkit.CompositeTuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeTuple{T&lt;:Tuple}</code></pre><p>A composite tuple can be considered as a tuple that is implemented by including an ordinary <code>Tuple</code> as its data attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L733-L737">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.CompositeVector" href="#QuantumLattices.Toolkit.CompositeVector"><code>QuantumLattices.Toolkit.CompositeVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeVector{T}</code></pre><p>A composite vector can be considered as a vector that is implemented by including a concrete subtype of <code>AbstractVector</code> as its data attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L770-L774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.NamedContainer" href="#QuantumLattices.Toolkit.NamedContainer"><code>QuantumLattices.Toolkit.NamedContainer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NamedContainer{T, Names} = NamedTuple{Names, &lt;:Tuple{Vararg{T}}}</code></pre><p>NamedContainer is just a wrapper of Julia NamedTuple, but not a composite type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L844-L848">source</a></section></article><h2 id="Named-vectors"><a class="docs-heading-anchor" href="#Named-vectors">Named vectors</a><a id="Named-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Named-vectors" title="Permalink"></a></h2><p>A named vector is similar to a named tuple, which associate each of its values with a name. Although the names of a named vector cannot be changed, the values can be modified if needed. In contrast to the predefined <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple"><code>NamedTuple</code></a> in Julia, which employs the names as type parameters, we just implement a named vector as a composite struct equipped with the <code>getindex</code> and <code>setindex!</code> functions, with the fieldnames being its names. This simple implementation makes it possible to define your own concrete named vector with any of your preferred type names, and ensures that all instances of a certain concrete named vector share the same names. Therefore, if you are familiar with Python, you will find that our named vector is more qualified to be the counterpart of the <a href="https://docs.python.org/3.7/library/collections.html#collections.namedtuple"><code>namedtuple</code></a> in Python than the default Julia implementation. Last but not least important, it is also worth noted that <strong>a named vector is not a vector</strong>, as is similar to that a named tuple is not a tuple in Julia. This results from our basic expectation that a named vector should be more like a tuple other than a vector so that not all operations valid to vectors are also valid to named vectors.</p><h3 id="NamedVector"><a class="docs-heading-anchor" href="#NamedVector">NamedVector</a><a id="NamedVector-1"></a><a class="docs-heading-anchor-permalink" href="#NamedVector" title="Permalink"></a></h3><p><a href="#QuantumLattices.Toolkit.NamedVector"><code>NamedVector</code></a> defines the abstract type for all concrete named vectors.</p><p>Main features include:</p><ul><li>Values can be accessed or modified either by the <code>.</code> operator or by the <code>[]</code> operator.</li><li>Comparisons, such as <code>≡</code>, <code>≢</code>, <code>==</code>, <code>≠</code>, <code>&gt;</code>, <code>&lt;</code>, <code>≥</code>, <code>≤</code> are supported. Therefore a vector of named vectors can be sorted by the default <code>sort</code> function.</li><li>Hash is supported by <code>hash</code>. Therefore, a named vector can be used as the key of a dict or set.</li><li>Iteration over its fieldnames is supported by <code>keys</code>, over its values is supported by <code>values</code>, over its field-value pairs is supported by <code>pairs</code>.</li><li>A reverse iteration is also supported.</li></ul><p>To subtype it, please note:</p><ol><li>A concrete type can be either mutable or immutable as you need, which is different from tuples.</li><li>The fields of a concrete type can be of the same type or not. For the former, we denote the named vector as &quot;homogeneous&quot; while for the latter as &quot;inhomogeneous&quot;. For homogeneous ones, we define a sub abstract type, <a href="#QuantumLattices.Toolkit.HomoNamedVector"><code>HomoNamedVector</code></a> for further optimization of the default methods. See <a href="#HomoNamedVector">HomoNamedVector</a> below.</li><li>For all concrete subtypes, if inner constructors are defined, the one which has the same interface with the default one must be implemented. Otherwise, some functionalities will not work.</li><li>Arithmetic operations, such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>÷</code>, etc. are <strong>not</strong> supported. However, the function <code>map</code> is implemented, which can help users do the overloading of these operations.</li></ol><h3 id="HomoNamedVector"><a class="docs-heading-anchor" href="#HomoNamedVector">HomoNamedVector</a><a id="HomoNamedVector-1"></a><a class="docs-heading-anchor-permalink" href="#HomoNamedVector" title="Permalink"></a></h3><p><a href="#QuantumLattices.Toolkit.HomoNamedVector"><code>HomoNamedVector</code></a> is the subtype of <a href="#QuantumLattices.Toolkit.NamedVector"><code>NamedVector</code></a> that of all its fields share the same type. Compared to <a href="#QuantumLattices.Toolkit.NamedVector"><code>NamedVector</code></a>, one more default method is implemented with <a href="#QuantumLattices.Toolkit.HomoNamedVector"><code>HomoNamedVector</code></a>, i.e. <code>eltype</code>, which returns the type of its fields. This function ensures the type stability of all the methods that involves an iteration of the field values of a named vector. Therefore, homogeneous named vector are usually more efficient than inhomogeneous ones. Use homogeneous ones as much as possible unless the code efficiency does not matter.</p><p>To subtype <a href="#QuantumLattices.Toolkit.HomoNamedVector"><code>HomoNamedVector</code></a>, all the suggestions mentioned in the previous subsection for <a href="#QuantumLattices.Toolkit.NamedVector"><code>NamedVector</code></a> also applies. A recommended template for a subtype is</p><pre><code class="language-julia hljs">[mutable] struct YourNamedVector{T} &lt;: HomoNamedVector{T}
    filed1::T
    filed2::T
    ...
end</code></pre><h3 id="Manual-4"><a class="docs-heading-anchor" href="#Manual-4">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.HomoNamedVector" href="#QuantumLattices.Toolkit.HomoNamedVector"><code>QuantumLattices.Toolkit.HomoNamedVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HomoNamedVector{T}</code></pre><p>Abstract type for all homogeneous named vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L920-L924">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.NamedVector" href="#QuantumLattices.Toolkit.NamedVector"><code>QuantumLattices.Toolkit.NamedVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NamedVector</code></pre><p>Abstract type for all named vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L853-L857">source</a></section></article><h2 id="Vector-spaces"><a class="docs-heading-anchor" href="#Vector-spaces">Vector spaces</a><a id="Vector-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-spaces" title="Permalink"></a></h2><p>A <a href="https://en.wikipedia.org/wiki/Vector_space">vector space</a> is a linear space, in which the addition of vectors and multiplication of a vector by a scalar are defined.</p><p>Vector spaces are frequently encountered in physics, e.g. the Hilbert space in quantum mechanics. In this submodule, we only implement those with finite dimensions. We want to remark that in our implementation, a vector space is a subtype of an abstract vector, therefore, the bases always possess a order, which means, two vector spaces are not considered to be equal to each other even if their corresponding actual mathematical spaces are the same but the orders of the bases are different.</p><h3 id="VectorSpace"><a class="docs-heading-anchor" href="#VectorSpace">VectorSpace</a><a id="VectorSpace-1"></a><a class="docs-heading-anchor-permalink" href="#VectorSpace" title="Permalink"></a></h3><p><a href="#QuantumLattices.Toolkit.VectorSpace"><code>VectorSpace{B}</code></a> is the abstraction of a vector space, which has only one type parameter:</p><ul><li><code>B&lt;:Any</code>: the type of the bases of the vector space</li></ul><p>Basically, a subtype should implement the following 3 methods:</p><ol><li><pre><code class="language-julia hljs">Base.length(vs::VectorSpace) -&gt; Int</code></pre>Get the dimension of a vector space</li><li><pre><code class="language-julia hljs">Base.getindex(vs::VectorSpace{B}, i::Int)  where B -&gt; B</code></pre>Get the ith basis of a vector space</li><li><pre><code class="language-julia hljs">Base.searchsortedfirst(vs::VectorSpace{B}, basis::B) where B -&gt; Int</code></pre>Search the index of a basis in a vector space</li></ol><p>Other features include</p><ul><li>comparison: <code>==</code> and <code>isequal</code></li><li>iteration: <code>iterate</code></li><li>inquiry: <code>size</code>, <code>findfirst</code> and <code>in</code></li></ul><h3 id="Manual-5"><a class="docs-heading-anchor" href="#Manual-5">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-5" title="Permalink"></a></h3><p>Predefined types of vector spaces:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.VectorSpace" href="#QuantumLattices.Toolkit.VectorSpace"><code>QuantumLattices.Toolkit.VectorSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpace{B} &lt;: AbstractVector{B}</code></pre><p>Abstract vector space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L930-L934">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.NamedVectorSpace" href="#QuantumLattices.Toolkit.NamedVectorSpace"><code>QuantumLattices.Toolkit.NamedVectorSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NamedVectorSpace{B} &lt;: VectorSpace{B}</code></pre><p>Abstract named vector space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1048-L1052">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.SimpleNamedVectorSpace" href="#QuantumLattices.Toolkit.SimpleNamedVectorSpace"><code>QuantumLattices.Toolkit.SimpleNamedVectorSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleNamedVectorSpace{N, B} &lt;: NamedVectorSpace{B}</code></pre><p>Abstract simple named vector space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1064-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.ParameterSpace" href="#QuantumLattices.Toolkit.ParameterSpace"><code>QuantumLattices.Toolkit.ParameterSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParameterSpace{N, T, B} &lt;: SimpleNamedVectorSpace{N, B}</code></pre><p>Parameter space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1074-L1078">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.DirectProductedNamedVectorSpace" href="#QuantumLattices.Toolkit.DirectProductedNamedVectorSpace"><code>QuantumLattices.Toolkit.DirectProductedNamedVectorSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DirectProductedNamedVectorSpace{T&lt;:Tuple{Vararg{SimpleNamedVectorSpace}}, B&lt;:Tuple} &lt;: CompositeNamedVectorSpace{T, B}</code></pre><p>Direct producted named vector space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1111-L1115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.ZippedNamedVectorSpace" href="#QuantumLattices.Toolkit.ZippedNamedVectorSpace"><code>QuantumLattices.Toolkit.ZippedNamedVectorSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZippedNamedVectorSpace{T&lt;:Tuple{Vararg{SimpleNamedVectorSpace}}, B&lt;:Tuple} &lt;: CompositeNamedVectorSpace{T, B}</code></pre><p>Zipped named vector space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1099-L1103">source</a></section></article><p>Predefined types of vector space style:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.VectorSpaceStyle" href="#QuantumLattices.Toolkit.VectorSpaceStyle"><code>QuantumLattices.Toolkit.VectorSpaceStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceStyle</code></pre><p>The style of a concrete type of vector space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L940-L944">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.VectorSpaceEnumerative" href="#QuantumLattices.Toolkit.VectorSpaceEnumerative"><code>QuantumLattices.Toolkit.VectorSpaceEnumerative</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceEnumerative &lt;: VectorSpaceStyle</code></pre><p>Enumerative vector space style, which indicates that the vector space has a predefined content named <code>contents</code> that contains all its bases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L976-L980">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.VectorSpaceCartesian" href="#QuantumLattices.Toolkit.VectorSpaceCartesian"><code>QuantumLattices.Toolkit.VectorSpaceCartesian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceCartesian &lt;: VectorSpaceStyle</code></pre><p>Cartesian vector space style, which indicates that every basis in it could be represented by a Cartesian index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L986-L990">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.VectorSpaceDirectProducted" href="#QuantumLattices.Toolkit.VectorSpaceDirectProducted"><code>QuantumLattices.Toolkit.VectorSpaceDirectProducted</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceDirectProducted &lt;: VectorSpaceStyle</code></pre><p>Vector space style which indicates that a vector space is the direct product of its sub-components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1024-L1028">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.VectorSpaceDirectSummed" href="#QuantumLattices.Toolkit.VectorSpaceDirectSummed"><code>QuantumLattices.Toolkit.VectorSpaceDirectSummed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceDirectSummed &lt;: VectorSpaceStyle</code></pre><p>Vector space style which indicates that a vector space is the direct sum of its sub-components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1009-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.VectorSpaceZipped" href="#QuantumLattices.Toolkit.VectorSpaceZipped"><code>QuantumLattices.Toolkit.VectorSpaceZipped</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceZipped &lt;: VectorSpaceStyle</code></pre><p>Vector space style which indicates that a vector space is the zip of its sub-components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1037-L1041">source</a></section></article><h2 id="Simple-trees"><a class="docs-heading-anchor" href="#Simple-trees">Simple trees</a><a id="Simple-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-trees" title="Permalink"></a></h2><p>The aim of this set of functions and types is to represent the standard tree structure in <strong>efficiency-non-sensitive</strong> cases. Please note that the default implementation of tree methods are far from optimal in efficiency. Therefore, please <strong>DO NOT</strong> use it if you need an efficient tree for addition, deletion, sort and inquiry. This module of codes apply only when the structure of tree matters but not the efficiency.</p><h3 id="AbstractSimpleTree"><a class="docs-heading-anchor" href="#AbstractSimpleTree">AbstractSimpleTree</a><a id="AbstractSimpleTree-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractSimpleTree" title="Permalink"></a></h3><p><a href="#QuantumLattices.Toolkit.AbstractSimpleTree"><code>AbstractSimpleTree{N, D}</code></a> is the abstract type for all concrete trees. By design, it has two type parameters:</p><ul><li><code>N</code>: the type of the tree&#39;s node</li><li><code>D</code>: the type of the tree&#39;s data</li></ul><p>To fully utilize the methods designed for a tree structure, in our protocol, a concrete subtype must implement the following methods:</p><ul><li>inquiry related methods<ul><li><pre><code class="language-julia hljs">root(tree::AbstractSimpleTree{N}) where N -&gt; Union{N, Nothing}</code></pre>Get a tree&#39;s root node (<code>nothing</code> for empty trees)</li><li><pre><code class="language-julia hljs">haskey(tree::AbstractSimpleTree{N}, node::N) where N -&gt; Bool</code></pre>Check whether a node is in a tree.</li><li><pre><code class="language-julia hljs">length(tree::AbstractSimpleTree) -&gt; Int</code></pre>Get the number of a tree&#39;s nodes.</li><li><pre><code class="language-julia hljs">parent(tree::AbstractSimpleTree{N},
       node::N,
       superparent::Union{N, Nothing}=nothing
       ) where N -&gt; Union{N, Nothing}</code></pre>Get the parent of a tree&#39;s node or return superparent when the input node is the tree&#39;s root.</li><li><pre><code class="language-julia hljs">children(tree::AbstractSimpleTree{N}, node::N) where N -&gt; Vector{N}</code></pre>Get the children of a tree&#39;s node.</li></ul></li><li>structure modification related methods<ul><li><pre><code class="language-julia hljs">addnode!(tree::AbstractSimpleTree{N},
         parent::Union{N, Nothing},
         node::N
         ) where N -&gt; typeof(tree)</code></pre>Update the structure of a tree by adding a node. When the parent is <code>nothing</code>, the input tree must be empty and the input node becomes the tree&#39;s root.</li><li><pre><code class="language-julia hljs">deletenode!(tree::AbstractSimpleTree{N}, node::N) where N -&gt; typeof(tree)</code></pre>Update the structure of a tree by deleting a node.</li></ul></li><li>index related methods<ul><li><pre><code class="language-julia hljs">getindex(tree::AbstractSimpleTree{N, D}, node::N) where {N, D} -&gt; D</code></pre>Get the data of a tree&#39;s node</li><li><pre><code class="language-julia hljs">setindex!(tree::AbstractSimpleTree{N, D}, node::N, data::D) where {N, D}</code></pre>Set the data of a tree&#39;s node.</li></ul></li></ul><p>Based on these methods, we implement several generic functions for inquiries and manipulations</p><ul><li>inquiry for type parameters: <code>keytype</code>, <code>valtype</code>, <code>eltype</code></li><li>expansion over nodes/data-records: <code>keys</code>, <code>values</code>, <code>pairs</code></li><li>inquiry for info of nodes: <a href="#QuantumLattices.Toolkit.isleaf"><code>isleaf</code></a>, <a href="#QuantumLattices.Toolkit.level"><code>level</code></a></li><li>inquiry for nodes: <a href="#QuantumLattices.Toolkit.ancestor"><code>ancestor</code></a>, <a href="#QuantumLattices.Toolkit.descendants"><code>descendants</code></a>, <a href="#QuantumLattices.Toolkit.siblings"><code>siblings</code></a>, <a href="#QuantumLattices.Toolkit.leaves"><code>leaves</code></a></li><li>modification: <code>push!</code>, <code>append!</code>, <code>delete!</code>, <code>empty!</code></li></ul><p>And optionally, when a subtype implement the following method,</p><pre><code class="language-julia hljs">empty(tree::AbstractSimpleTree) -&gt; typeof(tree)</code></pre><p>which constructs an empty tree of the same type with the input one, two more methods are supported:</p><ul><li><a href="#QuantumLattices.Toolkit.subtree"><code>subtree</code></a>: Get a subtree starting from a node.</li><li><a href="#QuantumLattices.Toolkit.move!"><code>move!</code></a>: Move a subtree to a new position.</li></ul><h3 id="SimpleTreeCore-and-SimpleTree"><a class="docs-heading-anchor" href="#SimpleTreeCore-and-SimpleTree">SimpleTreeCore and SimpleTree</a><a id="SimpleTreeCore-and-SimpleTree-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleTreeCore-and-SimpleTree" title="Permalink"></a></h3><p>To implement all the prerequisites listed above costs a bit efforts. We provide two lazy ways to get over this:</p><ol><li>Inheritance <code>AbstractSimpleTree</code> with <code>TREECORE::SimpleTreeCore</code> as one of its attribute</li><li>Inclusion an attribute which is an instance of <a href="#QuantumLattices.Toolkit.SimpleTree"><code>SimpleTree</code></a></li></ol><h4 id="SimpleTreeCore"><a class="docs-heading-anchor" href="#SimpleTreeCore">SimpleTreeCore</a><a id="SimpleTreeCore-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleTreeCore" title="Permalink"></a></h4><p><a href="#QuantumLattices.Toolkit.SimpleTreeCore"><code>SimpleTreeCore{N, D}</code></a>, as the literal meaning indicates, is the core of a tree. It encapsulates all the data structures needed by the default implementation, which contains <strong>4</strong> attributes:</p><ul><li><code>root::N</code>: the tree&#39;s root node</li><li><code>contents::Dict{N, D}</code>: the tree&#39;s (node, data) pairs</li><li><code>parent::Dict{N, N}</code>: records of the parent of each of the tree&#39;s nodes</li><li><code>children::Dict{N, Vector{N}}</code>: records of the children of each of the tree&#39;s nodes</li></ul><p>As above, the first lazy way is to include this struct with the special name <code>TREECORE</code> in your concrete subtype as one of its attribute.</p><h4 id="SimpleTree"><a class="docs-heading-anchor" href="#SimpleTree">SimpleTree</a><a id="SimpleTree-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleTree" title="Permalink"></a></h4><p><a href="#QuantumLattices.Toolkit.SimpleTree"><code>SimpleTree{N, D}</code></a> is the minimum struct that implements all the default tree methods. You can include an instance of it as an attribute in your own type to utilize all the tree methods.</p><h3 id="Manual-6"><a class="docs-heading-anchor" href="#Manual-6">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-6" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.simpletreedepth" href="#QuantumLattices.Toolkit.simpletreedepth"><code>QuantumLattices.Toolkit.simpletreedepth</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">simpletreedepth</code></pre><p>Indicate that the iteration over a tree is depth-first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1236-L1240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.simpletreewidth" href="#QuantumLattices.Toolkit.simpletreewidth"><code>QuantumLattices.Toolkit.simpletreewidth</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">simpletreewidth</code></pre><p>Indicate that the iteration over a tree is width-first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1243-L1247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.AbstractSimpleTree" href="#QuantumLattices.Toolkit.AbstractSimpleTree"><code>QuantumLattices.Toolkit.AbstractSimpleTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSimpleTree{Node, Data}</code></pre><p>Abstract type for all concrete trees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1250-L1254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.SimpleTree" href="#QuantumLattices.Toolkit.SimpleTree"><code>QuantumLattices.Toolkit.SimpleTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleTree{N, D} &lt;: AbstractSimpleTree{N, D}</code></pre><p>The minimum tree structure that implements all the default tree methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1570-L1574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.SimpleTreeCore" href="#QuantumLattices.Toolkit.SimpleTreeCore"><code>QuantumLattices.Toolkit.SimpleTreeCore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleTreeCore()</code></pre><p>The core of a simple tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1217-L1221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.addnode!" href="#QuantumLattices.Toolkit.addnode!"><code>QuantumLattices.Toolkit.addnode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addnode!(tree::AbstractSimpleTree{N}, node::N) where N} -&gt; typeof(tree)
addnode!(tree::AbstractSimpleTree{N}, ::Nothing, node::N) where N -&gt; typeof(tree)
addnode!(tree::AbstractSimpleTree{N}, parent::N, node::N) where N -&gt; typeof(tree)</code></pre><p>Update the structure of a tree by adding a node. When the parent is <code>nothing</code>, the input tree must be empty and the input node becomes the tree&#39;s root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1333-L1339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.ancestor" href="#QuantumLattices.Toolkit.ancestor"><code>QuantumLattices.Toolkit.ancestor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ancestor(tree::AbstractSimpleTree{N}, node::N, generation::Int=1) where N -&gt; N</code></pre><p>Get the ancestor of a tree&#39;s node of the n-th generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1457-L1461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.children" href="#QuantumLattices.Toolkit.children"><code>QuantumLattices.Toolkit.children</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">children(tree::AbstractSimpleTree) -&gt; Vector{keytype(tree)}
children(tree::AbstractSimpleTree, ::Nothing) -&gt; Vector{keytype(tree)}
children(tree::AbstractSimpleTree{N}, node::N) where N -&gt; Vector{N}</code></pre><p>Get the children of a tree&#39;s node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1322-L1328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.deletenode!" href="#QuantumLattices.Toolkit.deletenode!"><code>QuantumLattices.Toolkit.deletenode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deletenode!(tree::AbstractSimpleTree{N}, node::N) where N -&gt; typeof(tree)</code></pre><p>Update the structure of a tree by deleting a node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1356-L1360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.descendants" href="#QuantumLattices.Toolkit.descendants"><code>QuantumLattices.Toolkit.descendants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">descendants(tree::AbstractSimpleTree{N}, node::N, generation::Int=1) where N -&gt; Vector{N}</code></pre><p>Get the descendants of a tree&#39;s node of the nth generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1471-L1475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.isleaf" href="#QuantumLattices.Toolkit.isleaf"><code>QuantumLattices.Toolkit.isleaf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isleaf(tree::AbstractSimpleTree{N}, node::N) where N -&gt; Bool</code></pre><p>Judge whether a tree&#39;s node is a leaf (a node without children) or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1436-L1440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.leaves" href="#QuantumLattices.Toolkit.leaves"><code>QuantumLattices.Toolkit.leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leaves(tree::AbstractSimpleTree) -&gt; Vector{keytype(tree)}</code></pre><p>Get a tree&#39;s leaves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1492-L1496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.level" href="#QuantumLattices.Toolkit.level"><code>QuantumLattices.Toolkit.level</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level(tree::AbstractSimpleTree{N}, node::N) where N -&gt; Int</code></pre><p>Get the level of tree&#39;s node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1443-L1447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.move!" href="#QuantumLattices.Toolkit.move!"><code>QuantumLattices.Toolkit.move!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move!(tree::AbstractSimpleTree{N}, node::N, parent::N) where N -&gt; typeof(tree)</code></pre><p>Move a subtree to a new position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1558-L1562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.root" href="#QuantumLattices.Toolkit.root"><code>QuantumLattices.Toolkit.root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">root(tree::AbstractSimpleTree) -&gt; Union{keytype(tree), Nothing}</code></pre><p>Get a tree&#39;s root node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1294-L1298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.siblings" href="#QuantumLattices.Toolkit.siblings"><code>QuantumLattices.Toolkit.siblings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">siblings(tree::AbstractSimpleTree{N}, node::N) where N -&gt; Vector{N}</code></pre><p>Get the siblings (other nodes sharing the same parent) of a tree&#39;s node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1485-L1489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumLattices.Toolkit.subtree" href="#QuantumLattices.Toolkit.subtree"><code>QuantumLattices.Toolkit.subtree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subtree(tree::AbstractSimpleTree{N}, node::N) where N -&gt; typeof(tree)</code></pre><p>Get a subtree whose root is <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/ff5724f9696932c3ac231583a8b55c0e1de94f60/src/Toolkit.jl#L1545-L1549">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../advanced topics/ManageProjects/">« Manage projects</a><a class="docs-footer-nextpage" href="../QuantumOperators/">Quantum operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Friday 10 November 2023 11:35">Friday 10 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
