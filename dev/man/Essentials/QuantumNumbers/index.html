<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum numbers · QuantumLattices.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-89508993-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-89508993-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://quantum-many-body.github.io/QuantumLattices.jl/latest/man/Essentials/QuantumNumbers/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="QuantumLattices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">QuantumLattices.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Unitcell Description</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/">Spatial info of a unitcell</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/InternalDegreesOfFreedom/">Internal degrees of freedom</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/CouplingsAmongDifferentDegreesOfFreedom/">Couplings among different degrees of freedom</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/GeneratorOfOperators/">Generator of operators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Engine App Interface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/EngineAppInterface/Introduction/">Introduction</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../Interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Prerequisites</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Prerequisites/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../Prerequisites/Combinatorics/">Combinatorics</a></li><li><a class="tocitem" href="../../Prerequisites/Traits/">Traits</a></li><li><a class="tocitem" href="../../Prerequisites/CompositeStructures/">Composite structures</a></li><li><a class="tocitem" href="../../Prerequisites/SimpleTrees/">Simple trees</a></li><li><a class="tocitem" href="../../Prerequisites/NamedVectors/">Named vectors</a></li><li><a class="tocitem" href="../../Prerequisites/VectorSpaces/">Vector spaces</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Essentials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Introduction/">Introduction</a></li><li><a class="tocitem" href="../QuantumAlgebras/">Quantum algebras</a></li><li class="is-active"><a class="tocitem" href>Quantum numbers</a><ul class="internal"><li><a class="tocitem" href="#AbelianNumber"><span>AbelianNumber</span></a></li><li><a class="tocitem" href="#AbelianNumbers"><span>AbelianNumbers</span></a></li><li><a class="tocitem" href="#qnmanual"><span>Manual</span></a></li></ul></li><li><a class="tocitem" href="../Spatials/">Spatials</a></li><li><a class="tocitem" href="../DegreesOfFreedom/">Degrees of freedom</a></li><li><a class="tocitem" href="../Terms/">Terms</a></li><li><a class="tocitem" href="../Frameworks/">Frameworks</a></li><li><a class="tocitem" href="../QuantumSystems/">Quantum Systems</a></li></ul></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../../developer/CodeStyle/">Code style guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Essentials</a></li><li class="is-active"><a href>Quantum numbers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantum numbers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/master/docs/src/man/Essentials/QuantumNumbers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-numbers"><a class="docs-heading-anchor" href="#Quantum-numbers">Quantum numbers</a><a id="Quantum-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-numbers" title="Permalink"></a></h1><p>Quantum numbers can be considered as the conserved labels for the bases of a Hilbert space when a quantum system hosts some symmetries. Here we only implement Abelian quantum numbers because non-Abelian ones are far more complicated yet much less used. In practice, quantum numbers can be integers or half integers, therefore, we use real numbers to denote them in this module for simplicity. Independent quantum numbers, such as the particle number and the spin z-component, can coexist at the same time. We use type <a href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumber"><code>AbelianNumber</code></a> to represent the complete set of independent ones for a single basis of a Hilbert space, and type <a href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers"><code>AbelianNumbers</code></a> to represent the whole quantum numbers for the total bases.</p><h2 id="AbelianNumber"><a class="docs-heading-anchor" href="#AbelianNumber">AbelianNumber</a><a id="AbelianNumber-1"></a><a class="docs-heading-anchor-permalink" href="#AbelianNumber" title="Permalink"></a></h2><p>The abstract type for the complete set of independent quantum numbers for a single basis.</p><p>Main features include:</p><ul><li>function <code>periods</code>: get the periods of the quantum numbers</li><li>arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>^</code>, <code>⊕</code>, <code>⊗</code></li><li>hashable: concrete instances can be used as keys for a dict or a set</li><li>iterable: concrete instances are iterable over their values</li><li>comparable: two concrete instances can be compared</li></ul><p>In particular, <code>AbelianNumber &lt;: HomoNamedVector{Float}</code>, all features supported by <code>HomoNamedVector</code> are also available for <code>HomoNamedVector</code>. See also <a href="../../Prerequisites/NamedVectors/#HomoNamedVector">HomoNamedVector</a>.</p><p>For convenience, <strong>3</strong> kinds of quantum numbers are predefined in this module, i.e.</p><ul><li><a href="#QuantumLattices.Essentials.QuantumNumbers.SQN"><code>SQN</code></a>: for spin z-component reserved systems</li><li><a href="#QuantumLattices.Essentials.QuantumNumbers.PQN"><code>PQN</code></a>: for particle number reserved systems</li><li><a href="#QuantumLattices.Essentials.QuantumNumbers.SPQN"><code>SPQN</code></a>: for both particle number and spin-z component reserved systems</li></ul><p>Users who want to define their own <span>$Z_N$</span>-like quantum numbers must handle the periodicity in the construction function, otherwise, wrong results will be get when arithmetic operations, such as <code>+</code> or <code>-</code>, are involved. It is recommended to use the macro <a href="#QuantumLattices.Essentials.QuantumNumbers.@abeliannumber-Tuple{Any, Any, Any}"><code>@abeliannumber</code></a> to define your own concrete <code>AbelianNumber</code>s.</p><h2 id="AbelianNumbers"><a class="docs-heading-anchor" href="#AbelianNumbers">AbelianNumbers</a><a id="AbelianNumbers-1"></a><a class="docs-heading-anchor-permalink" href="#AbelianNumbers" title="Permalink"></a></h2><p>The whole quantum numbers for the total bases.</p><p>By design, a <a href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers"><code>AbelianNumbers{QN}</code></a> has one type parameter:</p><ul><li><code>QN&lt;:AbelianNumber</code>: the type of the quantum numbers contained in it</li></ul><p>And 3 attributes:</p><ul><li><code>form::Char</code>: Its form, whose value must be one of the followings<ul><li><code>&#39;G&#39;</code>: the general form, which has no restriction for its <code>contents</code></li><li><code>&#39;U&#39;</code>: the unitary form, which requires no duplicates in its <code>contents</code></li><li><code>&#39;C&#39;</code>: the canonical form, which requires both no duplicates and ascending-order in its <code>contents</code></li></ul>Usually, G-formed and U-formed <code>AbelianNumbers</code>es can be transformed to the corresponding C-formed ones by the <a href="#Base.sort-Tuple{AbelianNumbers}"><code>sort</code></a> function.</li><li><code>contents::Vector{QN}</code>: The quantum numbers contained in it. To achieve high efficiency, it is required to be an homogenous array of a certain kind of concrete <code>AbelianNumber</code>.</li><li><code>indptr::Vector{Int}</code>: The indptr of the quantum numbers contained in it, which is similar to the <code>colptr</code> attribute of a <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/#man-csc-1">CSC sparse matrix</a> and records the compression info of its <code>contents</code>.</li></ul><p>Main features include:</p><ul><li>function <code>eltype</code>: get the concrete type of the quantum numbers it contains</li><li>index access: get the contents directly by the <code>getindex</code> function</li><li>arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>^</code>, <code>⊗</code>, <code>⊕</code></li><li>iterable: various iteration supports, including functions such as <code>iterate</code>, <code>keys</code>, <code>values</code> and <code>pairs</code></li></ul><p>For a complete summation of its features, please refer to the <a href="#qnmanual">manual</a>.</p><p>For convenience, <strong>3</strong> functions are predefined to generate the <code>AbelianNumbers</code> of common physical systems, i.e.</p><ul><li><a href="#QuantumLattices.Essentials.QuantumNumbers.SQNS-Tuple{Real}"><code>SQNS</code></a>: a single spin</li><li><a href="#QuantumLattices.Essentials.QuantumNumbers.PQNS-Tuple{Real}"><code>PQNS</code></a>: a single-particle state with at most <code>N</code> identical particles</li><li><a href="#QuantumLattices.Essentials.QuantumNumbers.SPQNS-Tuple{Real}"><code>SPQNS</code></a>: a single site with internal degrees of freedom that can be ascribed to a spin</li></ul><h2 id="qnmanual"><a class="docs-heading-anchor" href="#qnmanual">Manual</a><a id="qnmanual-1"></a><a class="docs-heading-anchor-permalink" href="#qnmanual" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OrderedCollections.OrderedDict-Tuple{AbelianNumbers, Symbol}" href="#OrderedCollections.OrderedDict-Tuple{AbelianNumbers, Symbol}"><code>OrderedCollections.OrderedDict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OrderedDict(qns::AbelianNumbers, choice::Symbol) -&gt; OrderedDict
OrderedDict(qns::AbelianNumbers, ::Val{:indptr}) -&gt; OrderedDict{qns|&gt;eltype, UnitRange{Int}}
OrderedDict(qns::AbelianNumbers, ::Val{:counts}) -&gt; OrderedDict{qns|&gt;eltype, Int}</code></pre><p>Convert an <code>AbelianNumbers</code> to an ordered dict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L295-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.AbelianNumber" href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumber"><code>QuantumLattices.Essentials.QuantumNumbers.AbelianNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for all concrete quantum numbers for a single basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers" href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers"><code>QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbelianNumbers{QN&lt;:AbelianNumber} &lt;: EnumerativeVectorSpace{QN}</code></pre><p>The whole quantum numbers of the total bases of a Hilbert space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers" href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers"><code>QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbelianNumbers(qn::AbelianNumber, count::Int=1)</code></pre><p>Construct an <code>AbelianNumbers</code> with one unique quantum number which occurs <code>count</code> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers-Tuple{Char, Vector{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:AbelianNumber, Vector{Int64}, Symbol}" href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers-Tuple{Char, Vector{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:AbelianNumber, Vector{Int64}, Symbol}"><code>QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AbelianNumbers(form::Char, contents::Vector{&lt;:AbelianNumber}, indptr::Vector{Int}, choice::Symbol)
AbelianNumbers(form::Char, contents::Vector{&lt;:AbelianNumber}, counts::Vector{Int}, ::Val{:counts})
AbelianNumbers(form::Char, contents::Vector{&lt;:AbelianNumber}, indptr::Vector{Int}, ::Val{:indptr})</code></pre><p>Construct an <code>AbelianNumbers</code> from a vector of concrete quantum numbers and an vector containing their counts or indptr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L188-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var&quot;#s3&quot;, var&quot;#s2&quot;} where {var&quot;#s3&quot;&lt;:AbelianNumber, var&quot;#s2&quot;&lt;:(UnitRange{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer)}}" href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var&quot;#s3&quot;, var&quot;#s2&quot;} where {var&quot;#s3&quot;&lt;:AbelianNumber, var&quot;#s2&quot;&lt;:(UnitRange{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer)}}"><code>QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AbelianNumbers(od::OrderedDict{&lt;:AbelianNumber, &lt;:UnitRange{&lt;:Integer}})</code></pre><p>Construct an <code>AbelianNumbers</code> from an ordered dict containing concrete quantum numbers and their slices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var&quot;#s4&quot;, var&quot;#s3&quot;} where {var&quot;#s4&quot;&lt;:AbelianNumber, var&quot;#s3&quot;&lt;:Integer}}" href="#QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var&quot;#s4&quot;, var&quot;#s3&quot;} where {var&quot;#s4&quot;&lt;:AbelianNumber, var&quot;#s3&quot;&lt;:Integer}}"><code>QuantumLattices.Essentials.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AbelianNumbers(od::OrderedDict{&lt;:AbelianNumber, &lt;:Integer})</code></pre><p>Construct an <code>AbelianNumbers</code> from an ordered dict containing concrete quantum numbers and their counts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.Momentum" href="#QuantumLattices.Essentials.QuantumNumbers.Momentum"><code>QuantumLattices.Essentials.QuantumNumbers.Momentum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Momentum &lt;: AbelianNumber</code></pre><p>Abstract type for momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L717-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.Momentum1D" href="#QuantumLattices.Essentials.QuantumNumbers.Momentum1D"><code>QuantumLattices.Essentials.QuantumNumbers.Momentum1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Momentum1D{N}(k::Real) where N</code></pre><p>One dimensional momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L724-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.Momentum2D" href="#QuantumLattices.Essentials.QuantumNumbers.Momentum2D"><code>QuantumLattices.Essentials.QuantumNumbers.Momentum2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Momentum2D{N}(k₁::Real, k₂::Real) where N
Momentum2D{N₁, N₂}(k₁::Real, k₂::Real) where {N₁, N₂}</code></pre><p>Two dimensional momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L740-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.Momentum3D" href="#QuantumLattices.Essentials.QuantumNumbers.Momentum3D"><code>QuantumLattices.Essentials.QuantumNumbers.Momentum3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Momentum3D{N}(k₁::Real, k₂::Real, k₃::Real) where N
Momentum3D{N₁, N₂, N₃}(k₁::Real, k₂::Real, k₃::Real) where {N₁, N₂, N₃}</code></pre><p>Three dimensional momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L762-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.PQN" href="#QuantumLattices.Essentials.QuantumNumbers.PQN"><code>QuantumLattices.Essentials.QuantumNumbers.PQN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PQN(N::Real)</code></pre><p>The concrete <code>AbelianNumber</code> of a quantum system with particle number <code>N</code> conserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L674-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.SPQN" href="#QuantumLattices.Essentials.QuantumNumbers.SPQN"><code>QuantumLattices.Essentials.QuantumNumbers.SPQN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SPQN(N::Real, Sz::Real)</code></pre><p>The concrete <code>AbelianNumber</code> of a quantum system with both particle number <code>N</code> and spin z-component <code>Sz</code> conserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L681-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.SQN" href="#QuantumLattices.Essentials.QuantumNumbers.SQN"><code>QuantumLattices.Essentials.QuantumNumbers.SQN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SQN(Sz::Real)</code></pre><p>The concrete <code>AbelianNumber</code> of a quantum system with spin z-component <code>Sz</code> conserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L667-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.@abeliannumber-Tuple{Any, Any, Any}" href="#QuantumLattices.Essentials.QuantumNumbers.@abeliannumber-Tuple{Any, Any, Any}"><code>QuantumLattices.Essentials.QuantumNumbers.@abeliannumber</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@abeliannumber typename fields periods</code></pre><p>Construct a concrete <code>AbelianNumber</code> with the type name being <code>typename</code>, fieldnames specified by <code>fields</code> and periods specified by <code>periods</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Integer, AbelianNumbers}" href="#Base.:*-Tuple{Integer, AbelianNumbers}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(factor::Integer, qns::AbelianNumbers) -&gt; AbelianNumbers
*(qns::AbelianNumbers, factor::Integer) -&gt; AbelianNumbers</code></pre><p>Overloaded <code>*</code> operator for the multiplication between an integer and an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L477-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Integer, AbelianNumber}" href="#Base.:*-Tuple{Integer, AbelianNumber}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(factor::Integer, qn::AbelianNumber) -&gt; typeof(qn)
*(qn::AbelianNumber, factor::Integer) -&gt; typeof(qn)</code></pre><p>Overloaded <code>*</code> operator for the multiplication between an integer and an <code>AbelianNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{AbelianNumbers}" href="#Base.:+-Tuple{AbelianNumbers}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(qns::AbelianNumbers) -&gt; AbelianNumbers
+(qn::QN, qns::AbelianNumbers{QN}) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}
+(qns::AbelianNumbers{QN}, qn::QN) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}</code></pre><p>Overloaded <code>+</code> operator for <code>AbelianNumber</code>/<code>AbelianNumbers</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>The addition between an <code>AbelianNumbers</code> and an <code>AbelianNumber</code> is just a global shift of the contents of the <code>AbelianNumbers</code> by the <code>AbelianNumber</code>, therefore, the result is an <code>AbelianNumbers</code>.</li><li><code>+</code> cannot be used between two <code>AbelianNumbers</code> because the result is ambiguous. Instead, use <code>⊕</code> for direct sum and <code>⊗</code> for direct product.</li><li>To ensure type stability, an <code>AbelianNumber</code> and an <code>AbelianNumbers</code> can be added together if and only if the former&#39;s type is the same with the latter&#39;s eltype.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L439-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{AbelianNumber}" href="#Base.:+-Tuple{AbelianNumber}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(qn::AbelianNumber) -&gt; typeof(qn)
+(qn::QN, qns::QN...) where {QN&lt;:AbelianNumber} -&gt; QN</code></pre><p>Overloaded <code>+</code> operator for <code>AbelianNumber</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To ensure type stability, two <code>AbelianNumber</code> can be added together if and only if they are of the same type.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L45-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{AbelianNumbers}" href="#Base.:--Tuple{AbelianNumbers}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(qns::AbelianNumbers) -&gt; AbelianNumbers
-(qn::QN, qns::AbelianNumbers{QN}) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}
-(qns::AbelianNumbers{QN}, qn::QN) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}</code></pre><p>Overloaded <code>-</code> operator for <code>AbelianNumber</code>/<code>AbelianNumbers</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>The subtraction between an <code>AbelianNumbers</code> and an <code>AbelianNumber</code> is just a global shift of the contents of the <code>AbelianNumbers</code> by the <code>AbelianNumber</code>, therefore, the result is an <code>AbelianNumbers</code>.</li><li><code>-</code> cannot be used between two <code>AbelianNumbers</code> because the result is ambiguous. Instead, use <code>⊕</code> with signs for direct sum and <code>⊗</code> with signs for direct product.</li><li>To ensure type stability, an <code>AbelianNumber</code> can be subtracted by an <code>AbelianNumbers</code> or vice versa if and only if the former&#39;s type is the same with the latter&#39;s eltype.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L456-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{AbelianNumber}" href="#Base.:--Tuple{AbelianNumber}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(qn::AbelianNumber) -&gt; typeof(qn)
-(qn1::QN, qn2::QN) where {QN&lt;:AbelianNumber} -&gt; QN</code></pre><p>Overloaded <code>-</code> operator for <code>AbelianNumber</code> and <code>AbelianNumbers</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To ensure type stability, an <code>AbelianNumber</code> can be subtracted by another <code>AbelianNumber</code> if and only if they are of the same type.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{AbelianNumber, Integer}" href="#Base.:^-Tuple{AbelianNumber, Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(qn::AbelianNumber, factor::Integer) -&gt; typeof(qn)</code></pre><p>Overloaded <code>^</code> operator for <code>AbelianNumber</code>.</p><p>This operation translates into the direct product of <code>factor</code> copies of <code>qn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{AbelianNumbers, Integer}" href="#Base.:^-Tuple{AbelianNumbers, Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(qns::AbelianNumbers, factor::Integer) -&gt; AbelianNumbers</code></pre><p>Overloaded <code>^</code> operator for <code>AbelianNumbers</code>.</p><p>This operation translates into the direct product of <code>factor</code> copies of <code>qns</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L488-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter-Union{Tuple{QN}, Tuple{QN, AbelianNumbers{QN}}} where QN&lt;:AbelianNumber" href="#Base.filter-Union{Tuple{QN}, Tuple{QN, AbelianNumbers{QN}}} where QN&lt;:AbelianNumber"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter(target::QN, qns::AbelianNumbers{QN}) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}
filter(targets::Tuple{Vararg{QN}}, qns::AbelianNumbers{QN}) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}</code></pre><p>Find a subset of an <code>AbelianNumbers</code> by picking out the target quantum numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L381-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findall-Union{Tuple{QN}, Tuple{Union{Tuple{Vararg{QN, N} where N}, QN}, AbelianNumbers{QN}, Symbol}} where QN&lt;:AbelianNumber" href="#Base.findall-Union{Tuple{QN}, Tuple{Union{Tuple{Vararg{QN, N} where N}, QN}, AbelianNumbers{QN}, Symbol}} where QN&lt;:AbelianNumber"><code>Base.findall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, choice::Symbol) where {QN&lt;:AbelianNumber} -&gt; Vector{Int}
findall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, ::Val{:compression}) where {QN&lt;:AbelianNumber} -&gt; Vector{Int})
findall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, ::Val{:expansion}) where {QN&lt;:AbelianNumber} -&gt; Vector{Int}</code></pre><p>Find all the indices of the target quantum numbers in the contents or the expansion of an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L349-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbelianNumbers, UnitRange{Int64}}" href="#Base.getindex-Tuple{AbelianNumbers, UnitRange{Int64}}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(qns::AbelianNumbers, slice::UnitRange{Int}) -&gt; AbelianNumbers
getindex(qns::AbelianNumbers, indices::Vector{Int}) -&gt; AbelianNumbers</code></pre><p>Overloaded <code>[]</code> operator.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For an <code>AbelianNumbers</code>, all the <code>getindex</code> functions act on its <code>contents</code>, i.e. its compressed data, but not on its expansion, i.e. the uncompressed data. This definition is consistent with the size of an <code>AbelianNumbers</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L243-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{AbelianNumbers}" href="#Base.keys-Tuple{AbelianNumbers}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keys(qns::AbelianNumbers) -&gt; Vector{qns|&gt;eltype}</code></pre><p>Iterate over the concrete <code>AbelianNumber</code>s contained in an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron-Tuple{Vararg{AbelianNumber, N} where N}" href="#Base.kron-Tuple{Vararg{AbelianNumber, N} where N}"><code>Base.kron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kron(qns::Vararg{AbelianNumber}; signs=positives(qns))-&gt; eltype(qns)</code></pre><p>Get the direct product of some <code>AbelianNumber</code>s.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Physically, the direct product of a couple of <code>AbelianNumber</code>s are defined through the direct product of the bases of the Hilbert spaces they represent. Apparently, the result is still an <code>AbelianNumber</code> whose dimension is 1. At the same time, each component of the result is obtained by a summation of the corresponding components of the inputs with the correct signs. This is a direct consequence of the Abelian nature of our quantum numbers.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L97-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron-Union{Tuple{Vararg{AbelianNumbers{QN}, N} where N}, Tuple{QN}} where QN&lt;:AbelianNumber" href="#Base.kron-Union{Tuple{Vararg{AbelianNumbers{QN}, N} where N}, Tuple{QN}} where QN&lt;:AbelianNumber"><code>Base.kron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kron(qnses::AbelianNumbers{QN}...; signs=positives(qnses)) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}</code></pre><p>Get the direct product of some <code>AbelianNumbers</code>es.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Physically, the direct product of a couple of <code>AbelianNumbers</code>es are defined by the direct product of the bases of the Hilbert spaces they represent. Therefore, the dimension of the result equals the product of those of the inputs. Meanwhile, each quantum number in the contents of the result is obtained by a summation of the corresponding quantum numbers of the inputs with the correct signs. This is a direct consequence of the Abelian nature of our quantum numbers.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L542-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs-Tuple{AbelianNumbers, Symbol}" href="#Base.pairs-Tuple{AbelianNumbers, Symbol}"><code>Base.pairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pairs(qns::AbelianNumbers, choice::Symbol)
pairs(qns::AbelianNumbers, ::Val{:indptr})
pairs(qns::AbelianNumbers, ::Val{:counts})</code></pre><p>Iterate over the <code>AbelianNumber=&gt;slice</code> or <code>AbelianNumber=&gt;count</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L285-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prod-Union{Tuple{Vararg{AbelianNumbers{QN}, N} where N}, Tuple{QN}} where QN&lt;:AbelianNumber" href="#Base.prod-Union{Tuple{Vararg{AbelianNumbers{QN}, N} where N}, Tuple{QN}} where QN&lt;:AbelianNumber"><code>Base.prod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prod(qnses::AbelianNumbers{QN}...;
    signs=positives(qnses)
    ) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}, Dict{QN, Dict{NTuple{length(qnses), QN}, UnitRange{Int}}}</code></pre><p>Unitary Kronecker product of several <code>AbelianNumbers</code>es. The product result as well as the records of the product will be returned.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>All input <code>AbelianNumbers</code> must be &#39;U&#39; formed or &#39;C&#39; formed.</li><li>Since duplicate quantum number are not allowed in &#39;U&#39; formed and &#39;C&#39; formed <code>AbelianNumbers</code>es, in general, there exists a merge process of duplicate quantum numbers in the result. Therefore, records are needed to keep track of this process, which will be returned along with the product result. The records are stored in a <code>Dict{QN, Dict{NTuple{NTuple{length(qnses), QN}, UnitRange{Int}}}</code> typed dict, in which, for each nonduplicate quantum number <code>qn</code> in the result, there exist a record <code>Dict((qn₁, qn₂, ...)=&gt;start:stop, ...)</code> telling what quantum numbers <code>(qn₁, qn₂, ...)</code> a merged duplicate <code>qn</code> comes from and what slice <code>start:stop</code> this merged duplicate corresponds in the result.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L567-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort-Tuple{AbelianNumbers}" href="#Base.sort-Tuple{AbelianNumbers}"><code>Base.sort</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort(qns::AbelianNumbers) -&gt; Tuple{AbelianNumbers, Vector{Int}}</code></pre><p>Sort the quantum numbers of an <code>AbelianNumbers</code>, return the sorted <code>AbelianNumbers</code> and the permutation array that sorts the expansion of the original <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union-Tuple{Vararg{AbelianNumber, N} where N}" href="#Base.union-Tuple{Vararg{AbelianNumber, N} where N}"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">union(qns::AbelianNumber...; signs=positives(qns)) -&gt; AbelianNumbers
union(qnses::AbelianNumbers{QN}...; signs=positives(qnses)) where {QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}</code></pre><p>Get the direct sum of some <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Physically, the direct sum of a couple of <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es is defined by the direct sum of the bases of the Hilbert spaces they represent. Therefore, the dimension of the result equals the summation of those of the inputs. As a consequence, even for <code>AbelianNumber</code>s, the result will be an <code>AbelianNumbers</code> because the dimension of the result is greater than 1.</li><li>Signs of <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es can be provided when getting their direct sums.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L513-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values-Tuple{AbelianNumbers, Symbol}" href="#Base.values-Tuple{AbelianNumbers, Symbol}"><code>Base.values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">values(qns::AbelianNumbers, choice::Symbol)
values(qns::AbelianNumbers, ::Val{:indptr})
values(qns::AbelianNumbers, ::Val{:counts})</code></pre><p>Iterate over the slices/counts of the <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L274-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.PQNS-Tuple{Real}" href="#QuantumLattices.Essentials.QuantumNumbers.PQNS-Tuple{Real}"><code>QuantumLattices.Essentials.QuantumNumbers.PQNS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PQNS(N::Real) -&gt; AbelianNumbers{PQN}</code></pre><p>Construct the <code>AbelianNumbers</code> of the Hilbert space of a single-particle state with at most <code>N</code> identical particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L695-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.SPQNS-Tuple{Real}" href="#QuantumLattices.Essentials.QuantumNumbers.SPQNS-Tuple{Real}"><code>QuantumLattices.Essentials.QuantumNumbers.SPQNS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SPQNS(S::Real) -&gt; AbelianNumbers{SPQN}</code></pre><p>Construct the <code>AbelianNumbers</code> of the Hilbert space of a single site with internal degrees of freedom that can be ascribed to a spin <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L702-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.SQNS-Tuple{Real}" href="#QuantumLattices.Essentials.QuantumNumbers.SQNS-Tuple{Real}"><code>QuantumLattices.Essentials.QuantumNumbers.SQNS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SQNS(S::Real) -&gt; AbelianNumbers{SQN}</code></pre><p>Construct the <code>AbelianNumbers</code> of the Hilbert space of a single spin <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L688-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.periods" href="#QuantumLattices.Essentials.QuantumNumbers.periods"><code>QuantumLattices.Essentials.QuantumNumbers.periods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">periods</code></pre><p>The generic function that used to define the period of each component of a concrete <code>AbelianNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.positives-Union{Tuple{Tuple{Vararg{Any, N}}}, Tuple{N}} where N" href="#QuantumLattices.Essentials.QuantumNumbers.positives-Union{Tuple{Tuple{Vararg{Any, N}}}, Tuple{N}} where N"><code>QuantumLattices.Essentials.QuantumNumbers.positives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">positives(inputs::NTuple{N, Any}) where N -&gt; NTuple{N, Int}</code></pre><p>Return a tuple of all positive signs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.regularize!-Union{Tuple{QN}, Tuple{Type{QN}, AbstractVector{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:Real}} where QN&lt;:AbelianNumber" href="#QuantumLattices.Essentials.QuantumNumbers.regularize!-Union{Tuple{QN}, Tuple{Type{QN}, AbstractVector{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:Real}} where QN&lt;:AbelianNumber"><code>QuantumLattices.Essentials.QuantumNumbers.regularize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regularize!(::Type{QN}, array::AbstractVector{&lt;:Real}) where {QN&lt;:AbelianNumber} -&gt; typeof(array)
regularize!(::Type{QN}, array::AbstractMatrix{&lt;:Real}) where {QN&lt;:AbelianNumber} -&gt; typeof(array)</code></pre><p>Regularize the elements of an array in place so that it can represent quantum numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Essentials.QuantumNumbers.regularize-Union{Tuple{QN}, Tuple{Type{QN}, AbstractVecOrMat{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:Real}} where QN&lt;:AbelianNumber" href="#QuantumLattices.Essentials.QuantumNumbers.regularize-Union{Tuple{QN}, Tuple{Type{QN}, AbstractVecOrMat{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:Real}} where QN&lt;:AbelianNumber"><code>QuantumLattices.Essentials.QuantumNumbers.regularize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regularize(::Type{QN}, array::Union{AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}}) where {QN&lt;:AbelianNumber} -&gt; typeof(array)</code></pre><p>Regularize the elements of an array and return a copy that can represent quantum numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.:⊕-Tuple{Vararg{AbelianNumber, N} where N}" href="#QuantumLattices.Interfaces.:⊕-Tuple{Vararg{AbelianNumber, N} where N}"><code>QuantumLattices.Interfaces.:⊕</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊕(qns::AbelianNumber...) -&gt; AbelianNumbers{qns|&gt;eltype}
⊕(qnses::AbelianNumbers...) -&gt; qnses|&gt;eltype</code></pre><p>Get the direct sum of some <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L497-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.:⊗-Tuple{Vararg{AbelianNumber, N} where N}" href="#QuantumLattices.Interfaces.:⊗-Tuple{Vararg{AbelianNumber, N} where N}"><code>QuantumLattices.Interfaces.:⊗</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊗(qns::AbelianNumber...) -&gt; eltype(qns)</code></pre><p>Get the direct product of some <code>AbelianNumber</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.:⊗-Tuple{Vararg{AbelianNumbers, N} where N}" href="#QuantumLattices.Interfaces.:⊗-Tuple{Vararg{AbelianNumbers, N} where N}"><code>QuantumLattices.Interfaces.:⊗</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊗(qnses::AbelianNumbers...) -&gt; eltype(qnses)</code></pre><p>Get the direct product of some <code>AbelianNumbers</code>es.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L506-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.decompose-Union{Tuple{QN}, Tuple{QN, Vararg{AbelianNumbers{QN}, N} where N}} where QN&lt;:AbelianNumber" href="#QuantumLattices.Interfaces.decompose-Union{Tuple{QN}, Tuple{QN, Vararg{AbelianNumbers{QN}, N} where N}} where QN&lt;:AbelianNumber"><code>QuantumLattices.Interfaces.decompose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decompose(target::QN, qnses::AbelianNumbers{QN}...;
    signs=positives(qnses),
    method=:montecarlo,
    nmax=20
    ) where {QN&lt;:AbelianNumber} -&gt; Vector{NTuple{length(qnses), Int}}</code></pre><p>Find a couple of decompositions of <code>target</code> with respect to <code>qnses</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A tuple of integers <code>(i₁, i₂, ...)</code> is called a decomposition of a given <code>target</code> with respect to the given <code>qnses</code> if and only if they satisfy the &quot;decomposition rule&quot;:</p><p class="math-container">\[\sum_\text{j} \text{signs}[\text{j}]\times\text{qnses}[\text{j}][\text{i}_{\text{j}}]==\text{target}\]</p><p>This equation is in fact a set of restricted <a href="https://en.wikipedia.org/wiki/Diophantine_equation#Linear_Diophantine_equations">linear Diophantine equations</a>. Indeed, our quantum numbers are always discrete Abelian ones and all instances of a concrete <code>AbelianNumber</code> forms a <a href="https://en.wikipedia.org/wiki/Module_(mathematics)">module</a> over the <a href="https://en.wikipedia.org/wiki/Ring_(mathematics)">ring</a> of integers. Therefore, each quantum number can be represented as a integral multiple of the unit element of the Abelian module, which results in the final reduction of the above equation to a set of linear Diophantine equations. Then finding a decomposition is equivalent to find a solution of the reduced linear Diophantine equations, with the restriction that the quantum numbers constructed from the solution should be in the corresponding <code>qnses</code>. Here we provide two methods to find such decompositions, one is by brute force, and the other is by Monte Carlo simulations.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L604-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.dimension-Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:AbelianNumber}" href="#QuantumLattices.Interfaces.dimension-Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:AbelianNumber}"><code>QuantumLattices.Interfaces.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dimension(::Type{&lt;:AbelianNumber}) -&gt; Int
dimension(::AbelianNumber) -&gt; Int</code></pre><p>The dimension of the Hilbert space an <code>AbelianNumber</code> represents. Apparently, this is always 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.expand-Tuple{AbelianNumbers, Symbol}" href="#QuantumLattices.Interfaces.expand-Tuple{AbelianNumbers, Symbol}"><code>QuantumLattices.Interfaces.expand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand(qns::AbelianNumbers, choice::Symbol)
expand(qns::AbelianNumbers, ::Val{:contents}) -&gt; Vector{eltype(qns)}
expand(qns::AbelianNumbers, ::Val{:indices}) -&gt; Vector{Int}</code></pre><p>Expand the contents or indices of an <code>AbelianNumbers</code> to the uncompressed form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L412-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.permute-Tuple{AbelianNumbers, Vector{Int64}, Symbol}" href="#QuantumLattices.Interfaces.permute-Tuple{AbelianNumbers, Vector{Int64}, Symbol}"><code>QuantumLattices.Interfaces.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permute(qns::AbelianNumbers, permutation::Vector{Int}, choice::Symbol) -&gt; AbelianNumbers
permute(qns::AbelianNumbers, permutation::Vector{Int}, ::Val{:compression}) -&gt; AbelianNumbers
permute(qns::AbelianNumbers, permutation::Vector{Int}, ::Val{:expansion}) -&gt; AbelianNumbers</code></pre><p>Reorder the quantum numbers contained in an <code>AbelianNumbers</code> with a permutation and return the new one.</p><p>For <code>:compression</code> case, the permutation is for the compressed contents of the original <code>AbelianNumbers</code> while for <code>:expansion</code> case, the permutation is for the expanded contents of the original <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/4e2f1a5d9d051d57690ee651880e1ca47e794aa1/src/Essentials/QuantumNumbers.jl#L390-L398">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../QuantumAlgebras/">« Quantum algebras</a><a class="docs-footer-nextpage" href="../Spatials/">Spatials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 10 September 2021 12:21">Friday 10 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
