<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spatial information of a unitcell · QuantumLattices.jl</title><meta name="title" content="Spatial information of a unitcell · QuantumLattices.jl"/><meta property="og:title" content="Spatial information of a unitcell · QuantumLattices.jl"/><meta property="twitter:title" content="Spatial information of a unitcell · QuantumLattices.jl"/><meta name="description" content="Documentation for QuantumLattices.jl."/><meta property="og:description" content="Documentation for QuantumLattices.jl."/><meta property="twitter:description" content="Documentation for QuantumLattices.jl."/><meta property="og:url" content="https://quantum-many-body.github.io/QuantumLattices.jl/latest/unitcell description framework/SpatialInfoOfAUnitcell/"/><meta property="twitter:url" content="https://quantum-many-body.github.io/QuantumLattices.jl/latest/unitcell description framework/SpatialInfoOfAUnitcell/"/><link rel="canonical" href="https://quantum-many-body.github.io/QuantumLattices.jl/latest/unitcell description framework/SpatialInfoOfAUnitcell/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-89508993-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-89508993-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="QuantumLattices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumLattices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Unitcell Description Framework</span><ul><li><a class="tocitem" href="../Introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Spatial information of a unitcell</a><ul class="internal"><li><a class="tocitem" href="#Construction-of-a-lattice"><span>Construction of a lattice</span></a></li><li><a class="tocitem" href="#Request-for-the-bonds-of-a-lattice"><span>Request for the bonds of a lattice</span></a></li></ul></li><li><a class="tocitem" href="../InternalDegreesOfFreedom/">Internal degrees of freedom</a></li><li><a class="tocitem" href="../CouplingsAmongDifferentDegreesOfFreedom/">Couplings among different degrees of freedom</a></li><li><a class="tocitem" href="../GeneratorOfOperators/">Generator of operators</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../../advanced topics/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../advanced topics/LaTeXFormattedOutputs/">LaTeX formatted outputs</a></li><li><a class="tocitem" href="../../advanced topics/IndexOrders/">Index orders</a></li><li><a class="tocitem" href="../../advanced topics/BoundaryConditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../advanced topics/HybridSystems/">Hybrid systems</a></li><li><a class="tocitem" href="../../advanced topics/Transformations/">Transformations</a></li><li><a class="tocitem" href="../../advanced topics/ManageProjects/">Manage projects</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/Toolkit/">Toolkit</a></li><li><a class="tocitem" href="../../man/QuantumOperators/">Quantum operators</a></li><li><a class="tocitem" href="../../man/QuantumNumbers/">Quantum numbers</a></li><li><a class="tocitem" href="../../man/Spatials/">Spatials</a></li><li><a class="tocitem" href="../../man/DegreesOfFreedom/">Degrees of freedom</a></li><li><a class="tocitem" href="../../man/QuantumSystems/">Quantum Systems</a></li><li><a class="tocitem" href="../../man/Frameworks/">Frameworks</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Unitcell Description Framework</a></li><li class="is-active"><a href>Spatial information of a unitcell</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spatial information of a unitcell</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/master/docs/src/unitcell description framework/SpatialInfoOfAUnitcell.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Spatial-information-of-a-unitcell"><a class="docs-heading-anchor" href="#Spatial-information-of-a-unitcell">Spatial information of a unitcell</a><a id="Spatial-information-of-a-unitcell-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-information-of-a-unitcell" title="Permalink"></a></h1><p>The first step toward the complete description of a quantum lattice system is the understanding of the spatial information of a unitcell.</p><h2 id="Construction-of-a-lattice"><a class="docs-heading-anchor" href="#Construction-of-a-lattice">Construction of a lattice</a><a id="Construction-of-a-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-of-a-lattice" title="Permalink"></a></h2><p>In general, a lattice has translation symmetry. This symmetry introduces an equivalence relation for the points in a lattice when they can be translated into each other by multiple times of the translation vectors. This observation sets the mathematical foundation of the unitcell construction. As a result, it is enough for a lattice to restrict all points within the origin unitcell together with the translation vectors.</p><p><a href="../../man/Spatials/#QuantumLattices.Spatials.Lattice"><code>Lattice</code></a> is the simplest structure to encode all the spatial information within the origin unitcell. Apparently, it must contain all the coordinates of the points in the origin unitcell and the translation vectors of the lattice. It also appears to be useful to associate a lattice with a name. Therefore, in this package, <a href="../../man/Spatials/#QuantumLattices.Spatials.Lattice"><code>Lattice</code></a> has three attributes:</p><ul><li><code>name::Symbol</code>: the name of the lattice</li><li><code>coordinates::Matrix{&lt;:Number}</code>: the coordinates of the points within the origin unitcell</li><li><code>vectors::Vector{&lt;:StaticArraysCore.SVector}</code>: the translation vectors of the lattice</li></ul><p><a href="../../man/Spatials/#QuantumLattices.Spatials.Lattice"><code>Lattice</code></a> can be constructed by offering the coordinates, with optional keyword arguments to specify its name and translation vectors:</p><pre><code class="language-julia-repl hljs">julia&gt; Lattice([0.0])
Lattice(lattice)
  with 1 point:
    [0.0]

julia&gt; Lattice((0.0, 0.0), (0.5, 0.5); vectors=[[1.0, 0.0], [0.0, 1.0]], name=:Square)
Lattice(Square)
  with 2 points:
    [0.0, 0.0]
    [0.5, 0.5]
  with 2 translation vectors:
    [1.0, 0.0]
    [0.0, 1.0]

julia&gt; Lattice(
           (0.0, 0.0, 0.0);
           name=:Cube,
           vectors=[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
       )
Lattice(Cube)
  with 1 point:
    [0.0, 0.0, 0.0]
  with 3 translation vectors:
    [1.0, 0.0, 0.0]
    [0.0, 1.0, 0.0]
    [0.0, 0.0, 1.0]</code></pre><p>The coordinates could be specified by vectors or tuples.</p><p>Iteration over a lattice will get the coordinates of the points in it:</p><pre><code class="language-julia-repl hljs">julia&gt; lattice = Lattice((0.0, 0.0), (0.5, 0.5); vectors=[[1.0, 0.0], [0.0, 1.0]]);

julia&gt; length(lattice)
2

julia&gt; [lattice[1], lattice[2]]
2-element Vector{StaticArraysCore.SVector{2, Float64}}:
 [0.0, 0.0]
 [0.5, 0.5]

julia&gt; collect(lattice)
2-element Vector{StaticArraysCore.SVector{2, Float64}}:
 [0.0, 0.0]
 [0.5, 0.5]</code></pre><p>The reciprocal translation vectors of the dual lattice can be obtained by <a href="../../man/Spatials/#QuantumLattices.Spatials.reciprocals-Tuple{AbstractLattice}"><code>reciprocals</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; lattice = Lattice((0.0, 0.0); vectors=[[1.0, 0.0], [0.0, 1.0]]);

julia&gt; reciprocals(lattice)
2-element StaticArraysCore.SVector{2, StaticArraysCore.SVector{2, Float64}} with indices SOneTo(2):
 [6.283185307179586, -0.0]
 [-0.0, 6.283185307179586]</code></pre><h2 id="Request-for-the-bonds-of-a-lattice"><a class="docs-heading-anchor" href="#Request-for-the-bonds-of-a-lattice">Request for the bonds of a lattice</a><a id="Request-for-the-bonds-of-a-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Request-for-the-bonds-of-a-lattice" title="Permalink"></a></h2><p>Before the introduction of how to obtain the bonds of a lattice, let&#39;s discuss more about the unitcell construction to clarify the logic behind the definitions of the <a href="#Point"><code>Point</code></a> type and the <a href="#Bond"><code>Bond</code></a> type in this package.</p><h3 id="Point"><a class="docs-heading-anchor" href="#Point">Point</a><a id="Point-1"></a><a class="docs-heading-anchor-permalink" href="#Point" title="Permalink"></a></h3><p>With the translation symmetry, all points of a lattice are equivalent to those within the origin unitcell. However, it becomes complicated when the bonds are requested. The bonds inter different unitcells cannot be compressed into a single unitcell. Therefore, even in the unitcell construction framework, it turns out to be unavoidable to specify a point outside the origin unitcell, which requires extra information beyond a single coordinate if we want to remember which point it is equivalent to within the origin unitcell at the same time. In fact, it is customary in literature to express the coordinate <span>$\mathbf{R}$</span> of a point in a lattice as <span>$\mathbf{R}=\mathbf{R}_i+\mathbf{r}$</span>, where <span>$\mathbf{R}_i$</span> is the integral coordinate of the unitcell the point belongs to and <span>$\mathbf{r}$</span> is the relative displacement of the point in the unitcell. Apparently, any two of these three coordinates are complete to get the full information. In this package, we choose <span>$\mathbf{R}$</span> and <span>$\mathbf{R}_i$</span> as the complete set for a individual lattice point. Besides, we also associate a <code>site</code> index with a point for the fast lookup for its equivalence within the origin unitcell although it is redundant in theory. Thus, the <a href="#Point"><code>Point</code></a> defined in this package has three attributes as follows:</p><ul><li><code>site::Int</code>: the site index of a point that specifies the equivalent point within the origin unitcell</li><li><code>rcoordinate::</code><a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArraysCore.SVector</code></a>: the <strong>r</strong>eal <strong>coordinate</strong> of the point (<span>$\mathbf{R}$</span>)</li><li><code>icoordinate::</code><a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArraysCore.SVector</code></a>: the <strong>i</strong>ntegral <strong>coordinate</strong> of the unitcell the point belongs to (<span>$\mathbf{R}_i$</span>)</li></ul><p>At the construction of a <a href="#Point"><code>Point</code></a>, <code>rcoordinate</code> and <code>icoordinate</code> can accept tuples or usual vectors as inputs, such as</p><pre><code class="language-julia-repl hljs">julia&gt; Point(1, [0.0], [0.0])
Point(1, [0.0], [0.0])

julia&gt; Point(1, (1.5, 0.0), (1.0, 0.0))
Point(1, [1.5, 0.0], [1.0, 0.0])</code></pre><p><code>icoordinate</code> can be omitted, then it will be initialized by a zero <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArraysCore.SVector</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Point(1, [0.0, 0.5])
Point(1, [0.0, 0.5], [0.0, 0.0])</code></pre><h3 id="Bond"><a class="docs-heading-anchor" href="#Bond">Bond</a><a id="Bond-1"></a><a class="docs-heading-anchor-permalink" href="#Bond" title="Permalink"></a></h3><p>A bond in the narrow sense consist of two points. However, in quantum lattice systems, it is common to refer to generic bonds with only one or more than two points. In addition, it is also convenient to associate a bond with a kind information, such as the order of the nearest neighbors of the bond. Thus, the <a href="#Bond"><code>Bond</code></a> is defined as follows:</p><ul><li><code>kind</code>: the kind information of a generic bond</li><li><code>points::Vector{&lt;:Point}</code>: the points a generic bond contains</li></ul><pre><code class="language-julia-repl hljs">julia&gt; Bond(Point(1, [0.0, 0.0], [0.0, 0.0])) # 1-point bond
Bond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))

julia&gt; Bond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(1, [1.0, 1.0], [1.0, 1.0])) # 2-point bond
Bond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(1, [1.0, 1.0], [1.0, 1.0]))

julia&gt; Bond(:plaquette, Point(1, [0.0, 0.0]), Point(2, [1.0, 0.0]), Point(3, [1.0, 1.0]), Point(4, [0.0, 1.0])) # generic bond with 4 points
Bond(:plaquette, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(2, [1.0, 0.0], [0.0, 0.0]), Point(3, [1.0, 1.0], [0.0, 0.0]), Point(4, [0.0, 1.0], [0.0, 0.0]))</code></pre><p>It is noted that the <code>kind</code> attribute of a bond with only one point is set to be 0.</p><p>Iteration over a bond will get the points it contains:</p><pre><code class="language-julia-repl hljs">julia&gt; bond = Bond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(2, [1.0, 0.0], [0.0, 0.0]));

julia&gt; length(bond)
2

julia&gt; [bond[1], bond[2]]
2-element Vector{Point{2, Float64}}:
 Point(1, [0.0, 0.0], [0.0, 0.0])
 Point(2, [1.0, 0.0], [0.0, 0.0])

julia&gt; collect(bond)
2-element Vector{Point{2, Float64}}:
 Point(1, [0.0, 0.0], [0.0, 0.0])
 Point(2, [1.0, 0.0], [0.0, 0.0])</code></pre><p>The coordinate of a bond as a whole is also defined for those that only contain one or two points. The coordinate of a 1-point bond is defined to be the corresponding coordinate of this point, and the coordinate of a 2-point bond is defined to be the corresponding coordinate of the second point minus that of the first:</p><pre><code class="language-julia-repl hljs">julia&gt; bond1p = Bond(Point(1, [2.0], [1.0]));

julia&gt; rcoordinate(bond1p)
1-element StaticArraysCore.SVector{1, Float64} with indices SOneTo(1):
 2.0

julia&gt; icoordinate(bond1p)
1-element StaticArraysCore.SVector{1, Float64} with indices SOneTo(1):
 1.0

julia&gt; bond2p = Bond(1, Point(1, [1.0, 1.0], [1.0, 1.0]), Point(2, [0.5, 0.5], [0.0, 0.0]));

julia&gt; rcoordinate(bond2p)
2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):
 -0.5
 -0.5

julia&gt; icoordinate(bond2p)
2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):
 -1.0
 -1.0</code></pre><h3 id="Generation-of-1-point-and-2-point-bonds-of-a-lattice"><a class="docs-heading-anchor" href="#Generation-of-1-point-and-2-point-bonds-of-a-lattice">Generation of 1-point and 2-point bonds of a lattice</a><a id="Generation-of-1-point-and-2-point-bonds-of-a-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Generation-of-1-point-and-2-point-bonds-of-a-lattice" title="Permalink"></a></h3><p>In this package, we provide the function <a href="../../man/Spatials/#QuantumLattices.Spatials.bonds-Tuple{AbstractLattice, Integer}"><code>bonds</code></a> to get the 1-point and 2-point bonds of a lattice:</p><pre><code class="language-julia hljs">bonds(lattice::Lattice, nneighbor::Int) -&gt; Vector{&lt;:Bond}
bonds(lattice::Lattice, neighbors::Neighbors) -&gt; Vector{&lt;:Bond}</code></pre><p>which is based on the <code>KDTree</code> type provided by the <a href="https://github.com/KristofferC/NearestNeighbors.jl"><code>NearestNeighbors.jl</code></a> package. In the first method, all the bonds up to the <code>nneighbor</code>th nearest neighbors are returned, including the 1-point bonds:</p><pre><code class="language-julia-repl hljs">julia&gt; lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);

julia&gt; bonds(lattice, 2)
5-element Vector{Bond{Int64, Point{2, Float64}}}:
 Bond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(1, Point(1, [0.0, -1.0], [0.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(1, Point(1, [-1.0, 0.0], [-1.0, 0.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))</code></pre><p>However, this method is not so efficient, as <code>KDTree</code> only searches the bonds with the lengths less than a value, and it does not know the bond lengths for each order of nearest neighbors. Such information must be computed as first. Therefore, in the second method, <a href="../../man/Spatials/#QuantumLattices.Spatials.bonds-Tuple{AbstractLattice, Integer}"><code>bonds</code></a> can accept a new type, the <a href="../../man/Spatials/#QuantumLattices.Spatials.Neighbors"><code>Neighbors</code></a>, as its second positional parameter to improve the efficiency, which could tell the program the information of the bond lengths in priori:</p><pre><code class="language-julia-repl hljs">julia&gt; lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);

julia&gt; bonds(lattice, Neighbors(0=&gt;0.0, 1=&gt;1.0, 2=&gt;√2))
5-element Vector{Bond{Int64, Point{2, Float64}}}:
 Bond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(1, Point(1, [0.0, -1.0], [0.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(1, Point(1, [-1.0, 0.0], [-1.0, 0.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))</code></pre><p>Meanwhile, an instance of <a href="../../man/Spatials/#QuantumLattices.Spatials.Neighbors"><code>Neighbors</code></a> could also serve as a filter of the generated bonds, which select those bonds with the given bond lengths:</p><pre><code class="language-julia-repl hljs">julia&gt; lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);

julia&gt; bonds(lattice, Neighbors(2=&gt;√2))
2-element Vector{Bond{Int64, Point{2, Float64}}}:
 Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))
 Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))</code></pre><p>To obtain generic bonds containing more points, user are encouraged to implement their own <code>bonds</code> methods. Pull requests are welcomed.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../InternalDegreesOfFreedom/">Internal degrees of freedom »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 1 May 2025 16:19">Thursday 1 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
