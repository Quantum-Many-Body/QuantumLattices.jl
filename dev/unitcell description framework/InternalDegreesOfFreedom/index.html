<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal degrees of freedom · QuantumLattices.jl</title><meta name="title" content="Internal degrees of freedom · QuantumLattices.jl"/><meta property="og:title" content="Internal degrees of freedom · QuantumLattices.jl"/><meta property="twitter:title" content="Internal degrees of freedom · QuantumLattices.jl"/><meta name="description" content="Documentation for QuantumLattices.jl."/><meta property="og:description" content="Documentation for QuantumLattices.jl."/><meta property="twitter:description" content="Documentation for QuantumLattices.jl."/><meta property="og:url" content="https://quantum-many-body.github.io/QuantumLattices.jl/latest/unitcell description framework/InternalDegreesOfFreedom/"/><meta property="twitter:url" content="https://quantum-many-body.github.io/QuantumLattices.jl/latest/unitcell description framework/InternalDegreesOfFreedom/"/><link rel="canonical" href="https://quantum-many-body.github.io/QuantumLattices.jl/latest/unitcell description framework/InternalDegreesOfFreedom/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-89508993-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-89508993-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="QuantumLattices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumLattices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Unitcell Description Framework</span><ul><li><a class="tocitem" href="../Introduction/">Introduction</a></li><li><a class="tocitem" href="../SpatialInfoOfAUnitcell/">Spatial information of a unitcell</a></li><li class="is-active"><a class="tocitem" href>Internal degrees of freedom</a><ul class="internal"><li><a class="tocitem" href="#Hierarchy-of-the-internal-degrees-of-freedom"><span>Hierarchy of the internal degrees of freedom</span></a></li><li><a class="tocitem" href="#Quantum-lattice-systems-with-different-internal-structures"><span>Quantum lattice systems with different internal structures</span></a></li><li><a class="tocitem" href="#Operator-and-Operators"><span>Operator and Operators</span></a></li></ul></li><li><a class="tocitem" href="../CouplingsAmongDifferentDegreesOfFreedom/">Couplings among different degrees of freedom</a></li><li><a class="tocitem" href="../GeneratorOfOperators/">Generator of operators</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../../advanced topics/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../advanced topics/LaTeXFormattedOutputs/">LaTeX formatted outputs</a></li><li><a class="tocitem" href="../../advanced topics/IndexOrders/">Index orders</a></li><li><a class="tocitem" href="../../advanced topics/BoundaryConditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../advanced topics/HybridSystems/">Hybrid systems</a></li><li><a class="tocitem" href="../../advanced topics/Transformations/">Transformations</a></li><li><a class="tocitem" href="../../advanced topics/ManageProjects/">Manage projects</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/Toolkit/">Toolkit</a></li><li><a class="tocitem" href="../../man/QuantumOperators/">Quantum operators</a></li><li><a class="tocitem" href="../../man/QuantumNumbers/">Quantum numbers</a></li><li><a class="tocitem" href="../../man/Spatials/">Spatials</a></li><li><a class="tocitem" href="../../man/DegreesOfFreedom/">Degrees of freedom</a></li><li><a class="tocitem" href="../../man/QuantumSystems/">Quantum Systems</a></li><li><a class="tocitem" href="../../man/Frameworks/">Frameworks</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Unitcell Description Framework</a></li><li class="is-active"><a href>Internal degrees of freedom</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal degrees of freedom</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/master/docs/src/unitcell description framework/InternalDegreesOfFreedom.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-degrees-of-freedom"><a class="docs-heading-anchor" href="#Internal-degrees-of-freedom">Internal degrees of freedom</a><a id="Internal-degrees-of-freedom-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-degrees-of-freedom" title="Permalink"></a></h1><p>Now let&#39;s move to the second step, the internal degrees of freedom.</p><h2 id="Hierarchy-of-the-internal-degrees-of-freedom"><a class="docs-heading-anchor" href="#Hierarchy-of-the-internal-degrees-of-freedom">Hierarchy of the internal degrees of freedom</a><a id="Hierarchy-of-the-internal-degrees-of-freedom-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchy-of-the-internal-degrees-of-freedom" title="Permalink"></a></h2><p>In general, a lattice Hamiltonian can be expressed by the generators of the <a href="https://en.wikipedia.org/wiki/Algebra_over_a_field">algebra</a> that acts on the Hilbert space of the system. For example for the complex fermionic (bosonic) system, the Hilbert space is the <a href="https://en.wikipedia.org/wiki/Fock_space">Fock space</a>, and the lattice Hamiltonian can be expressed by the generators of the fermionic (bosonic) algebra, i.e., the the creation and annihilation operators <span>$\{c^\dagger_\alpha, c_\alpha\}$</span> <span>$\left(\{b^\dagger_\alpha, b_\alpha\}\right)$</span>. For another example for the local spin-1/2 system, the Hilbert space is the <span>$\otimes_\alpha\{\lvert\uparrow\rangle, \lvert\downarrow\rangle\}_\alpha$</span> space, and the lattice Hamiltonian can be expressed by the generators of the SU(2) spin algebra, i.e., the spin operators <span>$\{S^x_\alpha, S^y_\alpha, S^z_\alpha\}$</span> or <span>$\{S^+_\alpha, S^-_\alpha, S^z_\alpha\}$</span>. In both examples, the subscript <span>$\alpha$</span> denotes a complete set of indexes of the internal degrees of freedom of the quantum system. Therefore, the determination of the algebra acting on the system&#39;s Hilbert space and its corresponding generators lies at the center of the constructions of the operator representations of lattice Hamiltonians.</p><p>The global Hilbert space of a lattice system can be decomposed into the direct product of the local internal spaces &quot;living&quot; on individual points, leading to a similar decomposition of the global algebra into local ones. To incorporate with the unitcell construction of the lattice, an extra intermediate representation of the translation-equivalent internal degrees of freedom within the origin unitcell is also needed. Thus, from the microscopic to the macroscopic, we arrive at a three level hierarchy, namely the local-unitcell-global hierarchy, of the internal degrees of freedom.</p><p>At the local or the individual-point level, the local algebra is represented by the type <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Internal"><code>Internal</code></a>, and a local generator of the local algebra is represented by the type <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.IID"><code>IID</code></a>. Both types are abstract types with their concrete subtypes to represent concrete local algebras and concrete local generators of different quantum lattice systems with different internal structures, respectively.</p><p>At the unitcell level, the algebra of the system is represented by the type <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert"><code>Hilbert</code></a>, which defines the concrete local algebras point by point within the origin unitcell. Accordingly, the type <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Index"><code>Index</code></a>, which combines a site index and an instance of <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.IID"><code>IID</code></a>, could specify a translation-equivalent generator within the origin unitcell.</p><p>At the global or the whole-lattice level, we do not actually need a representation of the algebra of the system, but really do for the generators because we have to specify them outside the origin unitcell when the bond goes across the unitcell boundaries. The type <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeIndex"><code>CompositeIndex</code></a>, which combines an instance of <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Index"><code>Index</code></a> and the coordinates <span>$\mathbf{R}$</span> and <span>$\mathbf{R}_i$</span> of the underlying point, represents a generator at such a level.</p><p>The above discussions can be summarized by the following table, which also displays how the spatial part of a quantum lattice system is represented:</p><table><tr><th style="text-align: center"></th><th style="text-align: center">local (individual-point) level</th><th style="text-align: center">unitcell level</th><th style="text-align: center">global (whole-lattice) level</th></tr><tr><td style="text-align: center">spatial</td><td style="text-align: center"><a href="../SpatialInfoOfAUnitcell/#Point"><code>Point</code></a></td><td style="text-align: center"><a href="../../man/Spatials/#QuantumLattices.Spatials.Lattice"><code>Lattice</code></a></td><td style="text-align: center"></td></tr><tr><td style="text-align: center">algebra</td><td style="text-align: center"><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Internal"><code>Internal</code></a> and its concrete subtypes</td><td style="text-align: center"><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert"><code>Hilbert</code></a></td><td style="text-align: center"></td></tr><tr><td style="text-align: center">generator</td><td style="text-align: center"><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.IID"><code>IID</code></a> and its concrete subtypes</td><td style="text-align: center"><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Index"><code>Index</code></a></td><td style="text-align: center"><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeIndex"><code>CompositeIndex</code></a></td></tr></table><h2 id="Quantum-lattice-systems-with-different-internal-structures"><a class="docs-heading-anchor" href="#Quantum-lattice-systems-with-different-internal-structures">Quantum lattice systems with different internal structures</a><a id="Quantum-lattice-systems-with-different-internal-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-lattice-systems-with-different-internal-structures" title="Permalink"></a></h2><p>In this section, we will explain in detail for the common categories of quantum lattice systems implemented in this package about how their algebras and generators are organized according to the above three level hierarchy.</p><h3 id="Canonical-complex-fermionic,-canonical-complex-bosonic-and-hard-core-bosonic-systems"><a class="docs-heading-anchor" href="#Canonical-complex-fermionic,-canonical-complex-bosonic-and-hard-core-bosonic-systems">Canonical complex fermionic, canonical complex bosonic and hard-core bosonic systems</a><a id="Canonical-complex-fermionic,-canonical-complex-bosonic-and-hard-core-bosonic-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Canonical-complex-fermionic,-canonical-complex-bosonic-and-hard-core-bosonic-systems" title="Permalink"></a></h3><h4 id="Local-level:-Fock-and-FID"><a class="docs-heading-anchor" href="#Local-level:-Fock-and-FID">Local level: Fock and FID</a><a id="Local-level:-Fock-and-FID-1"></a><a class="docs-heading-anchor-permalink" href="#Local-level:-Fock-and-FID" title="Permalink"></a></h4><p>Roughly speaking, these systems share similar internal structures of local Hilbert spaces termed as the <a href="https://en.wikipedia.org/wiki/Fock_space">Fock space</a> where the generators of local algebras are the annihilation and creation operators. Besides the nambu index to distinguish whether it is an annihilation one or a creation one, such a generator usually adopts an orbital index and a spin index. Thus, the type <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.FID"><code>FID</code></a><code>&lt;:</code><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.IID"><code>IID</code></a>, which specifies a certain local generator of a local Fock algebra, has the following attributes:</p><ul><li><code>orbital::Int</code>: the orbital index</li><li><code>spin::Rational{Int}</code>: the spin index, which must be a half integer</li><li><code>nambu::Int</code>: the nambu index, which must be 1(annihilation) or 2(creation).</li></ul><p>Correspondingly, the type <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock"><code>Fock</code></a><code>&lt;:</code><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Internal"><code>Internal</code></a>, which specifies the local algebra acting on the local <a href="https://en.wikipedia.org/wiki/Fock_space">Fock space</a>, has the following attributes:</p><ul><li><code>norbital::Int</code>: the number of allowed orbital indices</li><li><code>nspin::Int</code>: the number of allowed spin indices</li></ul><p>To distinguish whether the system is a fermionic one or a bosonic one, <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.FID"><code>FID</code></a> and <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock"><code>Fock</code></a> take a symbol <code>:f</code>(for fermionic) or <code>:b</code>(for bosonic) to be their first type parameters.</p><p>Now let&#39;s see some examples.</p><p>An <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.FID"><code>FID</code></a> instance can be initialized by giving all its three attributes:</p><pre><code class="language-julia-repl hljs">julia&gt; FID{:f}(2, 1//2, 1)
FID{:f}(2, 1//2, 1)

julia&gt; FID{:b}(2, 0, 1)
FID{:b}(2, 0, 1)</code></pre><p>The adjoint of an <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.FID"><code>FID</code></a> instance is also defined:</p><pre><code class="language-julia-repl hljs">julia&gt; FID{:f}(3, 3//2, 1)&#39;
FID{:f}(3, 3//2, 2)

julia&gt; FID{:b}(3, 3//2, 2)&#39;
FID{:b}(3, 3//2, 1)</code></pre><p>Apparently, this operation is nothing but the &quot;Hermitian conjugate&quot;.</p><p>A <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock"><code>Fock</code></a> instance can be initialized by giving all its attributes:</p><pre><code class="language-julia-repl hljs">julia&gt; Fock{:f}(1, 2)
4-element Fock{:f}:
 FID{:f}(1, -1//2, 1)
 FID{:f}(1, 1//2, 1)
 FID{:f}(1, -1//2, 2)
 FID{:f}(1, 1//2, 2)

julia&gt; Fock{:b}(1, 1)
2-element Fock{:b}:
 FID{:b}(1, 0, 1)
 FID{:b}(1, 0, 2)</code></pre><p>As can be seen, a <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock"><code>Fock</code></a> instance behaves like a vector (because the parent type <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Internal"><code>Internal</code></a> is a subtype of <code>AbstractVector</code>), and its iteration just generates all the allowed <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.FID"><code>FID</code></a> instances on its associated spatial point:</p><pre><code class="language-julia-repl hljs">julia&gt; fck = Fock{:f}(2, 1);

julia&gt; fck |&gt; typeof |&gt; eltype
FID{:f, Int64, Rational{Int64}, Int64}

julia&gt; fck |&gt; length
4

julia&gt; [fck[1], fck[2], fck[3], fck[4]]
4-element Vector{FID{:f, Int64, Rational{Int64}, Int64}}:
 FID{:f}(1, 0, 1)
 FID{:f}(2, 0, 1)
 FID{:f}(1, 0, 2)
 FID{:f}(2, 0, 2)

julia&gt; fck |&gt; collect
4-element Vector{FID{:f, Int64, Rational{Int64}, Int64}}:
 FID{:f}(1, 0, 1)
 FID{:f}(2, 0, 1)
 FID{:f}(1, 0, 2)
 FID{:f}(2, 0, 2)</code></pre><p>This is isomorphic to the mathematical fact that a local algebra is a vector space of the local generators.</p><h4 id="Unitcell-level:-Hilbert-and-Index"><a class="docs-heading-anchor" href="#Unitcell-level:-Hilbert-and-Index">Unitcell level: Hilbert and Index</a><a id="Unitcell-level:-Hilbert-and-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Unitcell-level:-Hilbert-and-Index" title="Permalink"></a></h4><p>To specify the Fock algebra at the unitcell level, <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert"><code>Hilbert</code></a> associate each point within the origin unitcell with an instance of <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock"><code>Fock</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Hilbert(1=&gt;Fock{:f}(1, 2), 2=&gt;Fock{:f}(1, 2))
Hilbert{Fock{:f}} with 2 entries:
  1 =&gt; Fock{:f}(norbital=1, nspin=2)
  2 =&gt; Fock{:f}(norbital=1, nspin=2)

julia&gt; Hilbert(site=&gt;Fock{:f}(2, 2) for site=1:2)
Hilbert{Fock{:f}} with 2 entries:
  1 =&gt; Fock{:f}(norbital=2, nspin=2)
  2 =&gt; Fock{:f}(norbital=2, nspin=2)

julia&gt; Hilbert(Fock{:f}(2, 2), 2)
Hilbert{Fock{:f}} with 2 entries:
  1 =&gt; Fock{:f}(norbital=2, nspin=2)
  2 =&gt; Fock{:f}(norbital=2, nspin=2)

julia&gt; Hilbert([Fock{:f}(2, 2), Fock{:f}(2, 2)])
Hilbert{Fock{:f}} with 2 entries:
  1 =&gt; Fock{:f}(norbital=2, nspin=2)
  2 =&gt; Fock{:f}(norbital=2, nspin=2)</code></pre><p>In general, at different sites, the local Fock algebra could be different:</p><pre><code class="language-julia-repl hljs">julia&gt; Hilbert(site=&gt;Fock{:f}(iseven(site) ? 2 : 1, 1) for site=1:2)
Hilbert{Fock{:f}} with 2 entries:
  1 =&gt; Fock{:f}(norbital=1, nspin=1)
  2 =&gt; Fock{:f}(norbital=2, nspin=1)

julia&gt; Hilbert(1=&gt;Fock{:f}(1, 2), 2=&gt;Fock{:b}(1, 2))
Hilbert{Fock} with 2 entries:
  1 =&gt; Fock{:f}(norbital=1, nspin=2)
  2 =&gt; Fock{:b}(norbital=1, nspin=2)</code></pre><p><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert"><code>Hilbert</code></a> itself is a subtype of <code>AbstractDict</code>, the iteration over the keys gives the sites, and the iteration over the values gives the local algebras:</p><pre><code class="language-julia-repl hljs">julia&gt; hilbert = Hilbert(site=&gt;Fock{:f}(iseven(site) ? 2 : 1, 1) for site=1:2);

julia&gt; collect(keys(hilbert))
2-element Vector{Int64}:
 1
 2

julia&gt; collect(values(hilbert))
2-element Vector{Fock{:f}}:
 Fock{:f}(norbital=1, nspin=1)
 Fock{:f}(norbital=2, nspin=1)

julia&gt; collect(hilbert)
2-element Vector{Pair{Int64, Fock{:f}}}:
 1 =&gt; Fock{:f}(norbital=1, nspin=1)
 2 =&gt; Fock{:f}(norbital=2, nspin=1)

julia&gt; [hilbert[1], hilbert[2]]
2-element Vector{Fock{:f}}:
 Fock{:f}(norbital=1, nspin=1)
 Fock{:f}(norbital=2, nspin=1)</code></pre><p>To specify a translation-equivalent generator of the Fock algebra within the unitcell, <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Index"><code>Index</code></a> just combines a <code>site::Int</code> attribute and an <code>iid::FID</code> attribute:</p><pre><code class="language-julia-repl hljs">julia&gt; index = Index(1, FID{:f}(1, -1//2, 2))
Index(1, FID{:f}(1, -1//2, 2))

julia&gt; index.site
1

julia&gt; index.iid
FID{:f}(1, -1//2, 2)</code></pre><p>The Hermitian conjugate of an <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Index"><code>Index</code></a> is also defined:</p><pre><code class="language-julia-repl hljs">julia&gt; Index(1, FID{:f}(1, -1//2, 2))&#39;
Index(1, FID{:f}(1, -1//2, 1))</code></pre><h4 id="Global-level:-CompositeIndex"><a class="docs-heading-anchor" href="#Global-level:-CompositeIndex">Global level: CompositeIndex</a><a id="Global-level:-CompositeIndex-1"></a><a class="docs-heading-anchor-permalink" href="#Global-level:-CompositeIndex" title="Permalink"></a></h4><p>Since the local algebra of a quantum lattice system can be defined point by point, the global algebra can be completely compressed into the origin unitcell. However, the generator outside the origin unitcell cannot be avoided because we have to use them to compose the Hamiltonian on the bonds that goes across the unitcell boundaries. This situation is similar to the case of <a href="../../man/Spatials/#QuantumLattices.Spatials.Lattice"><code>Lattice</code></a> and <a href="../SpatialInfoOfAUnitcell/#Point"><code>Point</code></a>. Therefore, we take a similar solution for the generators to that is adopted for the <a href="../SpatialInfoOfAUnitcell/#Point"><code>Point</code></a>, i.e., we include the <span>$\mathbf{R}$</span> coordinate (by the <code>rcoordinate</code> attribute) and the <span>$\mathbf{R}_i$</span> coordinate (by the <code>icoordinate</code> attribute) of the underlying point together with the <code>index::Index</code> attribute in the <a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeIndex"><code>CompositeIndex</code></a> type to represent a generator that could be inside or outside the origin unitcell:</p><pre><code class="language-julia-repl hljs">julia&gt; index = CompositeIndex(Index(1, FID{:f}(1, 0, 2)), [0.5, 0.0], [0.0, 0.0])
CompositeIndex(Index(1, FID{:f}(1, 0, 2)), [0.5, 0.0], [0.0, 0.0])

julia&gt; index.index
Index(1, FID{:f}(1, 0, 2))

julia&gt; index.rcoordinate
2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):
 0.5
 0.0

julia&gt; index.icoordinate
2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):
 0.0
 0.0

julia&gt; index&#39; # the Hermitian conjugate of a CompositeIndex is also defined
CompositeIndex(Index(1, FID{:f}(1, 0, 1)), [0.5, 0.0], [0.0, 0.0])</code></pre><h3 id="SU(2)-spin-systems"><a class="docs-heading-anchor" href="#SU(2)-spin-systems">SU(2) spin systems</a><a id="SU(2)-spin-systems-1"></a><a class="docs-heading-anchor-permalink" href="#SU(2)-spin-systems" title="Permalink"></a></h3><h4 id="Local-level:-Spin-and-SID"><a class="docs-heading-anchor" href="#Local-level:-Spin-and-SID">Local level: Spin and SID</a><a id="Local-level:-Spin-and-SID-1"></a><a class="docs-heading-anchor-permalink" href="#Local-level:-Spin-and-SID" title="Permalink"></a></h4><p><a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin"><code>Spin</code></a><code>&lt;:</code><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Internal"><code>Internal</code></a> and <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a><code>&lt;:</code><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.IID"><code>IID</code></a> are designed to deal with SU(2) spin systems at the local level.</p><p>Although spin systems are essentially bosonic, the commonly-used local Hilbert space is distinct from that of an usual bosonic system: it is the space spanned by the eigenstates of a local <span>$S^z$</span> operator rather than a <a href="https://en.wikipedia.org/wiki/Fock_space">Fock space</a>. At the same time, a spin Hamiltonian is usually expressed by local spin operators, such as <span>$S^x$</span>, <span>$S^y$</span>, <span>$S^z$</span>, <span>$S^+$</span> and <span>$S^-$</span>, instead of creation and annihilation operators. Therefore, it is convenient to define another set of concrete subtypes for spin systems.</p><p>To specify which one of the five <span>$\{S^x, S^y, S^z, S^+, S^-\}$</span> a local spin operator is, the type <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a> has the following attribute:</p><ul><li><code>tag::Char</code>: the tag, which must be <code>&#39;x&#39;</code>, <code>&#39;y&#39;</code>, <code>&#39;z&#39;</code>, <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>.</li></ul><p>Correspondingly, the type <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin"><code>Spin</code></a>, which defines the local SU(2) spin algebra, does not need any attribute.</p><p>For <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a> and <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin"><code>Spin</code></a>, it is also necessary to know what the total spin is, which is taken as their first type parameters and should be a half-integer or an integer.</p><p>Now let&#39;s see examples.</p><p>An <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a> instance can be initialized as follows</p><pre><code class="language-julia-repl hljs">julia&gt; SID{3//2}(&#39;x&#39;)
SID{3//2}(&#39;x&#39;)

julia&gt; SID{1//2}(&#39;z&#39;)
SID{1//2}(&#39;z&#39;)

julia&gt; SID{1}(&#39;+&#39;)
SID{1}(&#39;+&#39;)</code></pre><p>The &quot;Hermitian conjugate&quot; of an <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a> instance can be obtained by the adjoint operation:</p><pre><code class="language-julia-repl hljs">julia&gt; SID{3//2}(&#39;x&#39;)&#39;
SID{3//2}(&#39;x&#39;)

julia&gt; SID{3//2}(&#39;y&#39;)&#39;
SID{3//2}(&#39;y&#39;)

julia&gt; SID{3//2}(&#39;z&#39;)&#39;
SID{3//2}(&#39;z&#39;)

julia&gt; SID{3//2}(&#39;+&#39;)&#39;
SID{3//2}(&#39;-&#39;)

julia&gt; SID{3//2}(&#39;-&#39;)&#39;
SID{3//2}(&#39;+&#39;)</code></pre><p>The local spin space is determined by the total spin. The standard matrix representation of an <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a> instance on this local spin space can be obtained by the <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.matrix"><code>matrix</code></a> function exported by this package:</p><pre><code class="language-julia-repl hljs">julia&gt; SID{1//2}(&#39;x&#39;) |&gt; matrix
2×2 Matrix{ComplexF64}:
 0.0+0.0im  0.5+0.0im
 0.5+0.0im  0.0+0.0im

julia&gt; SID{1//2}(&#39;y&#39;) |&gt; matrix
2×2 Matrix{ComplexF64}:
 0.0-0.0im  -0.0+0.5im
 0.0-0.5im   0.0-0.0im

julia&gt; SID{1//2}(&#39;z&#39;) |&gt; matrix
2×2 Matrix{ComplexF64}:
 -0.5+0.0im  -0.0+0.0im
  0.0+0.0im   0.5+0.0im

julia&gt; SID{1//2}(&#39;+&#39;) |&gt; matrix
2×2 Matrix{ComplexF64}:
 0.0+0.0im  0.0+0.0im
 1.0+0.0im  0.0+0.0im

julia&gt; SID{1//2}(&#39;-&#39;) |&gt; matrix
2×2 Matrix{ComplexF64}:
 0.0+0.0im  1.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre><p>A <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin"><code>Spin</code></a> instance can be initialized as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; Spin{1}()
5-element Spin{1}:
 SID{1}(&#39;x&#39;)
 SID{1}(&#39;y&#39;)
 SID{1}(&#39;z&#39;)
 SID{1}(&#39;+&#39;)
 SID{1}(&#39;-&#39;)

julia&gt; Spin{1//2}()
5-element Spin{1//2}:
 SID{1//2}(&#39;x&#39;)
 SID{1//2}(&#39;y&#39;)
 SID{1//2}(&#39;z&#39;)
 SID{1//2}(&#39;+&#39;)
 SID{1//2}(&#39;-&#39;)</code></pre><p>Similar to <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock"><code>Fock</code></a>, a <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin"><code>Spin</code></a> instance behaves like a vector whose iteration generates all the allowed <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a> instances on its associated spatial point:</p><pre><code class="language-julia-repl hljs">julia&gt; sp = Spin{1}();

julia&gt; sp |&gt; typeof |&gt; eltype
SID{1, Char}

julia&gt; sp |&gt; length
5

julia&gt; [sp[1], sp[2], sp[3], sp[4], sp[5]]
5-element Vector{SID{1, Char}}:
 SID{1}(&#39;x&#39;)
 SID{1}(&#39;y&#39;)
 SID{1}(&#39;z&#39;)
 SID{1}(&#39;+&#39;)
 SID{1}(&#39;-&#39;)

julia&gt; sp |&gt; collect
5-element Vector{SID{1, Char}}:
 SID{1}(&#39;x&#39;)
 SID{1}(&#39;y&#39;)
 SID{1}(&#39;z&#39;)
 SID{1}(&#39;+&#39;)
 SID{1}(&#39;-&#39;)</code></pre><p>It is noted that a <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin"><code>Spin</code></a> instance generates <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a> instances not only limited to those corresponding to <span>$S^x$</span>, <span>$S^y$</span>, <span>$S^z$</span>, but also those to <span>$S^+$</span> and <span>$S^-$</span> although the former three already forms a complete set of the generators of the local SU(2) spin algebra. This overcomplete feature is for the convenience to the construction of spin Hamiltonians.</p><h4 id="Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex"><a class="docs-heading-anchor" href="#Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex">Unitcell and global levels: Hilbert, Index and CompositeIndex</a><a id="Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex-1"></a><a class="docs-heading-anchor-permalink" href="#Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex" title="Permalink"></a></h4><p>At the unitcell and global levels to construct the SU(2) spin algebra and spin generators, it is completely the same to that of the Fock algebra and Fock generators as long as we replace <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock"><code>Fock</code></a> and <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.FID"><code>FID</code></a> with <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin"><code>Spin</code></a> and <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.SID"><code>SID</code></a>, respectively:</p><pre><code class="language-julia-repl hljs">julia&gt; Hilbert(1=&gt;Spin{1//2}(), 2=&gt;Spin{1}())
Hilbert{Spin} with 2 entries:
  1 =&gt; Spin{1//2}()
  2 =&gt; Spin{1}()

julia&gt; Index(1, SID{1//2}(&#39;+&#39;))
Index(1, SID{1//2}(&#39;+&#39;))

julia&gt; CompositeIndex(Index(1, SID{1//2}(&#39;-&#39;)), [0.5, 0.5], [1.0, 1.0])
CompositeIndex(Index(1, SID{1//2}(&#39;-&#39;)), [0.5, 0.5], [1.0, 1.0])</code></pre><h3 id="Phononic-systems"><a class="docs-heading-anchor" href="#Phononic-systems">Phononic systems</a><a id="Phononic-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Phononic-systems" title="Permalink"></a></h3><h4 id="Local-level:-Phonon-and-PID"><a class="docs-heading-anchor" href="#Local-level:-Phonon-and-PID">Local level: Phonon and PID</a><a id="Local-level:-Phonon-and-PID-1"></a><a class="docs-heading-anchor-permalink" href="#Local-level:-Phonon-and-PID" title="Permalink"></a></h4><p>Phononic systems are also bosonic systems. However, the canonical creation and annihilation operators of phonons depends on the eigenvalues and eigenvectors of the dynamical matrix, making them difficult to be defined locally at each point. Instead, we resort to the momentum (<span>$\mathbf{p}$</span>) and displacement (<span>$\mathbf{u}$</span>) operators of lattice vibrations as the generators, which can be easily defined locally. The type <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.PID"><code>PID</code></a><code>&lt;:</code><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.IID"><code>IID</code></a> could specify such a local generator, which has the following attributes:</p><ul><li><code>tag::Char</code>: the tag, which must be either <code>&#39;p&#39;</code> or <code>&#39;u&#39;</code>, to specify whether it is the momentum or the displacement operator, respectively</li><li><code>direction::Char</code>: the direction, which must be one of <code>&#39;x&#39;</code>, <code>&#39;y&#39;</code> and <code>&#39;z&#39;</code>, to indicate which spatial directional component of the generator it is</li></ul><p>Correspondingly, the type <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Phonon"><code>Phonon</code></a><code>&lt;:</code><a href="../../man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Internal"><code>Internal</code></a>, which defines the local <span>$\{\mathbf{u}, \mathbf{p}\}$</span> algebra of the lattice vibrations, has the following attributes:</p><ul><li><code>ndirection::Int</code>: the spatial dimension of the lattice vibrations, which must be 1, 2, or 3</li></ul><p>Now let&#39;s see examples:</p><pre><code class="language-julia-repl hljs">julia&gt; PID(&#39;u&#39;, &#39;x&#39;)
PID(&#39;u&#39;, &#39;x&#39;)

julia&gt; PID(&#39;p&#39;, &#39;x&#39;)
PID(&#39;p&#39;, &#39;x&#39;)

julia&gt; Phonon(1) # one-dimensional lattice vibration only has the x component
2-element Phonon:
 PID(&#39;u&#39;, &#39;x&#39;)
 PID(&#39;p&#39;, &#39;x&#39;)

julia&gt; Phonon(2) # two-dimensional lattice vibration only has the x and y components
4-element Phonon:
 PID(&#39;u&#39;, &#39;x&#39;)
 PID(&#39;p&#39;, &#39;x&#39;)
 PID(&#39;u&#39;, &#39;y&#39;)
 PID(&#39;p&#39;, &#39;y&#39;)

julia&gt; Phonon(3) # three-dimensional lattice vibration has the x, y and z components
6-element Phonon:
 PID(&#39;u&#39;, &#39;x&#39;)
 PID(&#39;p&#39;, &#39;x&#39;)
 PID(&#39;u&#39;, &#39;y&#39;)
 PID(&#39;p&#39;, &#39;y&#39;)
 PID(&#39;u&#39;, &#39;z&#39;)
 PID(&#39;p&#39;, &#39;z&#39;)</code></pre><h4 id="Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex-2"><a class="docs-heading-anchor" href="#Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex-2">Unitcell and global levels: Hilbert, Index and CompositeIndex</a><a class="docs-heading-anchor-permalink" href="#Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex-2" title="Permalink"></a></h4><p>At the unitcell and global levels, lattice-vibration algebras and generators are the same to previous situations by <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.Phonon"><code>Phonon</code></a> and <a href="../../man/QuantumSystems/#QuantumLattices.QuantumSystems.PID"><code>PID</code></a> replaced with in the corresponding types:</p><pre><code class="language-julia-repl hljs">julia&gt; Hilbert(site=&gt;Phonon(2) for site=1:3)
Hilbert{Phonon} with 3 entries:
  1 =&gt; Phonon(ndirection=2)
  2 =&gt; Phonon(ndirection=2)
  3 =&gt; Phonon(ndirection=2)

julia&gt; Index(1, PID(&#39;u&#39;, &#39;x&#39;))
Index(1, PID(&#39;u&#39;, &#39;x&#39;))

julia&gt; CompositeIndex(Index(1, PID(&#39;u&#39;, &#39;x&#39;)), [0.5, 0.5], [1.0, 1.0])
CompositeIndex(Index(1, PID(&#39;u&#39;, &#39;x&#39;)), [0.5, 0.5], [1.0, 1.0])</code></pre><h2 id="Operator-and-Operators"><a class="docs-heading-anchor" href="#Operator-and-Operators">Operator and Operators</a><a id="Operator-and-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-and-Operators" title="Permalink"></a></h2><p>Now we arrive at the core types of this package, the <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a> and <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a>. They are defined to deal with the mathematical operations, i.e., the <code>+</code>/<code>-</code>/<code>*</code> operations between two elements of the algebra acting on the Hilbert space, and the scalar multiplication between an element of the algebra and a number. Specifically, an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a> represents a <strong>product</strong> of several generators of the algebra specified at any of the three levels along with a coefficient, and an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a> represents the <strong>sum</strong> of several instances of <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a>.</p><p><a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a> can be initialized by two ways:</p><pre><code class="language-julia-repl hljs">julia&gt; Operator(2, FID{:f}(1, -1//2, 2), FID{:f}(1, -1//2, 1), SID{1//2}(&#39;z&#39;))
Operator(2, FID{:f}(1, -1//2, 2), FID{:f}(1, -1//2, 1), SID{1//2}(&#39;z&#39;))

julia&gt; 2 * Index(1, FID{:f}(1, -1//2, 2)) * Index(2, SID{1//2}(&#39;z&#39;))
Operator(2, Index(1, FID{:f}(1, -1//2, 2)), Index(2, SID{1//2}(&#39;z&#39;)))</code></pre><p>It is noted that the number of the generators can be any natural number.</p><p>Although generators at different levels can be producted to make an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a>, it is not recommended to do so because the logic will be muddled:</p><pre><code class="language-julia-repl hljs">julia&gt; Operator(
           2,
           FID{:f}(1, 0, 2),
           CompositeIndex(Index(2, FID{:f}(1, 0, 1)), [0.0], [0.0])
       ) # never do this !!!
Operator(2, FID{:f}(1, 0, 2), CompositeIndex(Index(2, FID{:f}(1, 0, 1)), [0.0], [0.0]))</code></pre><p><a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a> can be iterated and indexed by integers, which will give the corresponding generators in the product:</p><pre><code class="language-julia-repl hljs">julia&gt; op = Operator(2, FID{:f}(1, 1//2, 2), FID{:f}(1, 1//2, 1));

julia&gt; length(op)
2

julia&gt; [op[1], op[2]]
2-element Vector{FID{:f, Int64, Rational{Int64}, Int64}}:
 FID{:f}(1, 1//2, 2)
 FID{:f}(1, 1//2, 1)

julia&gt; collect(op)
2-element Vector{FID{:f, Int64, Rational{Int64}, Int64}}:
 FID{:f}(1, 1//2, 2)
 FID{:f}(1, 1//2, 1)</code></pre><p>To get the coefficient of an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a> or all its individual generators as a whole, use the <a href="../../man/QuantumOperators/#QuantumLattices.value-Tuple{OperatorPack}"><code>value</code></a> and <a href="../../man/DegreesOfFreedom/#QuantumLattices.id-Tuple{Term}"><code>id</code></a> function exported by this package, respectively:</p><pre><code class="language-julia-repl hljs">julia&gt; op = Operator(2, FID{:f}(1, 0, 2), FID{:f}(1, 0, 1));

julia&gt; value(op)
2

julia&gt; id(op)
(FID{:f}(1, 0, 2), FID{:f}(1, 0, 1))</code></pre><p>The product between two <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a>s, or the scalar multiplication between a number and an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a> is also an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Operator(2, FID{:f}(1, 1//2, 2)) * Operator(3, FID{:f}(1, 1//2, 1))
Operator(6, FID{:f}(1, 1//2, 2), FID{:f}(1, 1//2, 1))

julia&gt; 3 * Operator(2, FID{:f}(1, 1//2, 2))
Operator(6, FID{:f}(1, 1//2, 2))

julia&gt; Operator(2, FID{:f}(1, 1//2, 2)) * 3
Operator(6, FID{:f}(1, 1//2, 2))</code></pre><p>The Hermitian conjugate of an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a> can be obtained by the adjoint operator:</p><pre><code class="language-julia-repl hljs">julia&gt; op = Operator(6, FID{:f}(2, 1//2, 2), FID{:f}(1, 1//2, 1));

julia&gt; op&#39;
Operator(6, FID{:f}(1, 1//2, 2), FID{:f}(2, 1//2, 1))</code></pre><p>There also exists a special <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a>, which only has the coefficient:</p><pre><code class="language-julia-repl hljs">julia&gt; Operator(2)
Operator(2)</code></pre><p><a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a> can be initialized by two ways:</p><pre><code class="language-julia-repl hljs">julia&gt; Operators(Operator(2, FID{:f}(1, 1//2, 1)), Operator(3, FID{:f}(1, 1//2, 2)))
Operators with 2 Operator
  Operator(2, FID{:f}(1, 1//2, 1))
  Operator(3, FID{:f}(1, 1//2, 2))

julia&gt; Operator(2, FID{:f}(1, 1//2, 1)) - Operator(3, FID{:b}(1, 1//2, 2))
Operators with 2 Operator
  Operator(2, FID{:f}(1, 1//2, 1))
  Operator(-3, FID{:b}(1, 1//2, 2))</code></pre><p>Similar items are automatically merged during the construction of <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Operators(Operator(2, FID{:f}(1, 1//2, 1)), Operator(3, FID{:f}(1, 1//2, 1)))
Operators with 1 Operator
  Operator(5, FID{:f}(1, 1//2, 1))

julia&gt; Operator(2, FID{:f}(1, 1//2, 1)) + Operator(3, FID{:f}(1, 1//2, 1))
Operators with 1 Operator
  Operator(5, FID{:f}(1, 1//2, 1))</code></pre><p>The multiplication between two <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a>es, or between an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a> and an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator"><code>Operator</code></a>, or between a number and an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a> are defined:</p><pre><code class="language-julia-repl hljs">julia&gt; ops = Operator(2, FID{:f}(1, 1//2, 1)) + Operator(3, FID{:f}(1, 1//2, 2));

julia&gt; op = Operator(2, FID{:f}(2, 1//2, 1));

julia&gt; ops * op
Operators with 2 Operator
  Operator(4, FID{:f}(1, 1//2, 1), FID{:f}(2, 1//2, 1))
  Operator(6, FID{:f}(1, 1//2, 2), FID{:f}(2, 1//2, 1))

julia&gt; op * ops
Operators with 2 Operator
  Operator(4, FID{:f}(2, 1//2, 1), FID{:f}(1, 1//2, 1))
  Operator(6, FID{:f}(2, 1//2, 1), FID{:f}(1, 1//2, 2))

julia&gt; another = Operator(2, FID{:f}(1, 1//2, 1)) + Operator(3, FID{:f}(1, 1//2, 2));

julia&gt; ops * another 
Operators with 2 Operator
  Operator(6, FID{:f}(1, 1//2, 1), FID{:f}(1, 1//2, 2))
  Operator(6, FID{:f}(1, 1//2, 2), FID{:f}(1, 1//2, 1))

julia&gt; 2 * ops
Operators with 2 Operator
  Operator(4, FID{:f}(1, 1//2, 1))
  Operator(6, FID{:f}(1, 1//2, 2))

julia&gt; ops * 2
Operators with 2 Operator
  Operator(4, FID{:f}(1, 1//2, 1))
  Operator(6, FID{:f}(1, 1//2, 2))</code></pre><p>It is noted that in the result, the distributive law automatically applies. Besides, the fermion operator relation <span>$c^2=c\dagger^2=0$</span> is also used.</p><p>As is usual, the Hermitian conjugate of an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a> can be obtained by the adjoint operator:</p><pre><code class="language-julia-repl hljs">julia&gt; op₁ = Operator(6, FID{:f}(1, 1//2, 2), FID{:f}(2, 1//2, 1));

julia&gt; op₂ = Operator(4, FID{:f}(1, 1//2, 1), FID{:f}(2, 1//2, 1));

julia&gt; ops = op₁ + op₂;

julia&gt; ops&#39;
Operators with 2 Operator
  Operator(6, FID{:f}(2, 1//2, 2), FID{:f}(1, 1//2, 1))
  Operator(4, FID{:f}(2, 1//2, 2), FID{:f}(1, 1//2, 2))</code></pre><p><a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a> can be iterated and indexed:</p><pre><code class="language-julia-repl hljs">julia&gt; ops = Operator(2, FID{:f}(1, 1//2, 1)) + Operator(3, FID{:f}(1, 1//2, 2));

julia&gt; collect(ops)
2-element Vector{Operator{Int64, Tuple{FID{:f, Int64, Rational{Int64}, Int64}}}}:
 Operator(2, FID{:f}(1, 1//2, 1))
 Operator(3, FID{:f}(1, 1//2, 2))

julia&gt; ops[1]
Operator(2, FID{:f}(1, 1//2, 1))

julia&gt; ops[2]
Operator(3, FID{:f}(1, 1//2, 2))</code></pre><p>The index order of an <a href="../../man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators"><code>Operators</code></a> is the insertion order of the operators it contains.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../SpatialInfoOfAUnitcell/">« Spatial information of a unitcell</a><a class="docs-footer-nextpage" href="../CouplingsAmongDifferentDegreesOfFreedom/">Couplings among different degrees of freedom »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 1 August 2024 03:09">Thursday 1 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
