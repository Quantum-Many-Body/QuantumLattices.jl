var documenterSearchIndex = {"docs":
[{"location":"advanced topics/ManageProjects/","page":"Manage projects","title":"Manage projects","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"advanced topics/ManageProjects/#Manage-projects","page":"Manage projects","title":"Manage projects","text":"","category":"section"},{"location":"man/QuantumSystems/","page":"Quantum Systems","title":"Quantum Systems","text":"CurrentModule = QuantumLattices.QuantumSystems","category":"page"},{"location":"man/QuantumSystems/#Quantum-Systems","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"section"},{"location":"man/QuantumSystems/","page":"Quantum Systems","title":"Quantum Systems","text":"Modules = [QuantumSystems]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.FockTerm","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.FockTerm","text":"FockTerm\n\nType alias for Union{Onsite, Hopping, Pairing, Hubbard, InterOrbitalInterSpin, InterOrbitalIntraSpin, SpinFlip, PairHopping, Coulomb}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.PhononTerm","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.PhononTerm","text":"PhononTerm\n\nType alias for Union{Kinetic, Hooke, Elastic}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.annihilation","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.annihilation","text":"annihilation\n\nIndicate that the nambu index is annihilation.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.creation","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.creation","text":"creation\n\nIndicate that the nambu index is creation.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexofbosons","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexofbosons","text":"latexofbosons\n\nThe default LaTeX format of a bosonic index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexoffermions","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexoffermions","text":"latexoffermions\n\nThe default LaTeX format of a fermionic index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexofparticles","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexofparticles","text":"latexofparticles\n\nThe default LaTeX format of a wildcard Fock index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexofphonons","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexofphonons","text":"latexofphonons\n\nThe default LaTeX format of a phonon index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexofspins","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexofspins","text":"latexofspins\n\nThe default LaTeX format of a spin index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.DegreesOfFreedom.MatrixCoupling-Tuple{Union{Colon, Tuple{Int64, Int64}}, Type{PID}, AbstractMatrix}","page":"Quantum Systems","title":"QuantumLattices.DegreesOfFreedom.MatrixCoupling","text":"MatrixCoupling(sites::Union{NTuple{2, Int}, Colon}, ::Type{PID}, matrix::AbstractMatrix)\n\nConstruct a set of Couplings corresponding to the dynamical matrix of phonons.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.DegreesOfFreedom.MatrixCoupling-Union{Tuple{F}, Tuple{Union{Colon, Tuple{Int64, Int64}}, Type{F}, Union{Colon, AbstractMatrix}, Union{Colon, AbstractMatrix}, Union{Colon, AbstractMatrix}}} where F<:FID","page":"Quantum Systems","title":"QuantumLattices.DegreesOfFreedom.MatrixCoupling","text":"MatrixCoupling(sites::Union{NTuple{2, Int}, Colon}, ::Type{F}, orbital::Union{AbstractMatrix, Colon}, spin::Union{AbstractMatrix, Colon}, nambu::Union{AbstractMatrix, Colon}) where {F<:FID}\n\nConstruct a set of Couplings between two Index{<:Union{Int, Colon}, <:FID}s with the coefficients specified by matrices acting on separated internal spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.DegreesOfFreedom.MatrixCoupling-Union{Tuple{S}, Tuple{Union{Colon, Tuple{Int64, Int64}}, Type{S}, AbstractMatrix}} where S<:SID","page":"Quantum Systems","title":"QuantumLattices.DegreesOfFreedom.MatrixCoupling","text":"MatrixCoupling(sites::Union{NTuple{2, Int}, Colon}, ::Type{S}, matrix::AbstractMatrix) where {S<:SID}\n\nConstruct a set of Couplings between two Index{<:Union{Int, Colon}, <:SID}s with the coefficients specified by a matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Coulomb","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Coulomb","text":"Coulomb(\n    id::Symbol, value, bondkind, coupling=Coupling(Index(:, FID(:, :, :)), Index(:, FID(:, :, :)))^2;\n    ishermitian::Bool=true,\n    amplitude::Union{Function, Nothing}=nothing,\n    modulate::Union{Function, Bool}=true\n)\n\nCoulomb term.\n\nType alias for Term{:Coulomb, id, V, B, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Elastic","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Elastic","text":"Elastic(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nGeneric elastic energy of phonons.\n\nType alias for Term{:Elastic, id, V, B, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.FID","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.FID","text":"FID{T, O<:Union{Int, Symbol, Colon}, S<:Union{Rational{Int}, Symbol, Colon}, N<:Union{Int, Symbol, Colon}} <: SimpleIID\n\nThe Fock id.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Fock","text":"Fock{T} <: SimpleInternal{FID{T, Int, Rational{Int}, Int}}\n\nThe Fock internal degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Hooke","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Hooke","text":"Hooke(id::Symbol, value, bondkind; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nPotential energy of phonons by the Hooke's law.\n\nType alias for Term{:Hooke, id, V, B, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Hopping","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Hopping","text":"Hopping(id::Symbol, value, bondkind, coupling=Coupling(Index(:, FID(:, :, :)), Index(:, FID(:, :, :))); amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nHopping term.\n\nType alias for Term{:Hopping, id, V, B, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Hubbard","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Hubbard","text":"Hubbard(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nHubbard term.\n\nType alias for Term{:Hubbard, id, V, Int, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.InterOrbitalInterSpin","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.InterOrbitalInterSpin","text":"InterOrbitalInterSpin(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nInterorbital-interspin term.\n\nType alias for Term{:InterOrbitalInterSpin, id, V, Int, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.InterOrbitalIntraSpin","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.InterOrbitalIntraSpin","text":"InterOrbitalIntraSpin(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nInterorbital-intraspin term.\n\nType alias for Term{:InterOrbitalIntraSpin, id, V, Int, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Kinetic","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Kinetic","text":"Kinetic(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nKinetic energy of phonons.\n\nType alias for Term{:Kinetic, id, V, Int, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Onsite","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Onsite","text":"Onsite(id::Symbol, value, coupling=Coupling(Index(:, FID(:, :, :)), Index(:, FID(:, :, :))); ishermitian::Bool=true, amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nOnsite term.\n\nType alias for Term{:Onsite, id, V, Int, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.PID","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.PID","text":"PID{D<:Union{Char, Symbol, Colon}} <: SimpleIID\n\nThe phonon id.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.PairHopping","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.PairHopping","text":"PairHopping(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nPair-hopping term.\n\nType alias for Term{:PairHopping, id, V, Int, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Pairing","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Pairing","text":"Pairing(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nPairing term.\n\nType alias for Term{:Pairing, id, V, B, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Phonon","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Phonon","text":"Phonon <: SimpleInternal{PID{Char}}\n\nThe phonon internal degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.SID","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.SID","text":"SID{S, T<:Union{Char, Symbol, Colon}} <: SimpleIID\n\nThe spin id.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Spin","text":"Spin{S} <: SimpleInternal{SID{S, Char}}\n\nThe spin internal degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.SpinFlip","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.SpinFlip","text":"SpinFlip(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nSpin-flip term.\n\nType alias for Term{:SpinFlip, id, V, Int, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.SpinTerm","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.SpinTerm","text":"SpinTerm(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true)\n\nSpin term.\n\nType alias for Term{:SpinTerm, id, V, B, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@DM_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@DM_str","text":"DM\"x\" => SparseMatrixCSC([0 0 0; 0 0 1; 0 -1 0])\nDM\"y\" => SparseMatrixCSC([0 0 -1; 0 0 0; 1 0 0])\nDM\"z\" => SparseMatrixCSC([0 1 0; -1 0 0; 0 0 0])\n\nThe DM coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@Heisenberg_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@Heisenberg_str","text":"Heisenberg\"\" => SparseMatrixCSC([1 0 0; 0 1 0; 0 0 1])\n\nThe Heisenberg coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@Ising_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@Ising_str","text":"Ising\"x\" => SparseMatrixCSC([1 0 0; 0 0 0; 0 0 0])\nIsing\"y\" => SparseMatrixCSC([0 0 0; 0 1 0; 0 0 0])\nIsing\"z\" => SparseMatrixCSC([0 0 0; 0 0 0; 0 0 1])\n\nThe Ising coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@L_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@L_str","text":"L\"x\" => SparseMatrixCSC([0 0 0; 0 0 1im; 0 -1im 0])\nL\"y\" => SparseMatrixCSC([0 0 -1im; 0 0 0; 1im 0 0])\nL\"z\" => SparseMatrixCSC([0 1im 0; -1im 0 0; 0 0 0])\n\nThe three-dimensional rotation generators.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@Γ_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@Γ_str","text":"Γ\"x\" => SparseMatrixCSC([0 0 0; 0 0 1; 0 1 0])\nΓ\"y\" => SparseMatrixCSC([0 0 1; 0 0 0; 1 0 0])\nΓ\"z\" => SparseMatrixCSC([0 1 0; 1 0 0; 0 0 0])\n\nThe Γ coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@σ_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@σ_str","text":"σ\"0\" => SparseMatrixCSC([1 0; 0 1])\nσ\"x\" => SparseMatrixCSC([0 1; 1 0])\nσ\"y\" => SparseMatrixCSC([0 -1im; 1im 0])\nσ\"z\" => SparseMatrixCSC([1 0; 0 -1])\nσ\"+\" => SparseMatrixCSC([0 1; 0 0])\nσ\"-\" => SparseMatrixCSC([0 0; 1 0])\nσ\"11\" => SparseMatrixCSC([1 0; 0 0])\nσ\"22\" => SparseMatrixCSC([0 0; 0 1])\n\nThe Pauli matrix σ⁰, σˣ, σʸ, σᶻ, σ⁺, σ⁻, σ¹¹, σ²².\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#Base.:*-Tuple{Operator{<:Number, <:Tuple{Vararg{QuantumLattices.DegreesOfFreedom.AbstractCompositeIndex{<:Index{Int64, <:FID{:f}}}, N}} where N}, Operator{<:Number, <:Tuple{Vararg{QuantumLattices.DegreesOfFreedom.AbstractCompositeIndex{<:Index{Int64, <:FID{:f}}}, N}} where N}}","page":"Quantum Systems","title":"Base.:*","text":"*(\n    f1::Operator{<:Number, <:ID{AbstractCompositeIndex{<:Index{Int, <:FID{:f}}}}},\n    f2::Operator{<:Number, <:ID{AbstractCompositeIndex{<:Index{Int, <:FID{:f}}}}}\n) -> Union{Nothing, Operator}\n\nGet the multiplication of two fermionic Fock operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#Base.angle-Tuple{CompositeIndex{<:Index{Int64, <:FID}}, AbstractVector{<:AbstractVector{<:Number}}, AbstractVector{<:Number}}","page":"Quantum Systems","title":"Base.angle","text":"angle(id::CompositeIndex{<:Index{Int, <:FID}}, vectors::AbstractVector{<:AbstractVector{<:Number}}, values::AbstractVector{<:Number}) -> Complex{<:Number}\n\nGet the twist phase corresponding to a Fock index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.matrix-Union{Tuple{SID{S, Char}}, Tuple{S}, Tuple{SID{S, Char}, Type{<:Number}}} where S","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(sid::SID{S, Char}, dtype::Type{<:Number}=Complex{Float}) where S -> Matrix{dtype}\n\nGet the matrix representation of a sid.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.script-Tuple{Val{:BD}, PID, LaTeX}","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{:BD}, pid::PID, l::LaTeX) -> String\nscript(::Val{:BD}, index::Index{<:Union{Int, Colon}, <:PID}, l::LaTeX) -> String\nscript(::Val{:BD}, index::AbstractCompositeIndex{<:Index{<:Union{Int, Colon}, <:PID}}, l::LaTeX) -> String\n\nGet the requested script of a phonon index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.script-Tuple{Val{:direction}, PID}","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{:direction}, pid::PID; kwargs...) -> String\n\nGet the requested script of an pid.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.script-Tuple{Val{:orbital}, FID}","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{:orbital}, fid::FID; kwargs...) -> String\nscript(::Val{:spint}, fid::FID; kwargs...) -> String\nscript(::Val{:spinsym}, fid::FID; kwargs...) -> String\nscript(::Val{:nambu}, fid::FID; kwargs...) -> String\n\nGet the requested script of an fid.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.script-Tuple{Val{:tag}, SID}","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{:tag}, sid::SID; kwargs...) -> String\n\nGet the requested script of an sid.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.isannihilation-Tuple{FID}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.isannihilation","text":"isannihilation(fid::FID) -> Bool\nisannihilation(index::Index) -> Bool\nisannihilation(index::AbstractCompositeIndex) -> Bool\n\nJudge whether the nambu index is annihilation.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.iscreation-Tuple{FID}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.iscreation","text":"iscreation(fid::FID) -> Bool\niscreation(index::Index) -> Bool\niscreation(index::AbstractCompositeIndex) -> Bool\n\nJudge whether the nambu index is creation.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.isnormalordered-Tuple{Operator{<:Number, <:Tuple{Vararg{QuantumLattices.DegreesOfFreedom.AbstractCompositeIndex{<:Index{Int64, <:FID}}, N}} where N}}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.isnormalordered","text":"isnormalordered(opt::Operator{<:Number, <:ID{AbstractCompositeIndex{<:Index{Int, <:FID}}}}) -> Bool\n\nJudge whether an operator is normal ordered.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.expand-Tuple{Val{:Hooke}, Coupling{<:Number, <:Tuple{Index{<:Union{Colon, Int64}, PID{Colon}}, Index{<:Union{Colon, Int64}, PID{Colon}}}}, Bond, Hilbert}","page":"Quantum Systems","title":"QuantumLattices.expand","text":"expand(::Val{:Hooke}, pnc::Coupling{<:Number, <:NTuple{2, Index{<:Union{Int, Colon}, PID{Colon}}}}, bond::Bond, hilbert::Hilbert) -> PPExpand\n\nExpand the default phonon potential coupling on a given bond.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.permute-Tuple{CompositeIndex{<:Index{Int64, <:FID{:b}}}, CompositeIndex{<:Index{Int64, <:FID{:b}}}}","page":"Quantum Systems","title":"QuantumLattices.permute","text":"permute(id₁::CompositeIndex{<:Index{Int, <:FID{:b}}}, id₂::CompositeIndex{<:Index{Int, <:FID{:b}}}) -> Tuple{Vararg{Operator}}\n\nPermute two bosonic indexes and get the result.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.permute-Tuple{CompositeIndex{<:Index{Int64, <:FID{:f}}}, CompositeIndex{<:Index{Int64, <:FID{:f}}}}","page":"Quantum Systems","title":"QuantumLattices.permute","text":"permute(id₁::CompositeIndex{<:Index{Int, <:FID{:f}}}, id₂::CompositeIndex{<:Index{Int, <:FID{:f}}}) -> Tuple{Vararg{Operator}}\n\nPermute two fermionic indexes and get the result.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.permute-Tuple{CompositeIndex{<:Index{Int64, PID{Char}}}, CompositeIndex{<:Index{Int64, PID{Char}}}}","page":"Quantum Systems","title":"QuantumLattices.permute","text":"permute(id₁::CompositeIndex{<:Index{Int, PID{Char}}}, id₂::CompositeIndex{<:Index{Int, PID{Char}}}) -> Tuple{Vararg{Operator}}\n\nPermute two phonon indexes and get the result.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.permute-Union{Tuple{S}, Tuple{CompositeIndex{<:Index{Int64, SID{S, Char}}}, CompositeIndex{<:Index{Int64, SID{S, Char}}}}} where S","page":"Quantum Systems","title":"QuantumLattices.permute","text":"permute(id₁::CompositeIndex{<:Index{Int, SID{S, Char}}}, id₂::CompositeIndex{<:Index{Int, SID{S, Char}}}) where S -> Tuple{Vararg{Operator}}\n\nPermute two spin indexes and get the result.\n\n\n\n\n\n","category":"method"},{"location":"advanced topics/Transformations/","page":"Transformations","title":"Transformations","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"advanced topics/Transformations/#Transformations","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"man/Frameworks/","page":"Frameworks","title":"Frameworks","text":"CurrentModule = QuantumLattices.Frameworks","category":"page"},{"location":"man/Frameworks/#Frameworks","page":"Frameworks","title":"Frameworks","text":"","category":"section"},{"location":"man/Frameworks/","page":"Frameworks","title":"Frameworks","text":"Modules = [Frameworks]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Action","page":"Frameworks","title":"QuantumLattices.Frameworks.Action","text":"Action\n\nAbstract type for all actions.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"Algorithm{F<:Frontend, P<:Parameters, M<:Function} <: Function\n\nAn algorithm associated with an frontend.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm-Tuple{Assignment}","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"(alg::Algorithm)(assign::Assignment) -> Tuple{Algorithm, Assignment}\n(assign::Assignment)(alg::Algorithm) -> Tuple{Algorithm, Assignment}\n\nRun an assignment based on an algorithm.\n\nThe difference between these two methods is that the first uses the parameters of assign as the current parameters while the second uses those of alg.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm-Tuple{Symbol, Action}","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"(alg::Algorithm)(id::Symbol, action::Action; info::Bool=true, kwargs...) -> Tuple{Algorithm, Assignment}\n\nAdd an assignment on a algorithm by providing the contents of the assignment, and run this assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm-Tuple{Symbol, Frontend}","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"Algorithm(name::Symbol, frontend::Frontend; din::String=\".\", dout::String=\".\", parameters::Parameters=Parameters(frontend), map::Function=identity)\n\nConstruct an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm-Tuple{Symbol}","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"(alg::Algorithm)(id::Symbol; info::Bool=true, parameters::Parameters=Parameters{()}()) -> Tuple{Algorithm, Assignment}\n\nRun an assignment specified by its id.\n\nOptionally, the time of the run process can be informed by setting the info argument to be true.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.AnalyticalExpression","page":"Frameworks","title":"QuantumLattices.Frameworks.AnalyticalExpression","text":"AnalyticalExpression{F<:Function, P<:Parameters} <: RepresentationGenerator\n\nRepresentation of a quantum lattice system by an analytical expression.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Assignment","page":"Frameworks","title":"QuantumLattices.Frameworks.Assignment","text":"Assignment{A<:Action, P<:Parameters, M<:Function, N, D} <: Function\n\nAn assignment associated with an action.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.CompositeGenerator","page":"Frameworks","title":"QuantumLattices.Frameworks.CompositeGenerator","text":"CompositeGenerator{E<:Entry, T<:Union{Table, Nothing}} <: RepresentationGenerator\n\nAbstract type for a composite representation generator of a quantum lattice system.\n\nBy protocol, it must have the following predefined contents:\n\noperators::E: the entry for the generated (representations of) quantum operators\ntable::T: the index-sequence table if it is not nothing\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Entry","page":"Frameworks","title":"QuantumLattices.Frameworks.Entry","text":"Entry{C, A<:NamedTuple, B<:NamedTuple, P<:Parameters, D<:Boundary} <: RepresentationGenerator\n\nThe basic representation generator of a quantum lattice system that records the quantum operators or a representation of the quantum operators related to (part of) the system.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Entry-Tuple{Tuple{Vararg{Term}}, Vector{<:Bond}, Hilbert}","page":"Frameworks","title":"QuantumLattices.Frameworks.Entry","text":"Entry(terms::Tuple{Vararg{Term}}, bonds::Vector{<:Bond}, hilbert::Hilbert; half::Bool=false, boundary::Boundary=plain)\n\nConstruct an entry of quantum operators based on the input terms, bonds, Hilbert space and (twisted) boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Frontend","page":"Frameworks","title":"QuantumLattices.Frameworks.Frontend","text":"Frontend\n\nThe frontend of algorithms applied to a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Image","page":"Frameworks","title":"QuantumLattices.Frameworks.Image","text":"Image{E<:Entry, H<:Transformation, T<:Union{Table, Nothing}} <: CompositeGenerator{E, T}\n\nThe image of a transformation applied to a representation of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.OperatorGenerator","page":"Frameworks","title":"QuantumLattices.Frameworks.OperatorGenerator","text":"OperatorGenerator{E<:Entry{<:Operators}, TS<:Tuple{Vararg{Term}}, B<:Bond, H<:Hilbert, T<:Union{Table, Nothing}} <: CompositeGenerator{E, T}\n\nA generator of operators based on the terms, bonds and Hilbert space of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.OperatorGenerator-Tuple{Tuple{Vararg{Term}}, Vector{<:Bond}, Hilbert}","page":"Frameworks","title":"QuantumLattices.Frameworks.OperatorGenerator","text":"OperatorGenerator(terms::Tuple{Vararg{Term}}, bonds::Vector{<:Bond}, hilbert::Hilbert; half::Bool=false, boundary::Boundary=plain, table::Union{Table,Nothing}=nothing)\n\nConstruct a generator of operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters{Names}(values::Number...) where Names\n\nA NamedTuple that contain the key-value pairs.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{Boundary}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(bound::Boundary)\n\nGet the parameters of the twisted boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{Entry}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(entry::Entry)\n\nGet the complete set of parameters of an entry of (representations of) quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.RepresentationGenerator","page":"Frameworks","title":"QuantumLattices.Frameworks.RepresentationGenerator","text":"RepresentationGenerator <: Frontend\n\nRepresentation generator of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.QuantumOperators.LinearTransformation-Tuple{Entry}","page":"Frameworks","title":"QuantumLattices.QuantumOperators.LinearTransformation","text":"(transformation::LinearTransformation)(entry::Entry; kwargs...) -> Entry\n\nApply a linear transformation to an entry of (representations of) quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.QuantumOperators.Transformation-Tuple{RepresentationGenerator}","page":"Frameworks","title":"QuantumLattices.QuantumOperators.Transformation","text":"(transformation::Transformation)(gen::RepresentationGenerator; table::Union{Table, Nothing}=nothing, kwargs...) -> Image\n\nGet the image of a transformation applied to a representation of a quantum lattice system.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.:*-Tuple{Entry, Any}","page":"Frameworks","title":"Base.:*","text":"*(entry::Entry, factor) -> Entry\n*(factor, entry::Entry) -> Entry\n\nMultiply an entry of quantum operators with a factor.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.:+-Tuple{Entry, Entry}","page":"Frameworks","title":"Base.:+","text":"+(entry₁::Entry, entry₂::Entry) -> Entry\n\nAddition of two entries of quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.empty-Tuple{Entry}","page":"Frameworks","title":"Base.empty","text":"empty(entry::Entry) -> Entry\nempty!(entry::Entry) -> Entry\n\nGet an empty copy of an entry or empty an entry of (representations of) quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.empty-Tuple{Image}","page":"Frameworks","title":"Base.empty","text":"empty(gen::Image) -> Image\nempty!(gen::Image) -> Image\n\nGet an empty copy of or empty the image of a transformation applied to a representation.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.empty-Tuple{OperatorGenerator}","page":"Frameworks","title":"Base.empty","text":"empty(gen::OperatorGenerator) -> OperatorGenerator\nempty!(gen::OperatorGenerator) -> OperatorGenerator\n\nGet an empty copy of or empty an operator generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.match-Tuple{NamedTuple{Names, <:Tuple{Vararg{Number}}} where Names, NamedTuple{Names, <:Tuple{Vararg{Number}}} where Names}","page":"Frameworks","title":"Base.match","text":"match(params₁::Parameters, params₂::Parameters; atol=atol, rtol=rtol) -> Bool\n\nJudge whether the second set of parameters matches the first.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.nameof-Tuple{Algorithm, Assignment}","page":"Frameworks","title":"Base.nameof","text":"nameof(alg::Algorithm, assign::Assignment) -> String\n\nGet the name of the combination of an algorithm and an assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.repr","page":"Frameworks","title":"Base.repr","text":"repr(alg::Algorithm, f::Function=param->true; ndecimal::Int=10) -> String\n\nGet the repr representation of an algorithm.\n\nOptionally, some parameters of the algorithm can be filtered by specifying the f function. Besides, the maximum number of decimals of the parameters can also be specified by the keyword argument ndecimal.\n\n\n\n\n\n","category":"function"},{"location":"man/Frameworks/#Base.summary-Tuple{Algorithm}","page":"Frameworks","title":"Base.summary","text":"summary(alg::Algorithm)\n\nProvide a summary of an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.valtype-Tuple{Assignment}","page":"Frameworks","title":"Base.valtype","text":"valtype(assign::Assignment)\nvaltype(::Type{<:Assignment})\n\nThe type of the data(result) of an assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.valtype-Union{Tuple{Type{<:Entry{C, A, B}}}, Tuple{B}, Tuple{A}, Tuple{C}} where {C, A<:NamedTuple, B<:NamedTuple}","page":"Frameworks","title":"Base.valtype","text":"valtype(::Type{<:Entry})\n\nGet the valtype of an entry of (representations of) quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.prepare!","page":"Frameworks","title":"QuantumLattices.Frameworks.prepare!","text":"prepare!(alg::Algorithm, assign::Assignment, f::Function=assign->true) -> Tuple{Algorithm, Assignment}\n\nRun the dependences of an assignment.\n\nOptionally, some dependences can be filtered by specifying the f function.\n\n\n\n\n\n","category":"function"},{"location":"man/Frameworks/#QuantumLattices.Spatials.save-Tuple{Algorithm, Assignment}","page":"Frameworks","title":"QuantumLattices.Spatials.save","text":"save(alg::Algorithm, assign::Assignment; delimited=false) -> Tuple{Algorithm, Assignment}\n\nSave the data of an assignment registered on an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.add!-Tuple{Algorithm, Symbol, Action}","page":"Frameworks","title":"QuantumLattices.add!","text":"add!(alg::Algorithm, id::Symbol, action::Action; parameters::Parameters=Parameters{()}(), map::Function=identity, dependences::Tuple=(), kwargs...) -> Tuple{Algorithm, Assignment}\n\nAdd an assignment on an algorithm by providing the contents of the assignment without the execution of it.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.expand!-Tuple{Any, Entry}","page":"Frameworks","title":"QuantumLattices.expand!","text":"expand!(result, entry::Entry) -> typeof(result)\n\nExpand an entry to get the (representation of) quantum operators related to a quantum lattice system.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.expand-Tuple{OperatorGenerator, Symbol}","page":"Frameworks","title":"QuantumLattices.expand","text":"expand(gen::OperatorGenerator, name::Symbol) -> Operators\nexpand(gen::OperatorGenerator, i::Int) -> Operators\nexpand(gen::OperatorGenerator, name::Symbol, i::Int) -> Operators\n\nExpand an operator generator to get:\n\nthe operators of a specific term;\nthe operators on a specific bond;\nthe operators of a specific term on a specific bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.expand-Tuple{RepresentationGenerator}","page":"Frameworks","title":"QuantumLattices.expand","text":"expand(gen::RepresentationGenerator) -> valtype(gen)\nexpand!(result, gen::RepresentationGenerator) -> typeof(result)\n\nExpand the generator to get the representation of the quantum lattice system (or some part of it).\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.reset!-Tuple{Entry, LinearTransformation, Entry{<:Operators}}","page":"Frameworks","title":"QuantumLattices.reset!","text":"reset!(entry::Entry, transformation::LinearTransformation, source::Entry{<:Operators}; kwargs...)\n\nReset an entry by its source entry of quantum operators and the corresponding linear transformation.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.reset!-Tuple{Entry{<:Operators}, Tuple{Vararg{Term}}, Vector{<:Bond}, Hilbert}","page":"Frameworks","title":"QuantumLattices.reset!","text":"reset!(entry::Entry{<:Operators}, terms::Tuple{Vararg{Term}}, bonds::Vector{<:Bond}, hilbert::Hilbert; half::Bool=false, boundary::Boundary=entry.boundary) -> Entry\n\nReset an entry of quantum operators by the new terms, bonds, Hilbert space and (twisted) boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.reset!-Tuple{Image, Transformation, RepresentationGenerator}","page":"Frameworks","title":"QuantumLattices.reset!","text":"reset!(gen::Image, transformation::Transformation, source::RepresentationGenerator; table::Union{Table, Nothing}=nothing, kwargs...) -> Image\n\nReset the image of a transformation applied to a representation.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.reset!-Tuple{OperatorGenerator, AbstractLattice, Hilbert}","page":"Frameworks","title":"QuantumLattices.reset!","text":"reset!(gen::OperatorGenerator, lattice::AbstractLattice, hilbert::Hilbert; neighbors=max(map(term->term.bondkind, gen.terms)...)) -> OperatorGenerator\n\nReset an operator generator by a new lattice and the corresponding new hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Algorithm}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(alg::Algorithm; parameters...) -> Algorithm\n\nUpdate the parameters of an algorithm and its associated frontend.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Assignment}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(assign::Assignment; parameters...) -> Assignment\n\nUpdate the parameters of an assignment and the status of its associated action.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Entry, LinearTransformation, Entry{<:Operators}}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(entry::Entry, transformation::LinearTransformation, source::Entry{<:Operators}; kwargs...) -> Entry\n\nUpdate the parameters (including the boundary parameters) of an entry based on its source entry of quantum operators and the corresponding linear transformation.\n\n!!! Note     The coefficients of boundops are also updated due to the change of the boundary parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Entry{<:Operators}}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(entry::Entry{<:Operators}; parameters...) -> Entry\n\nUpdate the parameters (including the boundary parameters) of an entry of quantum operators.\n\n!!! Note     The coefficients of boundops are also updated due to the change of the boundary parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Image, RepresentationGenerator}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(gen::Image, source::RepresentationGenerator; kwargs...) -> Image\n\nUpdate the parameters of the image based on its source representation.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Image}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(gen::Image; parameters...) -> typeof(gen)\n\nUpdate the parameters of the image of a transformation applied to a representation.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{OperatorGenerator}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(gen::OperatorGenerator; parameters...) -> typeof(gen)\n\nUpdate the coefficients of the terms in a generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Tuple{Algorithm, Assignment}}","page":"Frameworks","title":"RecipesBase.apply_recipe","text":"@recipe plot(pack::Tuple{Algorithm, Assignment})\n\nDefine the recipe for the visualization of an assignment of an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"advanced topics/HybridSystems/","page":"Hybrid systems","title":"Hybrid systems","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"advanced topics/HybridSystems/#Hybrid-systems","page":"Hybrid systems","title":"Hybrid systems","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"CurrentModule = QuantumLattices.Toolkit\nDocTestFilters = [r\"var\\\".*\\\"\", r\"generic function with [0-9]* method\", r\".*s \\(.*\\% GC\\)\", r\"evals/sample:.*\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../../src/\")\n    using QuantumLattices.Toolkit\n    import QuantumLattices.Toolkit: isparameterbound, parameternames, contentnames, getcontent\nend","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"push!(LOAD_PATH, \"../../../src/\")\nusing QuantumLattices.Toolkit","category":"page"},{"location":"man/Toolkit/#Toolkit","page":"Toolkit","title":"Toolkit","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"This module contains the toolkit of the package.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The constants, types, macros, functions defined in this module will not be exported by the package. Instead, they serve as the prerequisites. The range of the contents are quite wide, but basically, they fall into two categories:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Utilities, such as global constants and miscellaneous tiny useful functions;\nBasic data structures as supplements to the Julia.Base and other common packages.","category":"page"},{"location":"man/Toolkit/#Utilities","page":"Toolkit","title":"Utilities","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"atol\nrtol\nFloat\nconcatenate\ndecimaltostr\ndelta\nordinal\nSegment","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.atol","page":"Toolkit","title":"QuantumLattices.Toolkit.atol","text":"Absolute tolerance for float numbers.\n\n\n\n\n\n","category":"constant"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.rtol","page":"Toolkit","title":"QuantumLattices.Toolkit.rtol","text":"Relative tolerance for float numbers.\n\n\n\n\n\n","category":"constant"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Float","page":"Toolkit","title":"QuantumLattices.Toolkit.Float","text":"Default float type.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.concatenate","page":"Toolkit","title":"QuantumLattices.Toolkit.concatenate","text":"concatenate(ts::Tuple...) -> Tuple\n\nConcatenate tuples.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.decimaltostr","page":"Toolkit","title":"QuantumLattices.Toolkit.decimaltostr","text":"decimaltostr(number, ::Int=5)\ndecimaltostr(number::Integer, n::Int=5)\ndecimaltostr(number::Rational, n::Int=5)\ndecimaltostr(number::AbstractFloat, n::Int=5)\ndecimaltostr(number::Complex, n::Int=5)\n\nConvert a number to a string with at most n decimal places.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.delta","page":"Toolkit","title":"QuantumLattices.Toolkit.delta","text":"delta(i, j) -> Int\n\nKronecker delta function.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.ordinal","page":"Toolkit","title":"QuantumLattices.Toolkit.ordinal","text":"ordinal(number::Integer)\n\nConvert a positive number to its corresponding ordinal.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Segment","page":"Toolkit","title":"QuantumLattices.Toolkit.Segment","text":"Segment{S} <: AbstractVector{S}\n\nA segment.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Combinatorics","page":"Toolkit","title":"Combinatorics","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The combinations and permutations of an indexable object are implemented, with duplicate elements allowed or not. Compared to another Julia package Combinatorics, the iterators return tuples instead of vectors, which could greatly decrease the memory allocation times and improves the code efficiency.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Combinatorics{M, C} is the abstract type of all combinatorial algorithms. It has two type parameters:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"M: the number of elements to be taken\nC: the type of the collection of candidate elements","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To avoid memory allocation, the iteration of a concrete combinatorial algorithm returns a tuple, whose length is M and eltype is eltype(C).","category":"page"},{"location":"man/Toolkit/#Combinations-and-DuplicateCombinations","page":"Toolkit","title":"Combinations and DuplicateCombinations","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Combinations{M, C} and DuplicateCombinations{M, C} generate all the combinations of M elements from an indexable collection whose type is C, with the differences being that the former forbids duplicate elements in the combinations while the latter allows.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"All combinations of 2 integers taken from 1 to 3 without duplicate:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Combinations{2}(1:3) |> collect","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"All combinations of 2 integers taken from 1 to 3 with duplicate allowed:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"DuplicateCombinations{2}(1:3) |> collect","category":"page"},{"location":"man/Toolkit/#Permutations-and-DuplicatePermutations","page":"Toolkit","title":"Permutations and DuplicatePermutations","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Permutations{M, C} and DuplicatePermutations{M, C} generate all the permutations of M elements from an indexable collection whose type is C, with the differences being that the former forbids duplicate elements in the permutations while the latter allows.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"All permutations of 2 integers taken from 1 to 3 without duplicate:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Permutations{2}(1:3) |> collect","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"All permutations of 2 integers taken from 1 to 3 with duplicate allowed:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"DuplicatePermutations{2}(1:3) |> collect","category":"page"},{"location":"man/Toolkit/#Manual","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Combinatorics\nCombinations\nDuplicateCombinations\nPermutations\nDuplicatePermutations","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Combinatorics","page":"Toolkit","title":"QuantumLattices.Toolkit.Combinatorics","text":"Combinatorics{M, C}\n\nAbstract combinatorial algorithms.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Combinations","page":"Toolkit","title":"QuantumLattices.Toolkit.Combinations","text":"Combinations{M}(contents::C) where {M, C}\n\nCombinations of M elements from contents. Duplicates are not allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.DuplicateCombinations","page":"Toolkit","title":"QuantumLattices.Toolkit.DuplicateCombinations","text":"DuplicateCombinations{M}(contents::C) where {M, C}\n\nCombinations of M elements from contents. Duplicates are allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Permutations","page":"Toolkit","title":"QuantumLattices.Toolkit.Permutations","text":"Permutations{M}(contents::C) where {M, C}\n\nPermutations of M elements from contents. Duplicates are not allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.DuplicatePermutations","page":"Toolkit","title":"QuantumLattices.Toolkit.DuplicatePermutations","text":"DuplicatePermutations{M}(contents::C) where {M, C}\n\nPermutations of M elements from contents. Duplicates are allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Traits","page":"Toolkit","title":"Traits","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Trait functions and trait types that are useful to the package are defined.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Generally speaking, traits in Julia could fall into two categories according to their usages, the first may be term as \"type helpers\" and the second are usually called \"Holy traits\" named after Tim Holy. Type helpers aim at the inquiry, alteration and computation of the compile-time information of types, while Holy traits can be applied as an alternative to multi-inheritance by use of the Julia multidispatch feature.","category":"page"},{"location":"man/Toolkit/#Type-helpers","page":"Toolkit","title":"Type helpers","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Type helpers are important for the generic programming in Julia, especially in the design of generic interfaces and abstract types.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Let's see a simple situation, i.e. the elemental addition of two vectors of numbers. The numbers can assume different types and the type of the result depends on both of them, for example, the result between two vectors of integers is a vector of integers while that between a vector of integers and a vector of floats is a vector of floats. Of course, one can explicitly define every elemental addition function between any two different types of vectors of numbers, like this:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"# wrong design pattern\n\nfunction elementaladdition(v₁::Vector{Int64}, v₂::Vector{Int64})\n    result = Int[]\n    ...\nend\nfunction elementaladdition(v₁::Vector{Int64}, v₂::Vector{Float64})\n    result = Float64[]\n    ...\nend\n...\n...","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Writing down all such methods is already a heavy repetition. What's worse, you will quickly find that a lot more functions, such as the elemental subtraction, elemental multiplication and elemental division, are waiting for you to implement. This is a total disaster.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The correct strategy is to define the promotion rule of any two types of numbers and use it to define the type of the result:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"# correct design pattern\n\npromotion(::Type{Int64}, ::Type{Int64}) = Int64\npromotion(::Type{Int64}, ::Type{Float64}) = Float64\n...\n...\n\nfunction elementaladdition(v₁::Vector{T₁}, v₂::Vector{T₂}) where {T₁<:Number, T₂<:Number}\n    result = promotion(T₁, T₂)[]\n    ...\nend\nfunction elementalsubtraction(v₁::Vector{T₁}, v₂::Vector{T₂}) where {T₁<:Number, T₂<:Number}\n    result = promotion(T₁, T₂)[]\n    ...\nend\n...\n...","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The promotion rule applies equally to all the arithmetic operations on numbers. Therefore, tedious code repetition could be avoided with it. In fact, similar promotion rules have already been defined in Julia base, and the default implementations of arithmetic operations in Julia are indeed based on them (see Base.promote_rule and Base.promote_type). When new user-defined numeric types are introduced, the only things you need to do is to add new promotion rules and implement a few basic arithmetic functions for these new types. Then quite a lot of generic codes could apply to them without any modification.","category":"page"},{"location":"man/Toolkit/#Type-helpers-with-type-parameters","page":"Toolkit","title":"Type helpers with type parameters","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The input and output types of a promotion rule are known at compile time, thus, the promotion rule is a trait function aiming at the computation of compile-time information of types. Trait functions dealing with the inquiries of compile-time information of types are also widely used in Julia, such as the eltype function of Vector:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> eltype(Vector{String})\nString","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For a user-defined parametric type, it is also useful to provide an inquiry function to access to the type parameters:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> struct Hi{T<:Number}\n           content::T\n       end\n       contenttype(::Type{Hi{T}}) where T<:Number = T\n       contenttype(Hi{Int64})\nInt64","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"However, the above defined function contenttype could not apply to a UnionAll type, such as Hi{<:Real}:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> contenttype(Hi{<:Real})\nERROR: MethodError: no method matching contenttype(::Type{Hi{<:Real}})\n[...]","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"In fact in Julia base, all such inquiry functions, e.g., the eltype function, work poor for the UnionAll types:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> eltype(Vector{<:Real})\nAny","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"In concept, eltype(Vector{<:Real} should return Real instead of Any as every element in Vector{<:Real} is indeed a real number. Similarly, we expect that contenttype(Hi{<:Real}) should also give us Real. Unfortunately, functions defined in the similar form like this could never achieve such goals. Julia base doesn't provide generic functions to access or change the information of the parameters of a type. In this module, we try to fill this gap with a set of generic trait functions.","category":"page"},{"location":"man/Toolkit/#Access-or-change-the-type-parameters-by-their-position-orders","page":"Toolkit","title":"Access or change the type parameters by their position orders","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The most direct information of the parameters of a type is their position orders. We provide parametertype to access to them by such information:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametertype(Hi{<:Real}, 1)\nReal\n\njulia> parametertype(Vector{<:Real}, 1)\nReal\n\njulia> parametertype(Vector{<:Real}, 2)\n1","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"You can use parametercount to inquire the total number of the parameters of a type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametercount(Hi)\n1\n\njulia> parametercount(Vector)\n2","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"It is noted that Vector has 2 type parameters because it is just a type alias for Array{T, 1} where T.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To change the parameters of a type, reparameter can be used:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> reparameter(Hi{Int64}, 1, Real)\nHi{Real}\n\njulia> reparameter(Vector{Int64}, 1, Real)\nVector{Real} (alias for Array{Real, 1})\n\njulia> reparameter(Vector{<:Real}, 2, 3)\nArray{<:Real, 3}\n\njulia> reparameter(Hi{Int64}, 1, Real, false)\nHi{Real}\n\njulia> reparameter(Hi{Int64}, 1, Real, true)\nHi{<:Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"We want to remark that by providing the fourth positional argument with the true value, a UnionAll type could be generated. When the fourth positional argument is omitted, it is actually determined by another trait function, i.e., isparameterbound. This function judges whether an input type should be considered as the upper bound of the new parameter of a type. By default, it is always defined to be false. This function can be overloaded to change the behavior for a certain type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> isparameterbound(::Type{<:Hi}, ::Val{1}, D) = !isconcretetype(D);\n\njulia> reparameter(Hi, 1, Real)\nHi{<:Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The second positional argument of isparameterbound must be of type Val because in principle you should be able to assign different behaviors for different parameters of a type separately. If it is of type Integer, a single overloading would change the behaviors for all.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Besides, you can inquire all the parameters of a type by parametertypes:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametertypes(Hi{<:Real})\nTuple{Real}\n\njulia> parametertypes(Vector{Int64})\nTuple{Int64, 1}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The obtained type parameters are stored as those of a Tuple.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"At the same time, you can change all the parameters of a type by fulltype:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> fulltype(Hi{Int64}, Tuple{Real})\nHi{<:Real}\n\njulia> fulltype(Hi{Int64}, Tuple{Real}, (false,))\nHi{Real}\n\njulia> fulltype(Vector{Int64}, Tuple{Real, 2})\nMatrix{Real} (alias for Array{Real, 2})\n\njulia> fulltype(Vector{Int64}, Tuple{Real, 2}, (true, false))\nMatrix{<:Real} (alias for Array{<:Real, 2})","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Like reparameter, the last positional argument of fulltype could determine whether the corresponding types specified by the type parameters of the input Tuple should be considered as the upper bounds of the new parameters of a type. When this argument is omitted, it is determined by another trait function isparameterbounds, which successively calls the isparameterbound function to determine the behaviors for all the parameters of a type as the literal indicates.","category":"page"},{"location":"man/Toolkit/#Associate-type-parameters-with-names","page":"Toolkit","title":"Associate type parameters with names","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Sometimes, it is more convenient to associate names with the parameters of a type, and then access or change them by their names. This can be done by overloading the parameternames trait function for a certain type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parameternames(::Type{<:Hi}) = (:content,)\nparameternames (generic function with 3 methods)","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Now, you can inquire the name of a type parameter by parametername with the given position order or vice versa by parameterorder:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametername(Hi, 1)\n:content\n\njulia> parameterorder(Hi, :content)\n1","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"You can also inquire whether a type has a parameter with the given name by hasparameter:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> hasparameter(Hi, :content)\ntrue\n\njulia> hasparameter(Hi, :others)\nfalse","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"And parametertype and reparameter can be applied by the name of a type parameter instead of its position order:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametertype(Hi{<:Real}, :content)\nReal\n\njulia> reparameter(Hi{Int}, :content, Real)\nHi{Real}\n\njulia> reparameter(Hi{Int}, :content, Real, true)\nHi{<:Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To change the reparameter behavior when its last positional argument is omitted, you should overload the isparameterbound function accordingly, e.g.:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> isparameterbound(::Type{<:Hi}, ::Val{:content}, D) = !isconcretetype(D);\n\njulia> reparameter(Hi{Int}, :content, Real)\nHi{<:Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"note: Note\nAccessing or altering a parameter of a type by its name is independent from that by its position order. Thus, even the following methodisparameterbound(::Type{<:Hi}, ::Val{1}, D)has been overloaded, it doesn't affect the result of the function call likereparameter(Hi{Int}, :content, Real)Rather, it only affect the result of the function call likereparameter(Hi{Int}, 1, Real)To change the default behavior of the former function call, you must overload the following method manually as wellisparameterbound(::Type{<:Hi}, ::Val{:content}, D)","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A new trait function parameterpair is provided to inquire the name-type pair of a parameter of a type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parameterpair(Hi{<:Real}, 1)\nPair{:content, Real}\n\njulia> parameterpair(Hi{<:Real}, :content)\nPair{:content, Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"And a new trait function parameterpairs can be used to inquire all the name-type pairs of the parameters of a type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parameterpairs(Hi{<:Real})\nNamedTuple{(:content,), Tuple{Real}}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The parameters of a type can be altered all at once by giving the name-type pairs to fulltype:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}}, (false,))\nHi{Real}\n\njulia> fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}}, (true,))\nHi{<:Real}\n\njulia> fulltype(Hi{Int}, NamedTuple{(:content,),Tuple{Real}})\nHi{<:Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Here, the last positional argument can be omitted whose default value would be determined by the isparameterbounds function which successively calls the isparameterbound function on each of the named parameter. Note that similar to the situation of the reparameter function in this subsubsection, the isparameterbound function called here is also the version that takes the parameter name as the input rather than that of the position order.","category":"page"},{"location":"man/Toolkit/#Type-helpers-with-predefined-contents","page":"Toolkit","title":"Type helpers with predefined contents","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Julia abstract types don't have any field or attribute. They are only tags on the type tree. However, we may expect sometimes an abstract type to possess some kind of predefined content so that the design of some methods could be highly simplified. For example, we may need an abstract type that describes a composite vector. Apparently, it should have a field that is the vector contained in it. Of course, we can appoint a fixed field name with it and force every concrete subtype must contain such a field. In such a design pattern, the name of this field in every concrete subtype must be kept unchanged, which may be annoying when it conflicts with that of another field. What's worse, a predefined content of an abstract type is not always limited to a certain field. Maybe we need more than one fields to construct such a content. The just mentioned design pattern cannot deal with such situations.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Here, we provide a set of trait functions to help the design of abstract types with predefined contents. We take the case of composite vector for illustration, and the generalization to other situations is straightforward. First, the trait function contentnames should be overloaded to define the names of the predefined contents:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> abstract type CompositeVector{T} end\n       contentnames(::Type{<:CompositeVector}) = (:content,);","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Then you can inquire the total number of predefined contents by contentcount, inquire the name of a predefined content with its position order by contentname, and judge whether a type has a predefined content with a given name by hascontent:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> contentcount(CompositeVector)\n1\n\njulia> contentname(CompositeVector, 1)\n:content\n\njulia> hascontent(CompositeVector, :content)\ntrue\n\njulia> hascontent(CompositeVector, :value)\nfalse","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The key is the interface getcontent, which defines how to get the value of the predefined content. For the simple case when the predefined content just corresponds to a field, and also the field name of the predefined content coincides with the content name, the overloading of getcontent can be omitted, e.g.:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> struct AnotherCompositeVector{T} <: CompositeVector{T}\n           content::Vector{T}\n       end;\n\njulia> v = AnotherCompositeVector([1, 2, 3])\n       getcontent(v, :content)\n3-element Vector{Int64}:\n 1\n 2\n 3","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For the cases when a predefined contents does not share the same name with a certain field, or even it is not limited to only one certain field, you must implement your own getcontent manually. Let's see two typical examples:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> struct DifferentFieldName{T} <: CompositeVector{T}\n           data::Vector{T}\n       end\n       getcontent(v::DifferentFieldName, ::Val{:content}) = v.data;\n\njulia> struct BeyondSingleField{T} <: CompositeVector{T}\n           firsthalf::Vector{T}\n           secondhalf::Vector{T}\n       end\n       getcontent(v::BeyondSingleField, ::Val{:content}) = [v.firsthalf; v.secondhalf];\n\njulia> v = DifferentFieldName([1, 2, 3])\n       getcontent(v, :content)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> v = BeyondSingleField([1, 2, 3], [4, 5, 6])\n       getcontent(v, :content)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Note that for the method overloading of getcontent, the second argument is of type Val{:content}. This is convenient because in principle an abstract type could have more than only one predefined content, thus, the behaviors of the getcontent function could be defined separately for different predefined contents in this way. In fact, the function call getcontent(m, contentname) is just an alias for getcontent(m, contentname|>Val).","category":"page"},{"location":"man/Toolkit/#Holy-traits","page":"Toolkit","title":"Holy traits","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"As an emergent feature of Julia, basically speaking, a Holy trait is a Julia type that could direct the generic function of a user-defined type to a certain implementation based on the Julia multi-dispatch mechanism. For different user-defined types, they could be assigned with different Holy traits, leading to different implementations of the same generic interface. Since the information of Holy traits are known at compile time, such design pattern doesn't affect the runtime efficiency as long as type stability is ensured.","category":"page"},{"location":"man/Toolkit/#Alternative-of-multi-inheritance","page":"Toolkit","title":"Alternative of multi-inheritance","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Maybe the most common application of Holy traits is to serve as the alternative of multi-inheritance. Let's see a simple scenario. You have defined an abstract type. It is natural to demand that for every concrete subtype of it, a pair of instances could be compared and judge whether they are equivalent to each other by the value. Unfortunately, for a new user-defined type, the default == function in Julia actually judges whether they are the same object, but not equal to each other by the value. Therefore, you need to define your own == function for this abstract type. However, you may need define a lot of abstract types when you are developing a Julia package. It is annoying if such simple functions must be written for each of them. In other languages like Python, this could be solved with the help of multi-inheritance. But Julia does not support multi-inheritance. The common way is to use Holy traits. For example, the above issue could be solved like this:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"struct Equivalence end\nconst equivalence = Equivalence()\nfunction Base.:(==)(::Equivalence, o₁, o₂)\n    n₁, n₂ = fieldcount(typeof(o₁)), fieldcount(typeof(o₂))\n    n₁≠n₂ && return false\n    for i = 1:n₁\n        getfield(o₁, i)≠getfield(o₂, i) && return false\n    end\n    return true\nend\n\nabstract type TypeWithEquivalence end\nBase.:(==)(o₁::TypeWithEquivalence, o₂::TypeWithEquivalence) = ==(equivalence, o₁, o₂);\n\nstruct ConcreteTypeWithEquivalence{F₁, F₂} <: TypeWithEquivalence\n    f₁::F₁\n    f₂::F₂\nend;\n\na₁ = ConcreteTypeWithEquivalence((\"a\", \"b\", \"c\"), [1, 2, 3])\na₂ = ConcreteTypeWithEquivalence((\"a\", \"b\", \"c\"), [1.0, 2.0, 3.0])\na₁ == a₂","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Here, the type Equivalence is the Holy trait that helps the abstract type TypeWithEquivalence to implement the == function, which applies equally to any other types.","category":"page"},{"location":"man/Toolkit/#Type-stability-and-the-generated-function-trick","page":"Toolkit","title":"Type stability and the generated function trick","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"However, the story does not end up here. If you are concerned about the code efficiency, you may find that the above implementation is not type stable:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"using BenchmarkTools\n@benchmark $a₁ == $a₂","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The memory allocation occurs when the == function tries to compare the values of getfield(o₁, i) and getfield(o₂, i) because in principle the types of these values depend on the runtime value of the variable i. To ensure type stability, the generated function trick can be utilized:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"struct EfficientEquivalence end\nconst efficientequivalence = EfficientEquivalence()\n@generated function Base.:(==)(::EfficientEquivalence, o₁, o₂)\n    n₁, n₂ = fieldcount(o₁), fieldcount(o₂)\n    n₁≠n₂ && return false\n    expr = :(getfield(o₁, 1) == getfield(o₂, 1))\n    for i = 2:n₁\n        expr = Expr(:&&, expr, :(getfield(o₁, $i) == getfield(o₂, $i)))\n    end\n    return expr\nend\n\nabstract type TypeWithEfficientEquivalence end\nfunction Base.:(==)(o₁::TypeWithEfficientEquivalence, o₂::TypeWithEfficientEquivalence)\n    return ==(efficientequivalence, o₁, o₂)\nend\n\nstruct ConcreteTypeWithEfficientEquivalence{F₁, F₂} <: TypeWithEfficientEquivalence\n    f₁::F₁\n    f₂::F₂\nend\n\na₁ = ConcreteTypeWithEfficientEquivalence((\"a\", \"b\", \"c\"), [1, 2, 3])\na₂ = ConcreteTypeWithEfficientEquivalence((\"a\", \"b\", \"c\"), [1.0, 2.0, 3.0])\na₁ == a₂","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"@benchmark $a₁ == $a₂","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"At runtime of the generated == function, it compares the values of getfield(o₁, 1) and getfield(o₂, 1), getfield(o₁, 2) and getfield(o₂, 2), etc., whose types are known at compile time. Therefore, type stability could be ensured.","category":"page"},{"location":"man/Toolkit/#EfficientOperations","page":"Toolkit","title":"EfficientOperations","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"EfficientOperations is a Holy trait defined in this module that packs several common operations, such as ==/isequal, </isless, isapprox and replace, to help other (abstract) types to implement such functions by passing efficientoperations as the first argument, just as illustrated above. See the manual for more detailed information.","category":"page"},{"location":"man/Toolkit/#Manual-2","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For traits with types themselves:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"commontype\nfulltype\nrawtype\nDataType\nsupertype","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.commontype","page":"Toolkit","title":"QuantumLattices.Toolkit.commontype","text":"commontype(f::Function, types, ::Type{T}=Any) where T\n\nFind the common return type of a function.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.fulltype","page":"Toolkit","title":"QuantumLattices.Toolkit.fulltype","text":"fulltype(::Type{T}, ::Type{PS}, ubs::Tuple{Vararg{Bool}}=isparameterbounds(T, PS)) where {T, PS<:Tuple}\nfulltype(::Type{T}, ::Type{PS}, ubs::Tuple{Vararg{Bool}}=isparameterbounds(T, PS)) where {T, PS<:NamedTuple}\n\nGet the full type of type T with the type parameters replaced by those of PS.\n\nHere, ubs determines whether the new type parameter should be considered as the upper bound accordingly.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.rawtype","page":"Toolkit","title":"QuantumLattices.Toolkit.rawtype","text":"rawtype(::Type{T}) where T -> DataType/UnionAll\n\nGet the \"raw part\" of a type. That is, the type without all its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#Core.DataType","page":"Toolkit","title":"Core.DataType","text":"DataType <: Type{T}\n\nDataType represents explicitly declared types that have names, explicitly declared supertypes, and, optionally, parameters.  Every concrete value in the system is an instance of some DataType.\n\nExamples\n\njulia> typeof(Real)\nDataType\n\njulia> typeof(Int)\nDataType\n\njulia> struct Point\n           x::Int\n           y\n       end\n\njulia> typeof(Point)\nDataType\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Base.supertype","page":"Toolkit","title":"Base.supertype","text":"supertype(T::DataType)\n\nReturn the supertype of DataType T.\n\nExamples\n\njulia> supertype(Int32)\nSigned\n\n\n\n\n\nsupertype(T, termination::Symbol) -> DataType\n\nGet the supertype of T till termination.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For traits with type parameters:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"hasparameter\nisparameterbound\nisparameterbounds\nparametercount\nparametername\nparameternames\nparameterorder\nparameterpair\nparameterpairs\nparametertype\nparametertypes\npromoteparameters\nreparameter","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.hasparameter","page":"Toolkit","title":"QuantumLattices.Toolkit.hasparameter","text":"hasparameter(::Type{T}, name::Symbol) where T -> Bool\n\nFor type T, judge whether it has a type parameter specified by name.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.isparameterbound","page":"Toolkit","title":"QuantumLattices.Toolkit.isparameterbound","text":"isparameterbound(::Type{T}, i::Integer, D) where T -> Bool\nisparameterbound(::Type{T}, name::Symbol, D) where T -> Bool\nisparameterbound(::Type{}, ::Val{}, ::Any) -> Bool\n\nFor a type T, judge whether a type D should be considered as the upper bound of one of its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.isparameterbounds","page":"Toolkit","title":"QuantumLattices.Toolkit.isparameterbounds","text":"isparameterbounds(::Type{T}, ::Type{PS}) where {T, PS<:Tuple} -> Tuple{Vararg{Bool}}\nisparameterbounds(::Type{T}, ::Type{PS}) where {T, PS<:NamedTuple} -> Tuple{Vararg{Bool}}\n\nFor a type T, judge whether the types specified by PS should be considered as the upper bounds of its corresponding type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parametercount","page":"Toolkit","title":"QuantumLattices.Toolkit.parametercount","text":"parametercount(::Type{T}) where T -> Int\n\nFor a type T, get the number of its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parametername","page":"Toolkit","title":"QuantumLattices.Toolkit.parametername","text":"parametername(::Type{T}, i::Integer) where T -> Symbol\n\nFor a type T, get the name of its ith type parameter.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parameternames","page":"Toolkit","title":"QuantumLattices.Toolkit.parameternames","text":"parameternames(::Type{T}) where T -> Tuple{Vararg{Symbol}}\n\nFor a type T, get the names of all its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parameterorder","page":"Toolkit","title":"QuantumLattices.Toolkit.parameterorder","text":"parameterorder(::Type{T}, name::Symbol) where T -> Int\n\nFor a type T, get the order of one of its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parameterpair","page":"Toolkit","title":"QuantumLattices.Toolkit.parameterpair","text":"parameterpair(::Type{T}, name::Symbol) where T\nparameterpair(::Type{T}, i::Integer) where T\n\nFor type T, get the name-type pair of one of its type parameters.\n\nThe result is stored in the type parameters of a Pair.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parameterpairs","page":"Toolkit","title":"QuantumLattices.Toolkit.parameterpairs","text":"parameterpairs(::Type{T}) where T\n\nFor a type T, get the name-type pairs of all its type parameters.\n\nThe return types are stored in the type parameters of a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parametertype","page":"Toolkit","title":"QuantumLattices.Toolkit.parametertype","text":"parametertype(::Type{T}, name::Symbol) where T\nparametertype(::Type{T}, i::Integer) where T\n\nFor a type T, get the type of one of its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parametertypes","page":"Toolkit","title":"QuantumLattices.Toolkit.parametertypes","text":"parametertypes(::Type{T}) where T\n\nFor a type T, get the types of all its type parameters.\n\nThe returned types are stored in the type parameters of a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.promoteparameters","page":"Toolkit","title":"QuantumLattices.Toolkit.promoteparameters","text":"promoteparameters(::Type{T1}, ::Type{T2}) where {T1<:NamedTuple, T2<:NamedTuple}\n\nPromote the types specified by two named tuples with the same names accordingly.\n\nThe result is stored in the type parameters of a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.reparameter","page":"Toolkit","title":"QuantumLattices.Toolkit.reparameter","text":"reparameter(::Type{T}, i::Integer, P, ub::Bool=isparameterbound(T, i, P)) where T\nreparameter(::Type{T}, name::Symbol, P, ub::Bool=isparameterbound(T, name, P)) where T\n\nFor a type T, replace the type of its ith type parameter with P. Here, ub determines whether P should be considered as the upper bound. \n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For traits with type contents:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"contentcount\ncontentname\ncontentnames\ncontentorder\ncontenttype\ncontenttypes\ngetcontent\nhascontent\ndissolve","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contentcount","page":"Toolkit","title":"QuantumLattices.Toolkit.contentcount","text":"contentcount(::Type{T}) where T -> Int\n\nFor a type T, get the number of its predefined contents.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contentname","page":"Toolkit","title":"QuantumLattices.Toolkit.contentname","text":"contentname(::Type{T}, i::Integer) where T -> Symbol\n\nFor a type T, get the name of its ith predefined content.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contentnames","page":"Toolkit","title":"QuantumLattices.Toolkit.contentnames","text":"contentnames(::Type{T}) where T -> Tuple{Vararg{Symbol}}\n\nFor a type T, define the names of its predefined contents.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contentorder","page":"Toolkit","title":"QuantumLattices.Toolkit.contentorder","text":"contentorder(::Type{T}, name::Symbol) where T -> Int\n\nFor a type T, get the position order of a predefined content by the name.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contenttype","page":"Toolkit","title":"QuantumLattices.Toolkit.contenttype","text":"contenttype(::Type{T}, name::Symbol) where T\ncontenttype(::Type{T}, ::Val{name}) where {T, name}\n\nFor a type T, get the type of a predefined content by the name.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contenttypes","page":"Toolkit","title":"QuantumLattices.Toolkit.contenttypes","text":"contenttypes(::Type{T}) where T\n\nFor a type T, get the types of its predefined contents.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.getcontent","page":"Toolkit","title":"QuantumLattices.Toolkit.getcontent","text":"getcontent(m, i::Integer)\ngetcontent(m, name::Symbol)\ngetcontent(m, ::Val{name}) where name\n\nGet the value of the predefined content of m. \n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.hascontent","page":"Toolkit","title":"QuantumLattices.Toolkit.hascontent","text":"hascontent(::Type{T}, name::Symbol) where T -> Bool\n\nFor a type T, judge whether it has a predefined content specified by name.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.dissolve","page":"Toolkit","title":"QuantumLattices.Toolkit.dissolve","text":"dissolve(m, f::Function=identity, args::Tuple=(), kwargs::NamedTuple=NamedTuple()) -> Tuple\n\nConvert m to a tuple by the function f applied elementally to its contents with the extra positional arguments (args) and keyword arguments (kwargs). \n\nThe underlying called interface is the dissolve function when f is applied to each content of m:\n\ndissolve(m, Val(name), f, args, kwargs)\n\nHere, name is the name of a content of m.\n\nBasically, the rule of how f operates on each field of m can be overridden by redefining the above dissolve function. !!!note    The default dissolve function ignores the operation of function f and just return the content value of m.\n\n\n\n\n\ndissolve(m, ::Val{name}, f::Function, args::Tuple, kwargs::NamedTuple) where name\n\nDissolve the content specified by name of m by the function f applied with the extra positional arguments (args) and keyword arguments (kwargs).\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For traits with type operations:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"efficientoperations","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.efficientoperations","page":"Toolkit","title":"QuantumLattices.Toolkit.efficientoperations","text":"efficientoperations\n\nIndicate that the efficient operations, i.e. \"==\"/\"isequal\", \"<\"/\"isless\" or \"replace\", will be used.\n\n\n\n\n\n","category":"constant"},{"location":"man/Toolkit/#Composite-structures","page":"Toolkit","title":"Composite structures","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"In principle, Julia is not an object-oriented programming language. For example, only abstract types can be inherited so that subtype cannot inherit fields from their parents. Therefore, Julia prefers composition over inheritance. However, to make a new concrete type behaves much alike another one, tedious repetitions of redefining the generic interfaces are usually not avoidable, especially for the basic types in Julia base. In this module, we implement three such composited types, CompositeTuple, CompositeVector and CompositeDict, for the sake of future usages. Besides, NamedContainer, as a wrapper of Julia NamedTuple, is also provided here so that the construction of a Julia NamedTuple can be more flexible over the standard (name=value, ... ) syntax.","category":"page"},{"location":"man/Toolkit/#CompositeTuple-and-CompositeNTuple","page":"Toolkit","title":"CompositeTuple and CompositeNTuple","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A composite tuple (ntuple) can be considered as a tuple (ntuple) that is implemented by including an ordinary Tuple(NTuple) as its data attribute.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To take full advantages of the Julia base, the following interfaces are defined:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"inquiry of info: length, eltype, hash\ncomparison between objects: ==, isequal\nobtainment of old elements: getindex\niteration: iterate, keys, values, pairs\nconstruction of new objects: reverse","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Note that arithmetic operations and logical operations excluding == and isequal are not supported. Besides, a composite tuple is not a tuple since Julia has no abstract tuples.","category":"page"},{"location":"man/Toolkit/#CompositeVector","page":"Toolkit","title":"CompositeVector","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A composite vector can be considered as a vector that is implemented by including a concrete subtype of AbstractVector as its data attribute, and it itself is a subtype of AbstractVector.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To take full advantages of the Julia base, the following interfaces are redefined:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"inquiry of info: size, length\ncomparison between objects: ==, isequal\nobtainment of old elements: getindex\noperation of old elements: setindex!\naddition of new elements: push!, pushfirst!, insert!, append!, prepend!\nremoval of old elements: splice!, deleteat!, pop!, popfirst!, empty!\nconstruction of new objects: empty, reverse, similar\niteration: iterate, keys, values, pairs","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Note that arithmetic operations and logical operations excluding == and isequal are not supported.","category":"page"},{"location":"man/Toolkit/#CompositeDict","page":"Toolkit","title":"CompositeDict","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A composite dict can be considered as a dict that is implemented by including a concrete subtype of AbstractDict as its data attribute and it itself is a subtype of AbstractDict.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To take full advantages of the Julia base, the following interfaces are redefined:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"inquiry of info: isempty, length, haskey, in\ncomparison between objects: ==, isequal\nobtainment of old elements: get, getkey, getindex\noperation and addition of elements: push!, get!, setindex!\nremoval of old elements: pop!, delete!, empty!\nconstruction of new objects: merge, empty\niteration: iterate, keys, values, pairs","category":"page"},{"location":"man/Toolkit/#NamedContainer","page":"Toolkit","title":"NamedContainer","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"NamedContainer is just a wrapper (type alias) of Julia NamedTuple, but not a composite type.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Julia NamedTuple is useful to keep type stability of codes when we deal with inhomogeneous immutable dict-like objects, but its default constructor is not so convenient because the names and contents must be assigned pair by pair in a pair of parentheses explicitly. Therefore, we define a type alias of NamedTuple under the name of NamedContainer, so that we can construct a NamedTuple by the usual-formed constructor NamedContainer, e.g.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"NamedContainer{(:a, :b)}((1, 2))","category":"page"},{"location":"man/Toolkit/#Manual-3","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"CompositeDict\nCompositeNTuple\nCompositeTuple\nCompositeVector\nNamedContainer","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.CompositeDict","page":"Toolkit","title":"QuantumLattices.Toolkit.CompositeDict","text":"CompositeDict{K, V}\n\nA composite dict can be considered as a dict that is implemented by including a concrete subtype of AbstractDict as its data attribute.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.CompositeNTuple","page":"Toolkit","title":"QuantumLattices.Toolkit.CompositeNTuple","text":"CompositeNTuple{N, T}\n\nA composite ntuple can be considered as a ntuple that is implemented by including an ordinary NTuple as its data attribute.\n\nAlias for CompositeTuple{NTuple{N, T}}.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.CompositeTuple","page":"Toolkit","title":"QuantumLattices.Toolkit.CompositeTuple","text":"CompositeTuple{T<:Tuple}\n\nA composite tuple can be considered as a tuple that is implemented by including an ordinary Tuple as its data attribute.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.CompositeVector","page":"Toolkit","title":"QuantumLattices.Toolkit.CompositeVector","text":"CompositeVector{T}\n\nA composite vector can be considered as a vector that is implemented by including a concrete subtype of AbstractVector as its data attribute.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.NamedContainer","page":"Toolkit","title":"QuantumLattices.Toolkit.NamedContainer","text":"NamedContainer{T, Names} = NamedTuple{Names, <:Tuple{Vararg{T}}}\n\nNamedContainer is just a wrapper of Julia NamedTuple, but not a composite type.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Named-vectors","page":"Toolkit","title":"Named vectors","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A named vector is similar to a named tuple, which associate each of its values with a name. Although the names of a named vector cannot be changed, the values can be modified if needed. In contrast to the predefined NamedTuple in Julia, which employs the names as type parameters, we just implement a named vector as a composite struct equipped with the getindex and setindex! functions, with the fieldnames being its names. This simple implementation makes it possible to define your own concrete named vector with any of your preferred type names, and ensures that all instances of a certain concrete named vector share the same names. Therefore, if you are familiar with Python, you will find that our named vector is more qualified to be the counterpart of the namedtuple in Python than the default Julia implementation. Last but not least important, it is also worth noted that a named vector is not a vector, as is similar to that a named tuple is not a tuple in Julia. This results from our basic expectation that a named vector should be more like a tuple other than a vector so that not all operations valid to vectors are also valid to named vectors.","category":"page"},{"location":"man/Toolkit/#NamedVector","page":"Toolkit","title":"NamedVector","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"NamedVector defines the abstract type for all concrete named vectors.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Main features include:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Values can be accessed or modified either by the . operator or by the [] operator.\nComparisons, such as ≡, ≢, ==, ≠, >, <, ≥, ≤ are supported. Therefore a vector of named vectors can be sorted by the default sort function.\nHash is supported by hash. Therefore, a named vector can be used as the key of a dict or set.\nIteration over its fieldnames is supported by keys, over its values is supported by values, over its field-value pairs is supported by pairs.\nA reverse iteration is also supported.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To subtype it, please note:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A concrete type can be either mutable or immutable as you need, which is different from tuples.\nThe fields of a concrete type can be of the same type or not. For the former, we denote the named vector as \"homogeneous\" while for the latter as \"inhomogeneous\". For homogeneous ones, we define a sub abstract type, HomoNamedVector for further optimization of the default methods. See HomoNamedVector below.\nFor all concrete subtypes, if inner constructors are defined, the one which has the same interface with the default one must be implemented. Otherwise, some functionalities will not work.\nArithmetic operations, such as +, -, *, /, %, ÷, etc. are not supported. However, the function map is implemented, which can help users do the overloading of these operations.","category":"page"},{"location":"man/Toolkit/#HomoNamedVector","page":"Toolkit","title":"HomoNamedVector","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"HomoNamedVector is the subtype of NamedVector that of all its fields share the same type. Compared to NamedVector, one more default method is implemented with HomoNamedVector, i.e. eltype, which returns the type of its fields. This function ensures the type stability of all the methods that involves an iteration of the field values of a named vector. Therefore, homogeneous named vector are usually more efficient than inhomogeneous ones. Use homogeneous ones as much as possible unless the code efficiency does not matter.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To subtype HomoNamedVector, all the suggestions mentioned in the previous subsection for NamedVector also applies. A recommended template for a subtype is","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"[mutable] struct YourNamedVector{T} <: HomoNamedVector{T}\n    filed1::T\n    filed2::T\n    ...\nend","category":"page"},{"location":"man/Toolkit/#Manual-4","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"HomoNamedVector\nNamedVector","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.HomoNamedVector","page":"Toolkit","title":"QuantumLattices.Toolkit.HomoNamedVector","text":"HomoNamedVector{T}\n\nAbstract type for all homogeneous named vectors.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.NamedVector","page":"Toolkit","title":"QuantumLattices.Toolkit.NamedVector","text":"NamedVector\n\nAbstract type for all named vectors.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Vector-spaces","page":"Toolkit","title":"Vector spaces","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A vector space is a linear space, in which the addition of vectors and multiplication of a vector by a scalar are defined.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Vector spaces are frequently encountered in physics, e.g. the Hilbert space in quantum mechanics. In this submodule, we only implement those with finite dimensions. We want to remark that in our implementation, a vector space is a subtype of an abstract vector, therefore, the bases always possess a order, which means, two vector spaces are not considered to be equal to each other even if their corresponding actual mathematical spaces are the same but the orders of the bases are different.","category":"page"},{"location":"man/Toolkit/#VectorSpace","page":"Toolkit","title":"VectorSpace","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"VectorSpace{B} is the abstraction of a vector space, which has only one type parameter:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"B<:Any: the type of the bases of the vector space","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Basically, a subtype should implement the following 3 methods:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Base.length(vs::VectorSpace) -> Int\nGet the dimension of a vector space\nBase.getindex(vs::VectorSpace{B}, i::Int)  where B -> B\nGet the ith basis of a vector space\nBase.searchsortedfirst(vs::VectorSpace{B}, basis::B) where B -> Int\nSearch the index of a basis in a vector space","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Other features include","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"comparison: == and isequal\niteration: iterate\ninquiry: size, findfirst and in","category":"page"},{"location":"man/Toolkit/#Manual-5","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Predefined types of vector spaces:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"VectorSpace\nNamedVectorSpace\nSimpleNamedVectorSpace\nParameterSpace\nDirectProductedNamedVectorSpace\nZippedNamedVectorSpace","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpace","text":"VectorSpace{B} <: AbstractVector{B}\n\nAbstract vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.NamedVectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.NamedVectorSpace","text":"NamedVectorSpace{B} <: VectorSpace{B}\n\nAbstract named vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.SimpleNamedVectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.SimpleNamedVectorSpace","text":"SimpleNamedVectorSpace{N, B} <: NamedVectorSpace{B}\n\nAbstract simple named vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.ParameterSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.ParameterSpace","text":"ParameterSpace{N, T, B} <: SimpleNamedVectorSpace{N, B}\n\nParameter space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.DirectProductedNamedVectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.DirectProductedNamedVectorSpace","text":"DirectProductedNamedVectorSpace{T<:Tuple{Vararg{SimpleNamedVectorSpace}}, B<:Tuple} <: CompositeNamedVectorSpace{T, B}\n\nDirect producted named vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.ZippedNamedVectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.ZippedNamedVectorSpace","text":"ZippedNamedVectorSpace{T<:Tuple{Vararg{SimpleNamedVectorSpace}}, B<:Tuple} <: CompositeNamedVectorSpace{T, B}\n\nZipped named vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Predefined types of vector space style:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"VectorSpaceStyle\nVectorSpaceEnumerative\nVectorSpaceCartesian\nVectorSpaceDirectProducted\nVectorSpaceDirectSummed\nVectorSpaceZipped","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceStyle","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceStyle","text":"VectorSpaceStyle\n\nThe style of a concrete type of vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceEnumerative","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceEnumerative","text":"VectorSpaceEnumerative <: VectorSpaceStyle\n\nEnumerative vector space style, which indicates that the vector space has a predefined content named contents that contains all its bases.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceCartesian","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceCartesian","text":"VectorSpaceCartesian <: VectorSpaceStyle\n\nCartesian vector space style, which indicates that every basis in it could be represented by a Cartesian index.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceDirectProducted","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceDirectProducted","text":"VectorSpaceDirectProducted <: VectorSpaceStyle\n\nVector space style which indicates that a vector space is the direct product of its sub-components.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceDirectSummed","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceDirectSummed","text":"VectorSpaceDirectSummed <: VectorSpaceStyle\n\nVector space style which indicates that a vector space is the direct sum of its sub-components.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceZipped","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceZipped","text":"VectorSpaceZipped <: VectorSpaceStyle\n\nVector space style which indicates that a vector space is the zip of its sub-components.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Simple-trees","page":"Toolkit","title":"Simple trees","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The aim of this set of functions and types is to represent the standard tree structure in efficiency-non-sensitive cases. Please note that the default implementation of tree methods are far from optimal in efficiency. Therefore, please DO NOT use it if you need an efficient tree for addition, deletion, sort and inquiry. This module of codes apply only when the structure of tree matters but not the efficiency.","category":"page"},{"location":"man/Toolkit/#AbstractSimpleTree","page":"Toolkit","title":"AbstractSimpleTree","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"AbstractSimpleTree{N, D} is the abstract type for all concrete trees. By design, it has two type parameters:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"N: the type of the tree's node\nD: the type of the tree's data","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To fully utilize the methods designed for a tree structure, in our protocol, a concrete subtype must implement the following methods:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"inquiry related methods\nroot(tree::AbstractSimpleTree{N}) where N -> Union{N, Nothing}\nGet a tree's root node (nothing for empty trees)\nhaskey(tree::AbstractSimpleTree{N}, node::N) where N -> Bool\nCheck whether a node is in a tree.\nlength(tree::AbstractSimpleTree) -> Int\nGet the number of a tree's nodes.\nparent(tree::AbstractSimpleTree{N},\n       node::N,\n       superparent::Union{N, Nothing}=nothing\n       ) where N -> Union{N, Nothing}\nGet the parent of a tree's node or return superparent when the input node is the tree's root.\nchildren(tree::AbstractSimpleTree{N}, node::N) where N -> Vector{N}\nGet the children of a tree's node.\nstructure modification related methods\naddnode!(tree::AbstractSimpleTree{N},\n         parent::Union{N, Nothing},\n         node::N\n         ) where N -> typeof(tree)\nUpdate the structure of a tree by adding a node. When the parent is nothing, the input tree must be empty and the input node becomes the tree's root.\ndeletenode!(tree::AbstractSimpleTree{N}, node::N) where N -> typeof(tree)\nUpdate the structure of a tree by deleting a node.\nindex related methods\ngetindex(tree::AbstractSimpleTree{N, D}, node::N) where {N, D} -> D\nGet the data of a tree's node\nsetindex!(tree::AbstractSimpleTree{N, D}, node::N, data::D) where {N, D}\nSet the data of a tree's node.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Based on these methods, we implement several generic functions for inquiries and manipulations","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"inquiry for type parameters: keytype, valtype, eltype\nexpansion over nodes/data-records: keys, values, pairs\ninquiry for info of nodes: isleaf, level\ninquiry for nodes: ancestor, descendants, siblings, leaves\nmodification: push!, append!, delete!, empty!","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"And optionally, when a subtype implement the following method,","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"empty(tree::AbstractSimpleTree) -> typeof(tree)","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"which constructs an empty tree of the same type with the input one, two more methods are supported:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"subtree: Get a subtree starting from a node.\nmove!: Move a subtree to a new position.","category":"page"},{"location":"man/Toolkit/#SimpleTreeCore-and-SimpleTree","page":"Toolkit","title":"SimpleTreeCore and SimpleTree","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To implement all the prerequisites listed above costs a bit efforts. We provide two lazy ways to get over this:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Inheritance AbstractSimpleTree with TREECORE::SimpleTreeCore as one of its attribute\nInclusion an attribute which is an instance of SimpleTree","category":"page"},{"location":"man/Toolkit/#SimpleTreeCore","page":"Toolkit","title":"SimpleTreeCore","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"SimpleTreeCore{N, D}, as the literal meaning indicates, is the core of a tree. It encapsulates all the data structures needed by the default implementation, which contains 4 attributes:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"root::N: the tree's root node\ncontents::Dict{N, D}: the tree's (node, data) pairs\nparent::Dict{N, N}: records of the parent of each of the tree's nodes\nchildren::Dict{N, Vector{N}}: records of the children of each of the tree's nodes","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"As above, the first lazy way is to include this struct with the special name TREECORE in your concrete subtype as one of its attribute.","category":"page"},{"location":"man/Toolkit/#SimpleTree","page":"Toolkit","title":"SimpleTree","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"SimpleTree{N, D} is the minimum struct that implements all the default tree methods. You can include an instance of it as an attribute in your own type to utilize all the tree methods.","category":"page"},{"location":"man/Toolkit/#Manual-6","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"simpletreedepth\nsimpletreewidth\nAbstractSimpleTree\nSimpleTree\nSimpleTreeCore\naddnode!\nancestor\nchildren\ndeletenode!\ndescendants\nisleaf\nleaves\nlevel\nmove!\nroot\nsiblings\nsubtree","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.simpletreedepth","page":"Toolkit","title":"QuantumLattices.Toolkit.simpletreedepth","text":"simpletreedepth\n\nIndicate that the iteration over a tree is depth-first.\n\n\n\n\n\n","category":"constant"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.simpletreewidth","page":"Toolkit","title":"QuantumLattices.Toolkit.simpletreewidth","text":"simpletreewidth\n\nIndicate that the iteration over a tree is width-first.\n\n\n\n\n\n","category":"constant"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.AbstractSimpleTree","page":"Toolkit","title":"QuantumLattices.Toolkit.AbstractSimpleTree","text":"AbstractSimpleTree{Node, Data}\n\nAbstract type for all concrete trees.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.SimpleTree","page":"Toolkit","title":"QuantumLattices.Toolkit.SimpleTree","text":"SimpleTree{N, D} <: AbstractSimpleTree{N, D}\n\nThe minimum tree structure that implements all the default tree methods.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.SimpleTreeCore","page":"Toolkit","title":"QuantumLattices.Toolkit.SimpleTreeCore","text":"SimpleTreeCore()\n\nThe core of a simple tree.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.addnode!","page":"Toolkit","title":"QuantumLattices.Toolkit.addnode!","text":"addnode!(tree::AbstractSimpleTree{N}, node::N) where N} -> typeof(tree)\naddnode!(tree::AbstractSimpleTree{N}, ::Nothing, node::N) where N -> typeof(tree)\naddnode!(tree::AbstractSimpleTree{N}, parent::N, node::N) where N -> typeof(tree)\n\nUpdate the structure of a tree by adding a node. When the parent is nothing, the input tree must be empty and the input node becomes the tree's root.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.ancestor","page":"Toolkit","title":"QuantumLattices.Toolkit.ancestor","text":"ancestor(tree::AbstractSimpleTree{N}, node::N, generation::Int=1) where N -> N\n\nGet the ancestor of a tree's node of the n-th generation.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.children","page":"Toolkit","title":"QuantumLattices.Toolkit.children","text":"children(tree::AbstractSimpleTree) -> Vector{keytype(tree)}\nchildren(tree::AbstractSimpleTree, ::Nothing) -> Vector{keytype(tree)}\nchildren(tree::AbstractSimpleTree{N}, node::N) where N -> Vector{N}\n\nGet the children of a tree's node.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.deletenode!","page":"Toolkit","title":"QuantumLattices.Toolkit.deletenode!","text":"deletenode!(tree::AbstractSimpleTree{N}, node::N) where N -> typeof(tree)\n\nUpdate the structure of a tree by deleting a node.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.descendants","page":"Toolkit","title":"QuantumLattices.Toolkit.descendants","text":"descendants(tree::AbstractSimpleTree{N}, node::N, generation::Int=1) where N -> Vector{N}\n\nGet the descendants of a tree's node of the nth generation.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.isleaf","page":"Toolkit","title":"QuantumLattices.Toolkit.isleaf","text":"isleaf(tree::AbstractSimpleTree{N}, node::N) where N -> Bool\n\nJudge whether a tree's node is a leaf (a node without children) or not.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.leaves","page":"Toolkit","title":"QuantumLattices.Toolkit.leaves","text":"leaves(tree::AbstractSimpleTree) -> Vector{keytype(tree)}\n\nGet a tree's leaves.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.level","page":"Toolkit","title":"QuantumLattices.Toolkit.level","text":"level(tree::AbstractSimpleTree{N}, node::N) where N -> Int\n\nGet the level of tree's node.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.move!","page":"Toolkit","title":"QuantumLattices.Toolkit.move!","text":"move!(tree::AbstractSimpleTree{N}, node::N, parent::N) where N -> typeof(tree)\n\nMove a subtree to a new position.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.root","page":"Toolkit","title":"QuantumLattices.Toolkit.root","text":"root(tree::AbstractSimpleTree) -> Union{keytype(tree), Nothing}\n\nGet a tree's root node.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.siblings","page":"Toolkit","title":"QuantumLattices.Toolkit.siblings","text":"siblings(tree::AbstractSimpleTree{N}, node::N) where N -> Vector{N}\n\nGet the siblings (other nodes sharing the same parent) of a tree's node.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.subtree","page":"Toolkit","title":"QuantumLattices.Toolkit.subtree","text":"subtree(tree::AbstractSimpleTree{N}, node::N) where N -> typeof(tree)\n\nGet a subtree whose root is node.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"CurrentModule = QuantumLattices.QuantumNumbers","category":"page"},{"location":"man/QuantumNumbers/#Quantum-numbers","page":"Quantum numbers","title":"Quantum numbers","text":"","category":"section"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Quantum numbers can be considered as the conserved labels for the bases of a Hilbert space when a quantum system hosts some symmetries. Here we only implement Abelian quantum numbers because non-Abelian ones are far more complicated yet much less used. In practice, quantum numbers can be integers or half integers, therefore, we use real numbers to denote them in this module for simplicity. Independent quantum numbers, such as the particle number and the spin z-component, can coexist at the same time. We use type AbelianNumber to represent the complete set of independent ones for a single basis of a Hilbert space, and type AbelianNumbers to represent the whole quantum numbers for the total bases.","category":"page"},{"location":"man/QuantumNumbers/#AbelianNumber","page":"Quantum numbers","title":"AbelianNumber","text":"","category":"section"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"The abstract type for the complete set of independent quantum numbers for a single basis.","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Main features include:","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"function periods: get the periods of the quantum numbers\narithmetic operations: +, -, *, ^, ⊕, ⊗\nhashable: concrete instances can be used as keys for a dict or a set\niterable: concrete instances are iterable over their values\ncomparable: two concrete instances can be compared","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"In particular, AbelianNumber <: HomoNamedVector{Float}, all features supported by HomoNamedVector are also available for HomoNamedVector. See also HomoNamedVector.","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"For convenience, 3 kinds of quantum numbers are predefined in this module, i.e.","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"SpinZ: for spin z-component reserved systems\nParticleNumber: for particle number reserved systems\nSpinfulParticle: for both particle number and spin-z component reserved systems","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Users who want to define their own Z_N-like quantum numbers must handle the periodicity in the construction function, otherwise, wrong results will be get when arithmetic operations, such as + or -, are involved. It is recommended to use the macro @abeliannumber to define your own concrete AbelianNumbers.","category":"page"},{"location":"man/QuantumNumbers/#AbelianNumbers","page":"Quantum numbers","title":"AbelianNumbers","text":"","category":"section"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"The whole quantum numbers for the total bases.","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"By design, a AbelianNumbers{QN} has one type parameter:","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"QN<:AbelianNumber: the type of the quantum numbers contained in it","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"And 3 attributes:","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"form::Char: Its form, whose value must be one of the followings\n'G': the general form, which has no restriction for its contents\n'U': the unitary form, which requires no duplicates in its contents\n'C': the canonical form, which requires both no duplicates and ascending-order in its contents\nUsually, G-formed and U-formed AbelianNumberses can be transformed to the corresponding C-formed ones by the sort function.\ncontents::Vector{QN}: The quantum numbers contained in it. To achieve high efficiency, it is required to be an homogenous array of a certain kind of concrete AbelianNumber.\nindptr::Vector{Int}: The indptr of the quantum numbers contained in it, which is similar to the colptr attribute of a CSC sparse matrix and records the compression info of its contents.","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Main features include:","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"function eltype: get the concrete type of the quantum numbers it contains\nindex access: get the contents directly by the getindex function\narithmetic operations: +, -, *, ^, ⊗, ⊕\niterable: various iteration supports, including functions such as iterate, keys, values and pairs","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"For a complete summation of its features, please refer to the manual.","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"For convenience, 3 functions are predefined to generate the AbelianNumbers of common physical systems, i.e.","category":"page"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"spinzs: a single spin\nparticlenumbers: a single-particle state with at most N identical particles\nspinfulparticles: a single site with internal degrees of freedom that can be ascribed to a spin","category":"page"},{"location":"man/QuantumNumbers/#qnmanual","page":"Quantum numbers","title":"Manual","text":"","category":"section"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Modules = [QuantumNumbers]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/QuantumNumbers/#OrderedCollections.OrderedDict-Tuple{AbelianNumbers, Symbol}","page":"Quantum numbers","title":"OrderedCollections.OrderedDict","text":"OrderedDict(qns::AbelianNumbers, choice::Symbol) -> OrderedDict\nOrderedDict(qns::AbelianNumbers, ::Val{:indptr}) -> OrderedDict{qns|>eltype, UnitRange{Int}}\nOrderedDict(qns::AbelianNumbers, ::Val{:counts}) -> OrderedDict{qns|>eltype, Int}\n\nConvert an AbelianNumbers to an ordered dict.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianNumber","text":"AbelianNumber{T<:Real} <: HomoNamedVector{T}\n\nAbstract type for all concrete quantum numbers for a single basis.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianNumbers","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(qn::AbelianNumber, count::Int=1)\n\nConstruct an AbelianNumbers with one unique quantum number which occurs count times.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianNumbers-2","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers{QN<:AbelianNumber} <: VectorSpace{QN}\n\nThe whole quantum numbers of the total bases of a Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianNumbers-Tuple{Char, Vector{<:AbelianNumber}, Vector{Int64}, Symbol}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(form::Char, contents::Vector{<:AbelianNumber}, indptr::Vector{Int}, choice::Symbol)\nAbelianNumbers(form::Char, contents::Vector{<:AbelianNumber}, counts::Vector{Int}, ::Val{:counts})\nAbelianNumbers(form::Char, contents::Vector{<:AbelianNumber}, indptr::Vector{Int}, ::Val{:indptr})\n\nConstruct an AbelianNumbers from a vector of concrete quantum numbers and an vector containing their counts or indptr.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianNumbers-Tuple{Char, Vector{<:AbelianNumber}}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(form::Char, contents::Vector{<:AbelianNumber})\n\nConstruct an AbelianNumbers with a set of quantum numbers whose counts are all one.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{<:AbelianNumber, <:Integer}}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(od::OrderedDict{<:AbelianNumber, <:Integer})\n\nConstruct an AbelianNumbers from an ordered dict containing concrete quantum numbers and their counts.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{<:AbelianNumber, <:UnitRange{<:Integer}}}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(od::OrderedDict{<:AbelianNumber, <:UnitRange{<:Integer}})\n\nConstruct an AbelianNumbers from an ordered dict containing concrete quantum numbers and their slices.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.Momenta","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.Momenta","text":"Momenta{P<:Momentum} <: VectorSpace{P}\n\nThe allowed set of momenta.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.Momentum","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.Momentum","text":"Momentum <: AbelianNumber{Int}\n\nAbstract type for momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.Momentum₁","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.Momentum₁","text":"Momentum₁{N}(k::Integer) where N\n\nOne dimensional momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.Momentum₂","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.Momentum₂","text":"Momentum₂{N}(k₁::Integer, k₂::Integer) where N\nMomentum₂{N₁, N₂}(k₁::Integer, k₂::Integer) where {N₁, N₂}\n\nTwo dimensional momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.Momentum₃","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.Momentum₃","text":"Momentum₃{N}(k₁::Integer, k₂::Integer, k₃::Integer) where N\nMomentum₃{N₁, N₂, N₃}(k₁::Integer, k₂::Integer, k₃::Integer) where {N₁, N₂, N₃}\n\nThree dimensional momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.ParticleNumber","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.ParticleNumber","text":"ParticleNumber(N::Real)\n\nThe concrete AbelianNumber of a quantum system with particle number N conserved.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.SpinZ","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.SpinZ","text":"SpinZ(Sz::Real)\n\nThe concrete AbelianNumber of a quantum system with spin z-component Sz conserved.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.SpinfulParticle","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.SpinfulParticle","text":"SpinfulParticle(N::Real, Sz::Real)\n\nThe concrete AbelianNumber of a quantum system with both particle number N and spin z-component Sz conserved.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.@abeliannumber-NTuple{4, Any}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.@abeliannumber","text":"@abeliannumber typename T fields periods\n\nConstruct a concrete AbelianNumber with the type name being typename, fieldtype specified by T, fieldnames specified by fields, and periods specified by periods.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumNumbers/#Base.:*-Tuple{Integer, AbelianNumbers}","page":"Quantum numbers","title":"Base.:*","text":"*(factor::Integer, qns::AbelianNumbers) -> AbelianNumbers\n*(qns::AbelianNumbers, factor::Integer) -> AbelianNumbers\n\nOverloaded * operator for the multiplication between an integer and an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:*-Tuple{Integer, AbelianNumber}","page":"Quantum numbers","title":"Base.:*","text":"*(factor::Integer, qn::AbelianNumber) -> typeof(qn)\n*(qn::AbelianNumber, factor::Integer) -> typeof(qn)\n\nOverloaded * operator for the multiplication between an integer and an AbelianNumber.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:+-Tuple{AbelianNumbers}","page":"Quantum numbers","title":"Base.:+","text":"+(qns::AbelianNumbers) -> AbelianNumbers\n+(qn::QN, qns::AbelianNumbers{QN}) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n+(qns::AbelianNumbers{QN}, qn::QN) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nOverloaded + operator for AbelianNumber/AbelianNumbers.\n\nnote: Note\nThe addition between an AbelianNumbers and an AbelianNumber is just a global shift of the contents of the AbelianNumbers by the AbelianNumber, therefore, the result is an AbelianNumbers.\n+ cannot be used between two AbelianNumbers because the result is ambiguous. Instead, use ⊕ for direct sum and ⊗ for direct product.\nTo ensure type stability, an AbelianNumber and an AbelianNumbers can be added together if and only if the former's type is the same with the latter's eltype.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:+-Tuple{AbelianNumber}","page":"Quantum numbers","title":"Base.:+","text":"+(qn::AbelianNumber) -> typeof(qn)\n+(qn::QN, qns::QN...) where {QN<:AbelianNumber} -> QN\n\nOverloaded + operator for AbelianNumber.\n\nnote: Note\nTo ensure type stability, two AbelianNumber can be added together if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:--Tuple{AbelianNumbers}","page":"Quantum numbers","title":"Base.:-","text":"-(qns::AbelianNumbers) -> AbelianNumbers\n-(qn::QN, qns::AbelianNumbers{QN}) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n-(qns::AbelianNumbers{QN}, qn::QN) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nOverloaded - operator for AbelianNumber/AbelianNumbers.\n\nnote: Note\nThe subtraction between an AbelianNumbers and an AbelianNumber is just a global shift of the contents of the AbelianNumbers by the AbelianNumber, therefore, the result is an AbelianNumbers.\n- cannot be used between two AbelianNumbers because the result is ambiguous. Instead, use ⊕ with signs for direct sum and ⊗ with signs for direct product.\nTo ensure type stability, an AbelianNumber can be subtracted by an AbelianNumbers or vice versa if and only if the former's type is the same with the latter's eltype.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:--Tuple{AbelianNumber}","page":"Quantum numbers","title":"Base.:-","text":"-(qn::AbelianNumber) -> typeof(qn)\n-(qn₁::QN, qn₂::QN) where {QN<:AbelianNumber} -> QN\n\nOverloaded - operator for AbelianNumber.\n\nnote: Note\nTo ensure type stability, an AbelianNumber can be subtracted by another AbelianNumber if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:^-Tuple{AbelianNumber, Integer}","page":"Quantum numbers","title":"Base.:^","text":"^(qn::AbelianNumber, factor::Integer) -> typeof(qn)\n\nOverloaded ^ operator for AbelianNumber.\n\nThis operation translates into the direct product of factor copies of qn.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:^-Tuple{AbelianNumbers, Integer}","page":"Quantum numbers","title":"Base.:^","text":"^(qns::AbelianNumbers, factor::Integer) -> AbelianNumbers\n\nOverloaded ^ operator for AbelianNumbers.\n\nThis operation translates into the direct product of factor copies of qns.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.filter-Union{Tuple{QN}, Tuple{QN, AbelianNumbers{QN}}} where QN<:AbelianNumber","page":"Quantum numbers","title":"Base.filter","text":"filter(target::QN, qns::AbelianNumbers{QN}) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\nfilter(targets::Tuple{Vararg{QN}}, qns::AbelianNumbers{QN}) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nFind a subset of an AbelianNumbers by picking out the target quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.findall-Union{Tuple{QN}, Tuple{Union{Tuple{Vararg{QN}}, QN}, AbelianNumbers{QN}, Symbol}} where QN<:AbelianNumber","page":"Quantum numbers","title":"Base.findall","text":"findall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, choice::Symbol) where {QN<:AbelianNumber} -> Vector{Int}\nfindall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, ::Val{:compression}) where {QN<:AbelianNumber} -> Vector{Int})\nfindall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, ::Val{:expansion}) where {QN<:AbelianNumber} -> Vector{Int}\n\nFind all the indices of the target quantum numbers in the contents or the expansion of an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.getindex-Tuple{AbelianNumbers, UnitRange{Int64}}","page":"Quantum numbers","title":"Base.getindex","text":"getindex(qns::AbelianNumbers, slice::UnitRange{Int}) -> AbelianNumbers\ngetindex(qns::AbelianNumbers, indices::Vector{Int}) -> AbelianNumbers\n\nOverloaded [] operator.\n\nnote: Note\nFor an AbelianNumbers, all the getindex functions act on its contents, i.e. its compressed data, but not on its expansion, i.e. the uncompressed data. This definition is consistent with the length of an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.keys-Tuple{AbelianNumbers}","page":"Quantum numbers","title":"Base.keys","text":"keys(qns::AbelianNumbers) -> Vector{qns|>eltype}\n\nIterate over the concrete AbelianNumbers contained in an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.kron-Tuple{Vararg{AbelianNumber}}","page":"Quantum numbers","title":"Base.kron","text":"kron(qns::Vararg{AbelianNumber}; signs=positives(qns))-> eltype(qns)\n\nGet the direct product of some AbelianNumbers.\n\nnote: Note\nPhysically, the direct product of a couple of AbelianNumbers are defined through the direct product of the bases of the Hilbert spaces they represent. Apparently, the result is still an AbelianNumber whose dimension is 1. At the same time, each component of the result is obtained by a summation of the corresponding components of the inputs with the correct signs. This is a direct consequence of the Abelian nature of our quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.kron-Union{Tuple{Vararg{AbelianNumbers{QN}}}, Tuple{QN}} where QN<:AbelianNumber","page":"Quantum numbers","title":"Base.kron","text":"kron(qnses::AbelianNumbers{QN}...; signs=positives(qnses)) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nGet the direct product of some AbelianNumberses.\n\nnote: Note\nPhysically, the direct product of a couple of AbelianNumberses are defined by the direct product of the bases of the Hilbert spaces they represent. Therefore, the dimension of the result equals the product of those of the inputs. Meanwhile, each quantum number in the contents of the result is obtained by a summation of the corresponding quantum numbers of the inputs with the correct signs. This is a direct consequence of the Abelian nature of our quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.pairs-Tuple{AbelianNumbers, Symbol}","page":"Quantum numbers","title":"Base.pairs","text":"pairs(qns::AbelianNumbers, choice::Symbol)\npairs(qns::AbelianNumbers, ::Val{:indptr})\npairs(qns::AbelianNumbers, ::Val{:counts})\n\nIterate over the AbelianNumber=>slice or AbelianNumber=>count pairs.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.prod-Union{Tuple{Vararg{AbelianNumbers{QN}}}, Tuple{QN}} where QN<:AbelianNumber","page":"Quantum numbers","title":"Base.prod","text":"prod(qnses::AbelianNumbers{QN}...; signs=positives(qnses)) where {QN<:AbelianNumber} -> AbelianNumbers{QN}, Dict{QN, Dict{NTuple{length(qnses), QN}, UnitRange{Int}}}\n\nUnitary Kronecker product of several AbelianNumberses. The product result as well as the records of the product will be returned.\n\nnote: Note\nAll input AbelianNumbers must be 'U' formed or 'C' formed.\nSince duplicate quantum number are not allowed in 'U' formed and 'C' formed AbelianNumberses, in general, there exists a merge process of duplicate quantum numbers in the result. Therefore, records are needed to keep track of this process, which will be returned along with the product result. The records are stored in a Dict{QN, Dict{NTuple{NTuple{length(qnses), QN}, UnitRange{Int}}} typed dict, in which, for each nonduplicate quantum number qn in the result, there exist a record Dict((qn₁, qn₂, ...)=>start:stop, ...) telling what quantum numbers (qn₁, qn₂, ...) a merged duplicate qn comes from and what slice start:stop this merged duplicate corresponds in the result.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.sort-Tuple{AbelianNumbers}","page":"Quantum numbers","title":"Base.sort","text":"sort(qns::AbelianNumbers) -> Tuple{AbelianNumbers, Vector{Int}}\n\nSort the quantum numbers of an AbelianNumbers, return the sorted AbelianNumbers and the permutation array that sorts the expansion of the original AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.union-Tuple{Vararg{AbelianNumber}}","page":"Quantum numbers","title":"Base.union","text":"union(qns::AbelianNumber...; signs=positives(qns)) -> AbelianNumbers\nunion(qnses::AbelianNumbers{QN}...; signs=positives(qnses)) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nGet the direct sum of some AbelianNumbers or AbelianNumberses.\n\nnote: Note\nPhysically, the direct sum of a couple of AbelianNumbers or AbelianNumberses is defined by the direct sum of the bases of the Hilbert spaces they represent. Therefore, the dimension of the result equals the summation of those of the inputs. As a consequence, even for AbelianNumbers, the result will be an AbelianNumbers because the dimension of the result is greater than 1.\nSigns of AbelianNumbers or AbelianNumberses can be provided when getting their direct sums.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.values-Tuple{AbelianNumbers, Symbol}","page":"Quantum numbers","title":"Base.values","text":"values(qns::AbelianNumbers, choice::Symbol)\nvalues(qns::AbelianNumbers, ::Val{:indptr})\nvalues(qns::AbelianNumbers, ::Val{:counts})\n\nIterate over the slices/counts of the AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.:⊕-Tuple{Vararg{AbelianNumber}}","page":"Quantum numbers","title":"QuantumLattices.:⊕","text":"⊕(qns::AbelianNumber...) -> AbelianNumbers{qns|>eltype}\n⊕(qnses::AbelianNumbers...) -> qnses|>eltype\n\nGet the direct sum of some AbelianNumbers or AbelianNumberses.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.:⊗-Tuple{Vararg{AbelianNumbers}}","page":"Quantum numbers","title":"QuantumLattices.:⊗","text":"⊗(qnses::AbelianNumbers...) -> eltype(qnses)\n\nGet the direct product of some AbelianNumberses.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.:⊗-Tuple{Vararg{AbelianNumber}}","page":"Quantum numbers","title":"QuantumLattices.:⊗","text":"⊗(qns::AbelianNumber...) -> eltype(qns)\n\nGet the direct product of some AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.particlenumbers-Tuple{Real}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.particlenumbers","text":"particlenumbers(N::Real) -> AbelianNumbers{ParticleNumber}\n\nConstruct the AbelianNumbers of the Hilbert space of a single-particle state with at most N identical particles.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.periods-Tuple{AbelianNumber}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.periods","text":"periods(qn::AbelianNumber)\n\nThe periods of the components of a concrete AbelianNumber.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.positives-Union{Tuple{Tuple{Vararg{Any, N}}}, Tuple{N}} where N","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.positives","text":"positives(inputs::NTuple{N, Any}) where N -> NTuple{N, Int}\n\nReturn a tuple of all positive signs.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.regularize!-Union{Tuple{QN}, Tuple{Type{QN}, AbstractVector{<:Real}}} where QN<:AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.regularize!","text":"regularize!(::Type{QN}, array::AbstractVector{<:Real}) where {QN<:AbelianNumber} -> typeof(array)\nregularize!(::Type{QN}, array::AbstractMatrix{<:Real}) where {QN<:AbelianNumber} -> typeof(array)\n\nRegularize the elements of an array in place so that it can represent quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.regularize-Union{Tuple{QN}, Tuple{Type{QN}, Union{AbstractVector{<:Real}, AbstractMatrix{<:Real}}}} where QN<:AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.regularize","text":"regularize(::Type{QN}, array::Union{AbstractVector{<:Real}, AbstractMatrix{<:Real}}) where {QN<:AbelianNumber} -> typeof(array)\n\nRegularize the elements of an array and return a copy that can represent quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.spinfulparticles-Tuple{Real}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.spinfulparticles","text":"spinfulparticles(S::Real) -> AbelianNumbers{SpinfulParticle}\n\nConstruct the AbelianNumbers of the Hilbert space of a single site with internal degrees of freedom that can be ascribed to a spin S.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.spinzs-Tuple{Real}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.spinzs","text":"spinzs(S::Real) -> AbelianNumbers{SpinZ}\n\nConstruct the AbelianNumbers of the Hilbert space of a single spin S.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.decompose-Union{Tuple{QN}, Tuple{QN, Vararg{AbelianNumbers{QN}}}} where QN<:AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.decompose","text":"decompose(target::QN, qnses::AbelianNumbers{QN}...; signs=positives(qnses), method=:montecarlo, nmax=20) where {QN<:AbelianNumber} -> Vector{NTuple{length(qnses), Int}}\n\nFind a couple of decompositions of target with respect to qnses.\n\nnote: Note\nA tuple of integers (i₁, i₂, ...) is called a decomposition of a given target with respect to the given qnses if and only if they satisfy the \"decomposition rule\":sum_textj textsignstextjtimestextqnsestextjtexti_textj==texttargetThis equation is in fact a set of restricted linear Diophantine equations. Indeed, our quantum numbers are always discrete Abelian ones and all instances of a concrete AbelianNumber forms a module over the ring of integers. Therefore, each quantum number can be represented as a integral multiple of the unit element of the Abelian module, which results in the final reduction of the above equation to a set of linear Diophantine equations. Then finding a decomposition is equivalent to find a solution of the reduced linear Diophantine equations, with the restriction that the quantum numbers constructed from the solution should be in the corresponding qnses. Here we provide two methods to find such decompositions, one is by brute force, and the other is by Monte Carlo simulations.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Tuple{Type{<:AbelianNumber}}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(::Type{<:AbelianNumber}) -> Int\ndimension(::AbelianNumber) -> Int\n\nThe dimension of the Hilbert space an AbelianNumber represents. Apparently, this is always 1.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.expand-Tuple{AbelianNumbers, Symbol}","page":"Quantum numbers","title":"QuantumLattices.expand","text":"expand(qns::AbelianNumbers, choice::Symbol)\nexpand(qns::AbelianNumbers, ::Val{:contents}) -> Vector{eltype(qns)}\nexpand(qns::AbelianNumbers, ::Val{:indices}) -> Vector{Int}\n\nExpand the contents or indices of an AbelianNumbers to the uncompressed form.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.permute-Tuple{AbelianNumbers, Vector{Int64}, Symbol}","page":"Quantum numbers","title":"QuantumLattices.permute","text":"permute(qns::AbelianNumbers, permutation::Vector{Int}, choice::Symbol) -> AbelianNumbers\npermute(qns::AbelianNumbers, permutation::Vector{Int}, ::Val{:compression}) -> AbelianNumbers\npermute(qns::AbelianNumbers, permutation::Vector{Int}, ::Val{:expansion}) -> AbelianNumbers\n\nReorder the quantum numbers contained in an AbelianNumbers with a permutation and return the new one.\n\nFor :compression case, the permutation is for the compressed contents of the original AbelianNumbers while for :expansion case, the permutation is for the expanded contents of the original AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\n    using SymPy: symbols\nend","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Couplings-among-different-degrees-of-freedom","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Now we arrive at the final step toward the complete description of a quantum lattice system, i.e., the terms that represent the couplings among different degrees of freedom.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Ingredients-of-terms-in-Hamiltonians","page":"Couplings among different degrees of freedom","title":"Ingredients of terms in Hamiltonians","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"In this package, the type Term is the representation of a term in lattice Hamiltonians.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As is well-known, different quantum lattice models have different terms. For example, the Hubbard model consist of an usual hopping term tsum_ijc^_ic_j + hc and a Hubbard term Usum_i c^_i c_i c^_ic_i while the transverse-field Ising model contains an Ising term Jsum_ijS^z_iS^z_j as well as a transverse-field term hsum_iS^x_i. Despite the rich diversity of the terms in quantum lattice models, they host common ingredients:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Overall coefficient: every term has an overall coefficient, e.g., the hopping amplitude t for the usual hopping term, the Hubbard interaction strength U for the Hubbard term, etc.\nKind of bonds to be summed over: as the natural result of lattice symmetry, every term contains a summation over some kind of generic bonds, e.g., the usual hopping term sums over the nearest-neighbor bonds ij, the Hubbard term sums over all individual points (namely the 1-point bonds), etc.\nCoupling pattern: in the body of the summation over bonds, every term contains a coupling pattern that can be represented by a certain combination of operators, e.g., the coupling pattern of the usual hopping term can be represented by c^_ic_j, of the Hubbard term can be represented by c^_i c_i c^_ic_i, etc.\nHermiticity: to guarantee the Hamiltonian to be Hermitian, the Hermitian conjugate (h.c.) of non-Hermitian terms must be added, e.g., the Hermitian conjugate of the usual hopping term must be added in the expression of the lattice Hamiltonian while that of the Hubbard term need not.\nBond-dependent amplitude (optional): the amplitude of a term can be dependent on the generic bonds, e.g., the staggered local chemical potential Δsum_i(-1)^ic^_ic_i depends on the site index of a point, the p+ip pairing potential Δsum_ije^iϕ_ijc^_ic^_j + hc depends on the azimuth angle ϕ_ij of the bond ij, etc.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Such common ingredients determine the underlying organization of Term. In fact, all of them manifest themselves in the basic construction function of Term shown as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Term{termkind}(\n    id::Symbol, value, bondkind, coupling, ishermitian::Bool;\n    amplitude::Union{Function, Nothing}=nothing\n) where termkind","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"where termkind must be a Symbol, value is the overall coefficient which should be a real number, coupling specifies the coupling pattern of the term which can accept an instance of Coupling, or an iterator of Couplings, or a function that returns a Coupling or an iterator of Couplings, and the keyword argument amplitude specifies the bond dependency of the amplitude if it is not nothing. Here, the new type Coupling is the building block of the coupling pattern, which will be discussed in detail in the following section. It is also noted that an extra id is also assigned with each term which can be used for fast lookup for later convenience.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Coupling-patterns","page":"Couplings among different degrees of freedom","title":"Coupling patterns","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Before the further discussion of Term, we at first turn to the coupling patterns, which lie at the center of the constructions of Terms.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Coupling:-building-block-of-coupling-patterns","page":"Couplings among different degrees of freedom","title":"Coupling: building block of coupling patterns","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Coupling uses a set of Indexes together with a coefficient to represent the coupling pattern, as the following construction function implies:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Coupling([value, ]indexes::Index...)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here, when value is omitted, it will be set to 1.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Let's see a typical example, which represents the coupling pattern of the usual hopping term tsum_ijc^_ic_j + hc:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(Index(1, FID(:, :, 2)), Index(2, FID(:, :, 1)))\n∑[Index(1, FID(:, :, 2)) Index(2, FID(:, :, 1))]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"There are several differences of the Indexes here compared to those introduced in the previous page of Internal degrees of freedom:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The site attributes are not the site indexes of the points in a lattice, instead, they are the ordinals of the points contained in a bond. In fact, in the expression of c^_ic_j, i is always the first site of a bond while j is always the second, thus, the site attributes here are 1 and 2 for the first Index and the second Index, respectively.\nThe iid attributes are initialized by special FID instances, which do not have the type parameter :f or :b to specify the statistics, and whose orbital and spin attributes are initialized by the : operator rather than integers. Without the statistics of :f or :b, FID could suit for both fermionic and bosonic quantum lattice systems, as the coupling pattern of an usual hopping term is the same for both kinds of systems. When the : operator is used in the initialization for either the orbital or the spin attribute, the default rule applies in the coupling pattern, that orbitals or spins are summed diagonally, i.e., c^_ic_jsum_ασc^_iασc_jασ. This rule is in fact a tradition in the literature of condensed matter physics. This implicit summation in the construction of a Coupling is made explicit in its string representation by the ∑ symbol, as can be seen in the above example.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Similarly, the total spin of SID can be omitted during the construction of the coupling patterns of spin terms, meaning that it suits any allowable value of total spins, e.g., the coupling pattern of the spin-flip term of any total spin Jsum_ijS^+_iS^-_j + hc is as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(1//2, Index(1, SID('+')), Index(2, SID('-')))\n1//2 Index(1, SID('+')) Index(2, SID('-'))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Note that in this coupling pattern, there is no summation symbol ∑ in the string representation because all indexes are definite. Therefore, the summation symbol ∑ in the string representation of a coupling pattern only reflects the summation over local internal degrees of freedom, but not the summation over bonds.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The diagonal summation rule also applies to the direction attribute of PID if initialized by the : operator, e.g., the the coupling pattern of the phonon kinetic term frac12Msum_i p^2_i can be constructed as:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(Index(1, PID('p', :)), Index(1, PID('p', :)))\n∑[Index(1, PID('p', :)) Index(1, PID('p', :))]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Of course, it also supports usual Indexes to initialize more specific coupling patterns, e.g., the coupling pattern of the orbital-1 spin-down hopping term of fermions tsum_ijc^_i 1 c_j 1  + hc is","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(Index(1, FID{:f}(1, 1//2, 2)), Index(2, FID{:f}(1, 1//2, 1)))\nIndex(1, FID{:f}(1, 1//2, 2)) Index(2, FID{:f}(1, 1//2, 1))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The Indexes can be of different types, which corresponds to a hybrid quantum lattice system that couples different categories of internal degrees of freedom:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(Index(1, FID{:f}(1, 1//2, 2)), Index(1, FID{:f}(1, 1//2, 1)), Index(1, SID('z')))\nIndex(1, FID{:f}(1, 1//2, 2)) Index(1, FID{:f}(1, 1//2, 1)) Index(1, SID('z'))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here, local spins are coupled to itinerant fermions. For more discussions on hybrid systems, please refer to the page of Hybrid systems.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"When all Indexes are of the same type, a Coupling can be initialized in different simpler ways:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# Coupling pattern for Fock systems\nCoupling(\n    [value, ]\n    sites::Union{Colon, NTuple{N, Int}},\n    ::Type{<:FID},\n    orbitals::Union{NTuple{N, Int}, Colon},\n    spins::Union{NTuple{N, Union{Rational{Int}, Int}}, Colon},\n    nambus::Union{NTuple{N, Int}, Colon}\n) where N\n\n# Coupling pattern for spin systems\nCoupling(\n    [value, ]\n    sites::Union{Colon, NTuple{N, Int}}, ::Type{<:SID},\n    tags::NTuple{N, Char}\n) where N\n\n# Coupling pattern for phonon systems\nCoupling(\n    [value, ]\n    sites::Union{Colon, NTuple{N, Int}},\n    ::Type{<:PID},\n    tags::NTuple{N, Char},\n    directions::Union{Colon, NTuple{N, Char}}\n) where N","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here, as is usual, when value is omitted, the coefficient of the Coupling will be set to be 1.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"See examples:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling((1, 1, 2, 2), FID, :, :, (2, 2, 1, 1))\n∑[Index(1, FID(:, :, 2)) Index(1, FID(:, :, 2)) Index(2, FID(:, :, 1)) Index(2, FID(:, :, 1))]\n\njulia> Coupling((1, 2), SID, ('z', 'z'))\nIndex(1, SID('z')) Index(2, SID('z'))\n\njulia> Coupling((1, 1), PID, ('p', 'p'), :)\n∑[Index(1, PID('p', :)) Index(1, PID('p', :))]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The coefficient and the indexes of a Coupling are stored in the value and indexes attributes, respectively:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> coupling = Coupling(1//2, Index(1, SID('+')), Index(2, SID('-')));\n\njulia> coupling.value\n1//2\n\njulia> coupling.indexes\n(Index(1, SID('+')), Index(2, SID('-')))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"A Coupling can be multiplied with a number:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> coupling = Coupling(1//2, Index(1, SID('+')), Index(2, SID('-')));\n\njulia> coupling * 3\n3//2 Index(1, SID('+')) Index(2, SID('-'))\n\njulia> 3 * coupling\n3//2 Index(1, SID('+')) Index(2, SID('-'))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Two Couplings can be multiplied together:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> cp₁ = Coupling((1, 1), FID, (:, :), (1//2, 1//2), (2, 1));\n\njulia> cp₂ = Coupling((1, 1), FID, (:, :), (-1//2, -1//2), (2, 1));\n\njulia> cp₁ * cp₂\n∑[Index(1, FID(:, 1//2, 2)) Index(1, FID(:, 1//2, 1))] ⋅ ∑[Index(1, FID(:, -1//2, 2)) Index(1, FID(:, -1//2, 1))]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"It is noted that due to the implicit summation of the orbital index in the coupling pattern, the above product is not equal to the coupling pattern of the Hubbard term Usum_i c^_i c_i c^_ic_i:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> cp₁ = Coupling((1, 1), FID, :, (1//2, 1//2), (2, 1));\n\njulia> cp₂ = Coupling((1, 1), FID, :, (-1//2, -1//2), (2, 1));\n\njulia> cp = Coupling((1, 1, 1, 1), FID, :, (1//2, 1//2, -1//2, -1//2), (2, 1, 2, 1)) # Hubbard coupling pattern\n∑[Index(1, FID(:, 1//2, 2)) Index(1, FID(:, 1//2, 1)) Index(1, FID(:, -1//2, 2)) Index(1, FID(:, -1//2, 1))]\n\njulia> cp == cp₁ * cp₂\nfalse","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Default-rules-in-coupling-patterns","page":"Couplings among different degrees of freedom","title":"Default rules in coupling patterns","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As has been shown in the previous subsection, some attributes of the iid attribute of Index can be initialized by the : operator during the construction of a coupling pattern. For the orbital and spin attributes of FID, and for the direction attribute of PID, the default rule is that such indexes will be summed diagonally in the coupling pattern. In fact, the site attribute of Index and the nambu attribute of FID also support the : initialization, but with different default rules.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Let's return to the example of the coupling pattern of the usual hopping term, i.e., c^dagger_ic_j. Apparently, the site attributes are always (1, 2) and the nambu attributes are always (2, 1) as long as the coupling pattern belongs to an usual hopping term. In fact, for most common terms in condensed matter, such attributes in the coupling pattern usually depends only on their kinds other than the concrete instances. Therefore, we could define them outside the construction functions of Coupling or Term by separate functions, and just leave them to the default rules.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"All predefined default rules can be found in the section of Specialized terms. If you need a term that is beyond such default rules, or you just think that such rules are too complicated to remember, it is recommended to explicitly writing them out in the coupling pattern.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Coupling-patterns-with-constraints","page":"Couplings among different degrees of freedom","title":"Coupling patterns with constraints","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The default rules cannot handle complicated summation conditions on the local internal degrees of freedom in the coupling pattern. For example, for the interorbital-interspin Hubbard term in a multi-orbital Hubbard model, which can be written as Usum_isum_αβtextandσ₁σ₂ c^_iασ₁ c_iασ₁ c^_iβσ₂ c_iβσ₂, it is impossible to specify its coupling pattern by a single Coupling in the usual way as introduced in previous subsections. Although the coupling pattern of a Term can also be an iterator of Couplings, it would be quite complicated to write down all the expressions by the manual expansion of the summation over α, β, σ₁ and σ₂. In fact, we have provided a simple way to specify a coupling pattern like this with the help of the macro @indexes:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"@indexes(index₁, index₂, ...[; constraint=...])","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For example, the coupling pattern of the above interorbital-interspin Hubbard term can be constructed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(@indexes(\n           Index(:, FID(α, σ₁, 2)),\n           Index(:, FID(α, σ₁, 1)),\n           Index(:, FID(β, σ₂, 2)),\n           Index(:, FID(β, σ₂, 1));\n           constraint=α<β && σ₁≠σ₂\n       ))\n∑[Index(:, FID(α, σ₁, 2)) Index(:, FID(α, σ₁, 1)) Index(:, FID(β, σ₂, 2)) Index(:, FID(β, σ₂, 1))](α < β && σ₁ ≠ σ₂)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The keyword argument constraint can be omitted if there are no constraints in the summation, e.g., for a special kind of phonon potential Vsum_ijfrac12sum_μνu_i^μ u_j^ν, the coupling pattern can be written as","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(1//2, @indexes Index(1, PID('u', μ)) Index(2, PID('u', ν)))\n1//2 ∑[Index(1, PID('u', μ)) Index(2, PID('u', ν))]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As is common for all cases, the Indexes in the @indexes macro can be of different types, e.g., for a fabricated term just for illustration λsum_ijfrac12sum_αβσ c^dagger_iασ c_iβσ u^x_i, the coupling pattern is","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(\n           1//2,\n           @indexes Index(1, FID(α, σ, 2)) Index(1, FID(β, σ, 1)) Index(1, PID('u', 'x'))\n       )\n1//2 ∑[Index(1, FID(α, σ, 2)) Index(1, FID(β, σ, 1)) Index(1, PID('u', 'x'))]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"One last remark. The constraints can only act on the iid attribute but not on the site attribute of Index. Remind that the site attribute of Index in the coupling pattern is the ordinal of a point in a bond but not the site index of a point in a lattice. Constraint on it makes no sense.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Coupling-patterns-with-matrices-acting-on-sub-internal-spaces","page":"Couplings among different degrees of freedom","title":"Coupling patterns with matrices acting on sub internal spaces","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"At times, the coupling pattern of a term is not compact enough to be represented by a single Coupling. Then as has been pointed out, they can be represented by an iterator of Couplings. A particular common case in condensed matter physics is that it can be represented by a matrix acting on specific sub internal spaces, e.g., a spin-dependent hopping tsum_ijc^dagger_i σᶻ c_j + hc where σᶻ acts on the local spin space. A new type, the MatrixCoupling, as a vector of Coupling, which can be constructed by the following functions:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# Fock systems\nMatrixCoupling(\n    sites::Union{NTuple{2, Int}, Colon},\n    ::Type{<:FID},\n    orbital::Union{AbstractMatrix, Colon},\n    spin::Union{AbstractMatrix, Colon},\n    nambu::Union{AbstractMatrix, Colon}\n)\n\n# Spin systems\nMatrixCoupling(\n    sites::Union{NTuple{2, Int}, Colon},\n    ::Type{<:SID},\n    matrix::AbstractMatrix\n)\n\n# Phonon systems\nMatrixCoupling(\n    sites::Union{NTuple{2, Int}, Colon},\n    ::Type{PID},\n    matrix::AbstractMatrix\n)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"is designed to represent the coupling patterns in such cases. Here, in the second construction function the matrix acts on the local (S^x S^y S^z)^T vector space, and in the third construction function the matrix acts on the local (u^x u^y u^z)^T vector space depending on the dimension of the lattice vibrations.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The following codes construct the coupling pattern of the above spin-dependent hopping example:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> mc = MatrixCoupling(:, FID, :, σ\"z\", :);\n\njulia> length(mc)\n2\n\njulia> mc[1]\n∑[Index(:, FID(:, 1//2, :)) Index(:, FID(:, 1//2, :))]\n\njulia> mc[2]\n- ∑[Index(:, FID(:, -1//2, :)) Index(:, FID(:, -1//2, :))]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here, @σ_str is a string literal that returns the generalized Pauli matrices:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"σ\"0\" => SparseMatrixCSC([1 0; 0 1])\nσ\"x\" => SparseMatrixCSC([0 1; 1 0])\nσ\"y\" => SparseMatrixCSC([0 -1im; 1im 0])\nσ\"z\" => SparseMatrixCSC([1 0; 0 -1])\nσ\"+\" => SparseMatrixCSC([0 1; 0 0])\nσ\"-\" => SparseMatrixCSC([0 0; 1 0])\nσ\"11\" => SparseMatrixCSC([1 0; 0 0])\nσ\"22\" => SparseMatrixCSC([0 0; 0 1])","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The coupling pattern of the Heisenberg term Jsum_ijS^x_iS^x_j+S^y_iS^y_j+S^z_iS^z_j can be constructed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> mc = MatrixCoupling(:, SID, Heisenberg\"\");\n\njulia> length(mc)\n3\n\njulia> mc[1]\nIndex(:, SID('x')) Index(:, SID('x'))\n\njulia> mc[2]\nIndex(:, SID('y')) Index(:, SID('y'))\n\njulia> mc[3]\nIndex(:, SID('z')) Index(:, SID('z'))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"where @Heisenberg_str is a string literal that helps to specify common spin terms.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here lists all the predefined string literals that are helpful to local spin systems:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# Heisenberg term\nHeisenberg\"\" => SparseMatrixCSC([1 0 0; 0 1 0; 0 0 1])\n\n# Ising terms\nIsing\"x\" => SparseMatrixCSC([1 0 0; 0 0 0; 0 0 0])\nIsing\"y\" => SparseMatrixCSC([0 0 0; 0 1 0; 0 0 0])\nIsing\"z\" => SparseMatrixCSC([0 0 0; 0 0 0; 0 0 1])\n\n# Γ terms\nΓ\"x\" => SparseMatrixCSC([0 0 0; 0 0 1; 0 1 0])\nΓ\"y\" => SparseMatrixCSC([0 0 1; 0 0 0; 1 0 0])\nΓ\"z\" => SparseMatrixCSC([0 1 0; 1 0 0; 0 0 0])\n\n# Dzyaloshinskii–Moriya terms\nDM\"x\" => SparseMatrixCSC([0 0 0; 0 0 1; 0 -1 0])\nDM\"y\" => SparseMatrixCSC([0 0 -1; 0 0 0; 1 0 0])\nDM\"z\" => SparseMatrixCSC([0 1 0; -1 0 0; 0 0 0])","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"MatrixCouplings can be producted or summed.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For one example, for the nearest-neighbor spin exchange interactions of itinerant fermions Jsum_ijc^_ivecσ_ic_i  c^_jvecσ_jc_j where vecσ_i=(σ^x_i σ^y_i σ^z_i)^T acts on the local spin space at site i, the coupling pattern can be constructed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> mc₁ = MatrixCoupling(:, FID, :, σ\"+\", :);\n\njulia> mc₂ = MatrixCoupling(:, FID, :, σ\"-\", :);\n\njulia> mc₃ = MatrixCoupling(:, FID, :, σ\"z\", :);\n\njulia> coupling = 1//2*mc₁*mc₂ + 1//2*mc₂*mc₁ + mc₃*mc₃;\n\njulia> collect(coupling)\n6-element Vector{Coupling}:\n 1//2 ∑[Index(:, FID(:, 1//2, :)) Index(:, FID(:, -1//2, :))] ⋅ ∑[Index(:, FID(:, -1//2, :)) Index(:, FID(:, 1//2, :))]\n 1//2 ∑[Index(:, FID(:, -1//2, :)) Index(:, FID(:, 1//2, :))] ⋅ ∑[Index(:, FID(:, 1//2, :)) Index(:, FID(:, -1//2, :))]\n ∑[Index(:, FID(:, 1//2, :)) Index(:, FID(:, 1//2, :))] ⋅ ∑[Index(:, FID(:, 1//2, :)) Index(:, FID(:, 1//2, :))]\n - ∑[Index(:, FID(:, -1//2, :)) Index(:, FID(:, -1//2, :))] ⋅ ∑[Index(:, FID(:, 1//2, :)) Index(:, FID(:, 1//2, :))]\n - ∑[Index(:, FID(:, 1//2, :)) Index(:, FID(:, 1//2, :))] ⋅ ∑[Index(:, FID(:, -1//2, :)) Index(:, FID(:, -1//2, :))]\n ∑[Index(:, FID(:, -1//2, :)) Index(:, FID(:, -1//2, :))] ⋅ ∑[Index(:, FID(:, -1//2, :)) Index(:, FID(:, -1//2, :))]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For another example, for the onsite spin-orbital coupling of the (d_yz d_xz d_xy)^T t_2g orbitals lambdasum_i c^dagger_i vecL_icdotvecσ_i c_i where vecL_i=(L^x_i L^y_i L^z_i)^T acts on the local orbital space and vecσ_i=(σ^x_i σ^y_i σ^z_i)^T acts on the local spin space, the coupling pattern can be constructed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> mc₁ = MatrixCoupling(:, FID, L\"x\", σ\"x\", :);\n\njulia> mc₂ = MatrixCoupling(:, FID, L\"y\", σ\"y\", :);\n\njulia> mc₃ = MatrixCoupling(:, FID, L\"z\", σ\"z\", :);\n\njulia> coupling = mc₁ + mc₂ + mc₃;\n\njulia> collect(coupling)\n12-element Vector{Coupling}:\n -1im Index(:, FID(3, -1//2, :)) Index(:, FID(2, 1//2, :))\n 1im Index(:, FID(2, -1//2, :)) Index(:, FID(3, 1//2, :))\n -1im Index(:, FID(3, 1//2, :)) Index(:, FID(2, -1//2, :))\n 1im Index(:, FID(2, 1//2, :)) Index(:, FID(3, -1//2, :))\n - Index(:, FID(3, -1//2, :)) Index(:, FID(1, 1//2, :))\n Index(:, FID(1, -1//2, :)) Index(:, FID(3, 1//2, :))\n Index(:, FID(3, 1//2, :)) Index(:, FID(1, -1//2, :))\n - Index(:, FID(1, 1//2, :)) Index(:, FID(3, -1//2, :))\n -1im Index(:, FID(2, 1//2, :)) Index(:, FID(1, 1//2, :))\n 1im Index(:, FID(1, 1//2, :)) Index(:, FID(2, 1//2, :))\n 1im Index(:, FID(2, -1//2, :)) Index(:, FID(1, -1//2, :))\n -1im Index(:, FID(1, -1//2, :)) Index(:, FID(2, -1//2, :))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Bond-dependent-coupling-patterns","page":"Couplings among different degrees of freedom","title":"Bond-dependent coupling patterns","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Sometimes, the coupling pattern of a term could be dependent on the bonds. For example, for the Kitaev term on the honeycomb lattice Ksum_ij_γ S_i^γS_j^γ where the nearest-neighbor spin exchange interaction depends on the direction of the nearest-neighbor bonds, as illustrated by the following picture, (Image: Kitaev honeycomb model) the coupling pattern can be represented by the following function:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"function kitaev(bond::Bond)\n    ϕ = azimuth(rcoordinate(bond)) # get the azimuth angle of a bond in radians\n    @assert any(≈(ϕ), (π/6, 7π/6, 5π/6, 11π/6, π/2, 3π/2)) \"kitaev error: wrong input bond.\"\n    any(≈(ϕ), (π/6, 7π/6)) && return Coupling(:, SID, ('x'), ('x'))\n    any(≈(ϕ), (5π/6, 11π/6)) && return Coupling(:, SID, ('y'), ('y'))\n    return Coupling(:, SID, ('z'), ('z'))\nend","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Note in all cases, the function to specify a bond dependent coupling pattern can only accept an instance of Bond as its sole argument, but it can return either a Coupling or an iterator of Couplings.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Bond-dependent-amplitude","page":"Couplings among different degrees of freedom","title":"Bond-dependent amplitude","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As is similar to bond-dependent coupling patterns, the bond-dependent amplitude of a term can be achieved by a function that only accepts an instance of Bond as its sole argument and returns a number. For example, for the staggered local chemical potential Δsum_i(-1)^ic_i^c_i, the bond-dependent amplitude can be specified as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"function staggered(bond::Bond)\n    @assert length(bond)==1 \"staggered error: wrong input bond.\"\n    return (-1)^bond[1].site\nend","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Terms-with-complex-coefficients","page":"Couplings among different degrees of freedom","title":"Terms with complex coefficients","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"A special case must be paid attention to, i.e., a term with a complex coefficient. In the construction function of Term, a complex number with a nonzero imaginary part can not be used to specify the overall coefficient of a term. This is because the Hamiltonian of a quantum lattice system must be Hermitian and a complex coefficient must be accompanied with its complex conjugate. Thus, the positive direction of the phase must be appointed, resulting in a bond-dependent amplitude. Then, it is always feasible to extract a real overall factor as the final coefficient and leave the remaining part to the bond-dependent amplitude function. For example, for the p+ip pairing potential Δsum_ije^iϕ_ijc^_ic^_j + hc, the coefficient is a pure imaginary number along the y direction, and the bond-dependent amplitude of this term can be specified as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"function pip_potential(bond::Bond)\n    ϕ = azimuth(rcoordinate(bond))\n    return exp(1im*ϕ)\nend","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Principles-of-the-partition-of-coefficients","page":"Couplings among different degrees of freedom","title":"Principles of the partition of coefficients","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As has been shown but not explicitly stated, in general, the coefficient of a term is partitioned into three parts in Term, the first part is the overall coefficient which must be a real number and is specified by the value argument in the construction function, the second part is the coefficient occurring in the coupling pattern, and the last part is handled by the bond-dependent amplitude function. Then there exist an ambiguity about how these three parts should be partitioned. Here are the recommended principles:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The overall real coefficient should contain as much as possible of the coefficient of the term that can be put in front of the summation over bonds.\nThe coefficient of a coupling pattern should be determined by traditions (e.g., i in the σʸ Pauli matrix), otherwise should be 1.\nThe bond-dependent amplitude should not contain the tuning parameters of a quantum lattice model.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"If the coefficient of a complicated term cannot fulfill the above principles at the same time, then you should consider splitting it into several terms. A simple check of the number of terms is that in principle it should be equal to the number of tunable parameters of the quantum lattice model under study.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Specialized-terms","page":"Couplings among different degrees of freedom","title":"Specialized terms","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For each certain kind of terms, some of the input parameters of the basic construction function are in fact fixed or have default values, e.g., the usual hopping term is always non-Hermitian while the Hubbard term is always Hermitian. Therefore, for each common kind of terms in condensed matter physics, it is more convenient to define the specialized construction function. In the following subsections we will list the predefined specialized terms.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Terms-for-complex-fermionic/bosonic-systems","page":"Couplings among different degrees of freedom","title":"Terms for complex fermionic/bosonic systems","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# termkind = :Onsite\n# bondkind = 0\nOnsite(\n    id::Symbol, value, coupling=Coupling(Index(:, FID(:, :, :)), Index(:, FID(:, :, :)));\n    ishermitian::Bool=true,\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Hopping\n# ishermitian = false\nHopping(\n    id::Symbol,\n    value,\n    bondkind,\n    coupling=Coupling(Index(:, FID(:, :, :)), Index(:, FID(:, :, :)));\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Pairing\n# ishermitian = false\nPairing(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :Hubbard\n# bondkind = 0\n# coupling = Coupling(:, FID, :, (1//2, 1//2, -1//2, -1//2), (2, 1, 2, 1))\n# ishermitian = true\nHubbard(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :InterOrbitalInterSpin\n# bondkind = 0\n# coupling = Coupling(@indexes(\n#     Index(:, FID(α, σ₁, 2)),\n#     Index(:, FID(α, σ₁, 1)),\n#     Index(:, FID(β, σ₂, 2)),\n#     Index(:, FID(β, σ₂, 1));\n#     constraint=α<β && σ₁≠σ₂\n# ))\n# ishermitian = true\nInterOrbitalInterSpin(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :InterOrbitalIntraSpin\n# bondkind = 0\n# coupling = Coupling(@indexes(\n#     Index(:, FID(α, σ, 2)),\n#     Index(:, FID(α, σ, 1)),\n#     Index(:, FID(β, σ, 2)),\n#     Index(:, FID(β, σ, 1));\n#     constraint=α<β\n# ))\n# ishermitian = true\nInterOrbitalIntraSpin(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :SpinFlip\n# bondkind = 0\n# coupling = Coupling(@indexes(\n#     Index(:, FID(α, 1//2, 2)),\n#     Index(:, FID(β, -1//2, 2)),\n#     Index(:, FID(α, -1//2, 1)),\n#     Index(:, FID(β, 1//2, 1));\n#     constraint=α<β\n# ))\n# ishermitian = false\nSpinFlip(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :PairHopping\n# bondkind = 0\n# coupling = Coupling(@indexes(\n#     Index(:, FID(α, 1//2, 2)),\n#     Index(:, FID(α, -1//2, 2)),\n#     Index(:, FID(β, -1//2, 1)),\n#     Index(:, FID(β, 1//2, 1));\n#     constraint=α<β\n# ))\n# ishermitian = false\nPairHopping(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :Coulomb\nCoulomb(\n    id::Symbol,\n    value,\n    bondkind,\n    coupling=Coupling(Index(:, FID(:, :, :)), Index(:, FID(:, :, :)))^2;\n    ishermitian::Bool=true,\n    amplitude::Union{Function, Nothing}=nothing\n)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Default rules for such terms when the site attribute of Index and the orbital, spin and nambu attributes of FID initialized by the : operator are listed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":" site orbital spin nambu\nOnsite (1, 1) diagonal diagonal (2, 1)\nHopping (1, 2) diagonal diagonal (2, 1)\nPairing (1, 1)/(1, 2) diagonal diagonal (1, 1)\nHubbard (1, 1, 1, 1) diagonal  \nInterOrbitalInterSpin (1, 1, 1, 1)   \nInterOrbitalIntraSpin (1, 1, 1, 1)   \nSpinFlip (1, 1, 1, 1)   \nPairHopping (1, 1, 1, 1)   \nCoulomb (1, 1, 2, 2) diagonal diagonal (2, 1, 2, 1)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"note: Note\nFor the Pairing term, the site attributes will be (1, 1) when bondkind=0, otherwise (1, 2).\nBlank cells in the above table mean that the corresponding attributes have been explicitly specified by the specialized construction functions. See the comments of the above code block in this subsection.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Terms-for-SU(2)-spin-systems","page":"Couplings among different degrees of freedom","title":"Terms for SU(2) spin systems","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# termkind = :SpinTerm\n# ishermitian = true\nSpinTerm(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For spin systems, only the site attribute of Index can be initialized by the : operator. Depending on the rank of the term (i.e. the number of Indexes in the coupling pattern) and the length of the bonds to be summed over, it will be (1, 1, ...) when the bond length is 1 and (1, 2, 1, 2...) when the bond length is 2. For other generic bonds with more points, no default rule exists.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Terms-for-phononic-systems","page":"Couplings among different degrees of freedom","title":"Terms for phononic systems","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# termkind = :Kinetic\n# bondkind = 0\n# coupling = Coupling(:, PID, ('p', 'p'), :)\n# ishermitian = true\n# default rules: (1, 1) for `site` and diagonal for `direction`\nKinetic(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :Hooke\n# ishermitian = true\n# default rules: (1, 2) for `site`\nHooke(id::Symbol, value, bondkind; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :Elastic\n# ishermitian = true\n# default rules: (1, 2) for `site`\nElastic(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For spin terms, the site attribute of Index and the direction attribute of PID can be initialized by the : operator. The default rules are also summarized in the comments of the above code block.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Expand-terms-to-obtain-operators","page":"Couplings among different degrees of freedom","title":"Expand terms to obtain operators","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"To obtain the operators of a Term, the expand function exported by this package can be used as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"expand(term::Term, bond::Bond, hilbert::Hilbert) -> Operators\nexpand(term::Term, bonds::Vector{<:Bond}, hilbert::Hilbert) -> Operators","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Let's see a simple example of the usual hopping term:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> t = Hopping(:t, 2.0, 1);\n\njulia> bond = Bond(1, Point(1, [0.0], [0.0]), Point(2, [0.5], [0.0]));\n\njulia> hilbert = Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:f}(1, 2));\n\njulia> expand(t, bond, hilbert)\nOperators with 4 Operator\n  Operator(2.0, CompositeIndex(Index(1, FID{:f}(1, 1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, 1//2, 1)), [0.5], [0.0]))\n  Operator(2.0, CompositeIndex(Index(1, FID{:f}(1, -1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, -1//2, 1)), [0.5], [0.0]))\n  Operator(2.0, CompositeIndex(Index(2, FID{:f}(1, 1//2, 2)), [0.5], [0.0]), CompositeIndex(Index(1, FID{:f}(1, 1//2, 1)), [0.0], [0.0]))\n  Operator(2.0, CompositeIndex(Index(2, FID{:f}(1, -1//2, 2)), [0.5], [0.0]), CompositeIndex(Index(1, FID{:f}(1, -1//2, 1)), [0.0], [0.0]))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"When a bond and a term do not match each other, the expand function will return an empty Operators:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> t = Hopping(:t, 1.0, 1);\n\njulia> bond = Bond(2, Point(1, [0.0], [0.0]), Point(1, [1.0], [1.0]));\n\njulia> hilbert = Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:f}(1, 2));\n\njulia> expand(t, bond, hilbert)\nOperators with 0 Operator","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"In the expand function, a Vector of Bonds can also be provided to get all the operators expanded on such bonds:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> t = Hopping(:t, 1.0, 1);\n\njulia> bonds = [\n           Bond(1, Point(2, [0.5], [0.0]), Point(1, [0.0], [0.0]))\n           Bond(1, Point(2, [-0.5], [-1.0]), Point(1, [0.0], [0.0]))\n       ];\n\njulia> hilbert = Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:f}(1, 2));\n\njulia> expand(t, bonds, hilbert)\nOperators with 8 Operator\n  Operator(1.0, CompositeIndex(Index(2, FID{:f}(1, 1//2, 2)), [-0.5], [-1.0]), CompositeIndex(Index(1, FID{:f}(1, 1//2, 1)), [0.0], [0.0]))\n  Operator(1.0, CompositeIndex(Index(1, FID{:f}(1, 1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, 1//2, 1)), [0.5], [0.0]))\n  Operator(1.0, CompositeIndex(Index(1, FID{:f}(1, 1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, 1//2, 1)), [-0.5], [-1.0]))\n  Operator(1.0, CompositeIndex(Index(1, FID{:f}(1, -1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, -1//2, 1)), [0.5], [0.0]))\n  Operator(1.0, CompositeIndex(Index(2, FID{:f}(1, 1//2, 2)), [0.5], [0.0]), CompositeIndex(Index(1, FID{:f}(1, 1//2, 1)), [0.0], [0.0]))\n  Operator(1.0, CompositeIndex(Index(2, FID{:f}(1, -1//2, 2)), [-0.5], [-1.0]), CompositeIndex(Index(1, FID{:f}(1, -1//2, 1)), [0.0], [0.0]))\n  Operator(1.0, CompositeIndex(Index(1, FID{:f}(1, -1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, -1//2, 1)), [-0.5], [-1.0]))\n  Operator(1.0, CompositeIndex(Index(2, FID{:f}(1, -1//2, 2)), [0.5], [0.0]), CompositeIndex(Index(1, FID{:f}(1, -1//2, 1)), [0.0], [0.0]))","category":"page"},{"location":"advanced topics/Introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = QuantumLattices","category":"page"},{"location":"advanced topics/Introduction/#AdvancedTopicsIntroduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"advanced topics/Introduction/","page":"Introduction","title":"Introduction","text":"The unitcell description framework is the basics of this package, which completes the goal of describing a quantum lattice system and obtaining its Hamiltonian in the operator form. Here, we introduce some advanced utilities provided in this package that will be useful for the compiling, debugging and applying of quantum many-body algorithms.","category":"page"},{"location":"advanced topics/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"LaTeXFormattedOutputs.md\",\n    \"IndexOrders.md\",\n    \"BoundaryConditions.md\",\n    \"HybridSystems.md\",\n    \"Transformations.md\",\n    \"ManageProjects.md\",\n    ]\nDepth = 2","category":"page"},{"location":"advanced topics/LaTeXFormattedOutputs/","page":"LaTeX formatted outputs","title":"LaTeX formatted outputs","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"advanced topics/LaTeXFormattedOutputs/#LaTeX-formatted-outputs","page":"LaTeX formatted outputs","title":"LaTeX formatted outputs","text":"","category":"section"},{"location":"man/Spatials/","page":"Spatials","title":"Spatials","text":"CurrentModule = QuantumLattices.Spatials","category":"page"},{"location":"man/Spatials/#Spatials","page":"Spatials","title":"Spatials","text":"","category":"section"},{"location":"man/Spatials/","page":"Spatials","title":"Spatials","text":"Modules = [Spatials]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Spatials/#QuantumLattices.QuantumNumbers.Momentum₁-Union{Tuple{N}, Tuple{AbstractVector, AbstractVector{<:AbstractVector}}} where N","page":"Spatials","title":"QuantumLattices.QuantumNumbers.Momentum₁","text":"Momentum₁{N}(momentum::AbstractVector, reciprocals::AbstractVector{<:AbstractVector}) where N\nMomentum₂{N₁, N₂}(momentum::AbstractVector, reciprocals::AbstractVector{<:AbstractVector}) where {N₁, N₂}\nMomentum₃{N₁, N₂, N₃}(momentum::AbstractVector, reciprocals::AbstractVector{<:AbstractVector}) where {N₁, N₂, N₃}\n\nConstruct a quantum momentum by the coordinates.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.AbstractLattice","page":"Spatials","title":"QuantumLattices.Spatials.AbstractLattice","text":"AbstractLattice{N, D<:Number, M}\n\nAbstract type of a unitcell-described lattice.\n\nIt should have the following contents:\n\nname::Symbol: the name of the lattice\ncoordinates::Matrix{D}: the coordinates of the lattice\nvectors::SVector{M, SVector{N, D}}: the translation vectors of the lattice\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Bond","page":"Spatials","title":"QuantumLattices.Spatials.Bond","text":"Bond{K, P<:Point}\n\nA generic bond, which could contains several points.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Bond-Tuple{Point}","page":"Spatials","title":"QuantumLattices.Spatials.Bond","text":"Bond(point::Point)\nBond(kind, point₁::Point, point₂::Point, points::Point...)\n\nConstruct a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.BrillouinZone","page":"Spatials","title":"QuantumLattices.Spatials.BrillouinZone","text":"BrillouinZone{K, P<:Momentum, S<:SVector, N} <: ReciprocalSpace{K, S}\n\nThe Brillouin zone of a lattice.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.BrillouinZone-Tuple{AbstractVector{<:AbstractVector}, Any}","page":"Spatials","title":"QuantumLattices.Spatials.BrillouinZone","text":"BrillouinZone(reciprocals::AbstractVector{<:AbstractVector}, nk)\nBrillouinZone{K}(reciprocals::AbstractVector{<:AbstractVector}, nk) where K\nBrillouinZone(::Type{P}, reciprocals::AbstractVector{<:AbstractVector}) where {P<:Momentum}\nBrillouinZone{K}(::Type{P}, reciprocals::AbstractVector{<:AbstractVector}) where {K, P<:Momentum}\n\nConstruct a Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.Lattice","page":"Spatials","title":"QuantumLattices.Spatials.Lattice","text":"Lattice{N, D<:Number, M} <: AbstractLattice{N, D, M}\n\nSimplest lattice.\n\nA simplest lattice can be constructed from its coordinates and translation vectors.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Lattice-Union{Tuple{N}, Tuple{Lattice, Tuple{Vararg{Int64, N}}}, Tuple{Lattice, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Char, N}}}} where N","page":"Spatials","title":"QuantumLattices.Spatials.Lattice","text":"Lattice(lattice::Lattice, ranges::NTuple{N, Int}, boundaries::NTuple{N, Char}=ntuple(i->'O', Val(N)); mode::Symbol=:nonnegative) where N\nLattice(lattice::Lattice, ranges::NTuple{N, UnitRange{Int}}, boundaries::NTuple{N, Char}=ntuple(i->'O', Val(N))) where N\n\nConstruct a lattice from the translations of another.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.Lattice-Union{Tuple{Vararg{Tuple{Vararg{Number, N}}}}, Tuple{N}} where N","page":"Spatials","title":"QuantumLattices.Spatials.Lattice","text":"Lattice(coordinates::NTuple{N, Number}...; name::Symbol=:lattice, vectors::Union{AbstractVector{<:AbstractVector{<:Number}}, Nothing}=nothing) where N\nLattice(coordinates::Vector{<:Number}...; name::Symbol=:lattice, vectors::Union{AbstractVector{<:AbstractVector{<:Number}}, Nothing}=nothing)\n\nConstruct a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.Neighbors","page":"Spatials","title":"QuantumLattices.Spatials.Neighbors","text":"Neighbors{K, V<:Number} <: CompositeDict{K, V}\n\nNeighbor vs. bond length maps.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Neighbors-Tuple{AbstractLattice, Integer}","page":"Spatials","title":"QuantumLattices.Spatials.Neighbors","text":"Neighbors(lattice::AbstractLattice, nneighbor::Integer; coordination::Int=12)\n\nGet the neighbor vs. bond length map of a lattice up to the nneighborth order.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.Point","page":"Spatials","title":"QuantumLattices.Spatials.Point","text":"Point{N, D<:Number}\n\nA point in a unitcell-described lattice.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Point-Union{Tuple{N}, Tuple{Integer, Tuple{Vararg{var\"#s176\", N}} where var\"#s176\"<:Number}, Tuple{Integer, Tuple{Vararg{var\"#s149\", N}} where var\"#s149\"<:Number, Tuple{Vararg{var\"#s148\", N}} where var\"#s148\"<:Number}} where N","page":"Spatials","title":"QuantumLattices.Spatials.Point","text":"Point(site::Integer, rcoordinate::SVector{N, D}, icoordinate::SVector{N, D}) where {N, D<:Number}\nPoint(site::Integer, rcoordinate::NTuple{N, <:Number}, icoordinate::NTuple{N, <:Number}=ntuple(i->0, N)) where N\nPoint(site::Integer, rcoordinate::AbstractVector{<:Number}, icoordinate::AbstractVector{<:Number}=zero(SVector{length(rcoordinate), Int}))\n\nConstruct a labeled point.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalPath","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalPath","text":"ReciprocalPath{K, S<:SVector, N, R} <: ReciprocalSpace{K, S}\n\nA path in the reciprocal space.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalPath-Union{Tuple{M}, Tuple{AbstractVector{<:AbstractVector}, Tuple{Tuple{Vararg{Pair, M}}, Tuple{Vararg{Pair, M}}}}} where M","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalPath","text":"ReciprocalPath(\n    reciprocals::AbstractVector{<:AbstractVector}, contents::Tuple{NTuple{M, Pair}, NTuple{M, Pair}};\n    length=100, ends=nothing\n) where M\nReciprocalPath(\n    reciprocals::AbstractVector{<:AbstractVector}, segments::Pair{<:NTuple{N, Number}, <:NTuple{N, Number}}...;\n    representations=segments, length=100, ends=nothing\n) where N\nReciprocalPath(\n    reciprocals::AbstractVector{<:AbstractVector}, segments::Tuple{Vararg{Pair{<:NTuple{N, Number}, <:NTuple{N, Number}}}};\n    representations=segments, length=100, ends=nothing\n) where N\n\nReciprocalPath{K}(\n    reciprocals::AbstractVector{<:AbstractVector}, contents::Tuple{NTuple{M, Pair}, NTuple{M, Pair}};\n    length=100, ends=nothing\n) where {K, M}\nReciprocalPath{K}(\n    reciprocals::AbstractVector{<:AbstractVector}, segments::Pair{<:NTuple{N, Number}, <:NTuple{N, Number}}...;\n    representations=segments, length=100, ends=nothing\n) where {K, N}\nReciprocalPath{K}(\n    reciprocals::AbstractVector{<:AbstractVector}, segments::Tuple{Vararg{Pair{<:NTuple{N, Number}, <:NTuple{N, Number}}}};\n    representations=segments, length=100, ends=nothing\n) where {K, N}\n\nConstruct a path in the reciprocal space.\n\nWhen length is an integer, it specifies the length of each segment except for the last whose length will be length+1. When ends is nothing, the start point will be included while the end point will be not for each segment except for the last whose both points will be included.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalSpace","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalSpace","text":"ReciprocalSpace{K, P<:SVector} <: SimpleNamedVectorSpace{K, P}\n\nAbstract type of reciprocal spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalZone","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalZone","text":"ReciprocalZone{K, S<:SVector, V<:Number} <: ReciprocalSpace{K, S}\n\nA zone in the reciprocal space.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalZone-Tuple{AbstractVector{<:AbstractVector}}","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalZone","text":"ReciprocalZone(\n    reciprocals::AbstractVector{<:AbstractVector};\n    length=100, ends=(true, false)\n)\nReciprocalZone(\n    reciprocals::AbstractVector{<:AbstractVector},\n    bounds::Pair{<:Number, <:Number}...;\n    length=100, ends=(true, false)\n)\nReciprocalZone(\n    reciprocals::AbstractVector{<:AbstractVector},\n    bounds::Union{Tuple{Vararg{Pair{<:Number, <:Number}}}, Vector{<:Pair{<:Number, <:Number}}};\n    length=100, ends=(true, false)\n)\n\nReciprocalZone{K}(\n    reciprocals::AbstractVector{<:AbstractVector};\n    length=100, ends=(true, false)\n) where K\nReciprocalZone{K}(\n    reciprocals::AbstractVector{<:AbstractVector},\n    bounds::Pair{<:Number, <:Number}...;\n    length=100, ends=(true, false)\n) where K\nReciprocalZone{K}(\n    reciprocals::AbstractVector{<:AbstractVector},\n    bounds::Union{Tuple{Vararg{Pair{<:Number, <:Number}}}, Vector{<:Pair{<:Number, <:Number}}};\n    length=100, ends=(true, false)\n) where K\n\nConstruct a rectangular zone in the reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalZone-Union{Tuple{BrillouinZone{K, P}}, Tuple{P}, Tuple{K}} where {K, P<:Momentum}","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalZone","text":"ReciprocalZone(brillouinzone::BrillouinZone)\n\nConstruct a reciprocal zone from a Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.@hexagon_str-Tuple{String}","page":"Spatials","title":"QuantumLattices.Spatials.@hexagon_str","text":"hexagon\"P₁-P₂-P₃-...\"\nhexagon\"P₁-P₂-P₃-..., 120°\"\nhexagon\"P₁-P₂-P₃-..., 60°\"\n\nConstruct a tuple of start-stop point pairs for the hexagonal reciprocal space.\n\n\n\n\n\n","category":"macro"},{"location":"man/Spatials/#QuantumLattices.Spatials.@line_str-Tuple{String}","page":"Spatials","title":"QuantumLattices.Spatials.@line_str","text":"line\"P₁-P₂-P₃-...\"\n\nConstruct a tuple of start-stop point pairs for the one dimensional reciprocal space.\n\n\n\n\n\n","category":"macro"},{"location":"man/Spatials/#QuantumLattices.Spatials.@rectangle_str-Tuple{String}","page":"Spatials","title":"QuantumLattices.Spatials.@rectangle_str","text":"rectangle\"P₁-P₂-P₃-...\"\n\nConstruct a tuple of start-stop point pairs for the rectangular reciprocal space.\n\n\n\n\n\n","category":"macro"},{"location":"man/Spatials/#Base.eltype-Tuple{Bond}","page":"Spatials","title":"Base.eltype","text":"eltype(bond::Bond)\neltype(::Type{<:Bond{K, P} where K}) where {P<:Point}\n\nGet the point type contained in a generic bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.getindex-Tuple{AbstractLattice, Integer}","page":"Spatials","title":"Base.getindex","text":"getindex(lattice::AbstractLattice, i::Integer) -> SVector\n\nGet the ith coordinate.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.getindex-Tuple{Bond, Integer}","page":"Spatials","title":"Base.getindex","text":"getindex(bond::Bond, i::Integer) -> Point\n\nGet the ith point contained in a generic bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.iterate","page":"Spatials","title":"Base.iterate","text":"iterate(bond::Bond, state=1)\n\nIterate over the points contained in a generic bond.\n\n\n\n\n\n","category":"function"},{"location":"man/Spatials/#Base.length-Tuple{AbstractLattice}","page":"Spatials","title":"Base.length","text":"length(lattice::AbstractLattice) -> Int\n\nGet the number of points contained in a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.length-Tuple{Bond}","page":"Spatials","title":"Base.length","text":"length(bond::Bond) -> Int\n\nGet the number of points contained in a generic bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.reverse-Tuple{Bond}","page":"Spatials","title":"Base.reverse","text":"reverse(bond::Bond) -> Bond\n\nGet the reversed bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.azimuth-Tuple{AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.azimuth","text":"azimuth(v::AbstractVector{<:Number}) -> Number\n\nGet the azimuth angle in radians of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.azimuthd-Tuple{AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.azimuthd","text":"azimuthd(v::AbstractVector{<:Number}) -> Number\n\nGet the azimuth angle in degrees of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.bonds!-Tuple{Vector, AbstractLattice, Int64}","page":"Spatials","title":"QuantumLattices.Spatials.bonds!","text":"bonds!(bonds::Vector, lattice::AbstractLattice, nneighbor::Int; coordination::Int=12)\nbonds!(bonds::Vector, lattice::AbstractLattice, neighbors::Neighbors) -> typeof(bonds)\n\nGet the required bonds of a lattice and append them to the input bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.bonds-Tuple{AbstractLattice, Int64}","page":"Spatials","title":"QuantumLattices.Spatials.bonds","text":"bonds(lattice::AbstractLattice, nneighbor::Int; coordination::Int=12) -> Vector{Bond{Int, Point{dimension(lattice), dtype(lattice)}}}\nbonds(lattice::AbstractLattice, neighbors::Neighbors) -> Vector{Bond{keytype(neighbors), Point{dimension(lattice), dtype(lattice)}}}\n\nGet the required bonds of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.distance-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.distance","text":"distance(p₁::AbstractVector{<:Number}, p₂::AbstractVector{<:Number}) -> Number\n\nGet the distance between two points.\n\nnote: Note\nCompared to norm(p₁-p₂), this function avoids the memory allocation for p₁-p₂, thus is more efficient.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.icoordinate-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Spatials.icoordinate","text":"icoordinate(bond::Bond) -> SVector\n\nGet the icoordinate of the bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.interlinks-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Neighbors}","page":"Spatials","title":"QuantumLattices.Spatials.interlinks","text":"interlinks(cluster₁::AbstractMatrix{<:Number}, cluster₂::AbstractMatrix{<:Number}, neighbors::Neighbors) -> Vector{Tuple{Int, Int, Int}}\n\nUse kdtree to get the intercluster nearest neighbors.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isintracell-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Spatials.isintracell","text":"isintracell(bond::Bond) -> Bool\n\nJudge whether a bond is intra the unit cell of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isintracell-Tuple{Point}","page":"Spatials","title":"QuantumLattices.Spatials.isintracell","text":"isintracell(point::Point) -> Bool\n\nJudge whether a point is intra the unitcell.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isintratriangle-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.isintratriangle","text":"isintratriangle(\n    p::AbstractVector{<:Number}, p₁::AbstractVector{<:Number}, p₂::AbstractVector{<:Number}, p₃::AbstractVector{<:Number};\n    vertexes::NTuple{3, Bool}=(true, true, true), edges::NTuple{3, Bool}=(true, true, true), atol::Real=atol, rtol::Real=rtol\n) -> Bool\n\nJudge whether a point belongs to the interior of a triangle whose vertexes are p₁, 'p₂' and p₃ with the give tolerance. vertexes and edges define whether the interior should contain the vertexes or edges, respectively.\n\nnote: Note\nThe vertexes are in the order (p₁, p₂, p₃) and the edges are in the order (p1p2, p2p3, p3p1).\nThe edges do not contain the vertexes.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isonline-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.isonline","text":"isonline(\n    p::AbstractVector{<:Number}, p₁::AbstractVector{<:Number}, p₂::AbstractVector{<:Number};\n    ends::Tuple{Bool, Bool}=(true, true), atol::Real=atol, rtol::Real=rtol\n) -> Bool\n\nJudge whether a point is on a line segment whose end points are p₁ and p₂ with the given tolerance. ends defines whether the line segment should contain its ends.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isparallel-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.isparallel","text":"isparallel(v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}; atol::Real=atol, rtol::Real=rtol) -> Int\n\nJudge whether two vectors are parallel to each other with the given tolerance, 0 for not parallel, 1 for parallel and -1 for antiparallel.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.issubordinate-Tuple{AbstractVector{<:Number}, AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.Spatials.issubordinate","text":"issubordinate(coordinate::AbstractVector{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}; atol::Real=atol, rtol::Real=rtol) -> Bool\n\nJudge whether a coordinate belongs to a lattice defined by vectors with the given tolerance.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.minimumlengths","page":"Spatials","title":"QuantumLattices.Spatials.minimumlengths","text":"minimumlengths(cluster::AbstractMatrix{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, nneighbor::Int=1; coordination::Int=12) -> Vector{Float}\n\nUse kdtree to search the lowest several minimum bond lengths within a lattice translated by a cluster.\n\nWhen the translation vectors are not empty, the lattice will be considered periodic in the corresponding directions. Otherwise the lattice will be open in all directions. To search for the bonds across the periodic boundaries, the cluster will be pre-translated to become a supercluster, which has open boundaries but is large enough to contain all the nearest neighbors within the required order. The coordination parameter sets the average number of each order of nearest neighbors. If it is to small, larger bond lengths may not be searched, and the result will contain Inf. This is a sign that you may need a larger coordination. Another situation that Inf appears in the result occurs when the minimum lengths are searched in open lattices. Indeed, the cluster may be too small so that the required order just goes beyond it. In this case the warning message can be safely ignored.\n\n\n\n\n\n","category":"function"},{"location":"man/Spatials/#QuantumLattices.Spatials.polar-Tuple{AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.polar","text":"polar(v::AbstractVector{<:Number}) -> Number\n\nGet the polar angle in radians of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.polard-Tuple{AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.polard","text":"polard(v::AbstractVector{<:Number}) -> Number\n\nGet the polar angle in degrees of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.rcoordinate-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Spatials.rcoordinate","text":"rcoordinate(bond::Bond) -> SVector\n\nGet the rcoordinate of the bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.reciprocals-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.Spatials.reciprocals","text":"reciprocals(lattice::AbstractLattice) -> Vector{<:SVector}\n\nGet the reciprocal translation vectors of the dual lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.reciprocals-Tuple{AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.Spatials.reciprocals","text":"reciprocals(vectors::AbstractVector{AbstractVector{<:Number}}) -> AbstractVector{<:AbstractVector{<:Number}}\n\nGet the reciprocals dual to the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.rotate-Tuple{AbstractVector{<:Number}, Number}","page":"Spatials","title":"QuantumLattices.Spatials.rotate","text":"rotate(vector::AbstractVector{<:Number}, angle::Number; axis::Tuple{Union{AbstractVector{<:Number}, Nothing}, Tuple{<:Number, <:Number}}=(nothing, (0, 0))) -> Vector{<:Number}\nrotate(cluster::AbstractMatrix{<:Number}, angle::Number; axis::Tuple{Union{AbstractVector{<:Number}, Nothing}, Tuple{<:Number, <:Number}}=(nothing, (0, 0))) -> Matrix{<:Number}\n\nGet a rotated vector/cluster of the original one by a certain angle around an axis.\n\nThe axis is determined by a point it gets through (nothing can be used to denote the origin), and its polar as well as azimuth angles in radians. The default axis is the z axis.\n\nnote: Note\nThe result is given by the Rodrigues' rotation formula.\nOnly 2 and 3 dimensional vectors can be rotated.\nWhen the input vectors are 2 dimensional, both the polar and azimuth of the axis must be 0.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.selectpath-Union{Tuple{M}, Tuple{BrillouinZone, Tuple{Tuple{Vararg{Pair, M}}, Tuple{Vararg{Pair, M}}}}} where M","page":"Spatials","title":"QuantumLattices.Spatials.selectpath","text":"selectpath(\n    brillouinzone::BrillouinZone, contents::Tuple{NTuple{M, Pair}, NTuple{M, Pair}};\n    ends=nothing, atol::Real=atol, rtol::Real=rtol\n) where M\nselectpath(\n    brillouinzone::BrillouinZone, segments::Pair{<:NTuple{N, Number}, <:NTuple{N, Number}}...;\n    representations=segments, ends=nothing, atol::Real=atol, rtol::Real=rtol\n) where N -> Tuple(ReciprocalPath, Vector{Int})\nselectpath(\n    brillouinzone::BrillouinZone, segments::Tuple{Vararg{Pair{<:NTuple{N, Number}, <:NTuple{N, Number}}}};\n    representations=segments, ends=nothing, atol::Real=atol, rtol::Real=rtol\n) where N -> Tuple(ReciprocalPath, Vector{Int})\n\nSelect a path from a BrillouinZone. Return a ReciprocalPath and the positions of the equivalent points in the BrillouinZone.\n\nWhen ends is nothing, the start point will be included while the end point will be not for each segment except for the last whose both points will be included.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.shrink-Union{Tuple{N}, Tuple{K}, Tuple{ReciprocalZone{K}, Vararg{OrdinalRange{<:Integer}, N}}} where {K, N}","page":"Spatials","title":"QuantumLattices.Spatials.shrink","text":"shrink(reciprocalzone::ReciprocalZone{K}, ranges::Vararg{OrdinalRange{<:Integer}, N}) where {K, N} -> ReciprocalZone\n\nShrink a reciprocal zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.tile-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractVector{<:Number}}, Any}","page":"Spatials","title":"QuantumLattices.Spatials.tile","text":"tile(cluster::AbstractMatrix{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, translations) -> Matrix{<:Number}\n\nTile a supercluster by translations of the input cluster.\n\nBasically, the final supercluster is composed of several parts, each of which is a translation of the original cluster, with the translation vectors specified by vectors and each set of the translation indices contained in translations. When translation vectors are empty, a copy of the original cluster will be returned.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.translate-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.translate","text":"translate(cluster::AbstractMatrix{<:Number}, vector::AbstractVector{<:Number}) -> Matrix{vector|>eltype}\n\nGet the translated cluster of the original one by a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.volume-Tuple{AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.Spatials.volume","text":"volume(vectors::AbstractVector{<:SVector}) -> Number\nvolume(v::AbstractVector{<:Number}) -> Number\nvolume(v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}) -> Number\nvolume(v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}, v₃::AbstractVector{<:Number}) -> Number\n\nGet the volume spanned by the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.decompose-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.decompose","text":"decompose(v₀::AbstractVector{<:Number}, v₁::AbstractVector{<:Number}) -> Tuple{Number}\ndecompose(v₀::AbstractVector{<:Number}, v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}) -> Tuple{Number, Number}\ndecompose(v₀::AbstractVector{<:Number}, v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}, v₃::AbstractVector{<:Number}) -> Tuple{Number, Number, Number}\ndecompose(v₀::AbstractVector{<:Number}, vs::AbstractVector{<:AbstractVector{<:Number}}) -> Vector{<:Number}\n\nDecompose a vector with respect to input basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dimension-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.dimension","text":"dimension(lattice::AbstractLattice) -> Int\ndimension(::Type{<:AbstractLattice{N}}) where N -> Int\n\nGet the space dimension of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dimension-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.dimension","text":"dimension(bond::Bond) -> Int\ndimension(::Type{<:Bond{K, P} where K}) where {P<:Point} -> Int\n\nGet the space dimension of a concrete bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dimension-Tuple{Point}","page":"Spatials","title":"QuantumLattices.dimension","text":"dimension(point::Point) -> Int\ndimension(::Type{<:Point{N}}) where N -> Int\n\nGet the spatial dimension of a point.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dtype-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.dtype","text":"dtype(lattice::AbstractLattice)\ndtype(::Type{<:AbstractLattice{N, D} where N}) where {D<:Number}\n\nGet the data type of the coordinates of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dtype-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.dtype","text":"dtype(bond::Bond)\ndtype(::Type{<:Bond{K, P} where K}) where {P<:Point}\n\nGet the data type of the coordinates of the points contained in a generic bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dtype-Tuple{Point}","page":"Spatials","title":"QuantumLattices.dtype","text":"dtype(point::Point)\ndtype(::Type{<:Point{N, D} where N}) where {D<:Number}\n\nGet the data type of the coordinates of a point.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.expand-Tuple{Momentum, AbstractVector{<:AbstractVector}}","page":"Spatials","title":"QuantumLattices.expand","text":"expand(momentum::Momentum, reciprocals::AbstractVector{<:AbstractVector}) -> eltype(reciprocals)\n\nExpand the momentum from integral values to real values with the given reciprocals.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#RecipesBase.apply_recipe","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(lattice::AbstractLattice, neighbors::Union{Int, Neighbors}, filter::Function=bond->true; siteon=false)\n\nDefine the recipe for the visualization of a lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/Spatials/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ReciprocalPath}","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(path::ReciprocalPath)\n\nDefine the recipe for the visualization of a reciprocal path.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ReciprocalSpace}","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(reciprocalspace::ReciprocalSpace)\n\nDefine the recipe for the visualization of a reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"advanced topics/IndexOrders/","page":"Index orders","title":"Index orders","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"advanced topics/IndexOrders/#Index-orders","page":"Index orders","title":"Index orders","text":"","category":"section"},{"location":"man/DegreesOfFreedom/","page":"Degrees of freedom","title":"Degrees of freedom","text":"CurrentModule = QuantumLattices.DegreesOfFreedom","category":"page"},{"location":"man/DegreesOfFreedom/#Degrees-of-freedom","page":"Degrees of freedom","title":"Degrees of freedom","text":"","category":"section"},{"location":"man/DegreesOfFreedom/","page":"Degrees of freedom","title":"Degrees of freedom","text":"Modules = [DegreesOfFreedom]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.AbstractCompositeIndex","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.AbstractCompositeIndex","text":"AbstractCompositeIndex{I<:Index} <: OperatorUnit\n\nThe abstract type of a composite index.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Boundary","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Boundary","text":"Boundary{Names}(values::AbstractVector{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}) where Names\n\nBoundary twist of operators.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Boundary-Tuple{Operator}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Boundary","text":"(bound::Boundary)(operator::Operator; origin::Union{AbstractVector, Nothing}=nothing) -> Operator\n\nGet the boundary twisted operator.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Component","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Component","text":"Component{T₁, T₂} <: VectorSpace{Tuple{T₁, T₁, T₂}}\n\nA component of a MatrixCoupling, i.e., a matrix acting on a separated internal space.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeIID","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CompositeIID","text":"CompositeIID{T<:Tuple{Vararg{SimpleIID}}} <: IID\n\nThe composition of several single internal ids.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeIID-Tuple{Vararg{SimpleIID}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CompositeIID","text":"CompositeIID(contents::SimpleIID...)\n\nConstruct a composite iid from a set of simple iids.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeIndex","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CompositeIndex","text":"CompositeIndex{I<:Index, V<:SVector} <: AbstractCompositeIndex{I}\n\nComposite index of a quantum operator.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeIndex-Tuple{Index, Any, Any}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CompositeIndex","text":"CompositeIndex(index::Index, rcoordinate, icoordinate)\nCompositeIndex(index::Index; rcoordinate, icoordinate)\n\nConstruct an operator id.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeInternal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CompositeInternal","text":"CompositeInternal{K, T<:Tuple{Vararg{SimpleInternal}}} <: Internal{IID}\n\nThe composition of several single internal spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeInternal-Union{Tuple{Vararg{SimpleInternal}}, Tuple{K}} where K","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CompositeInternal","text":"CompositeInternal{K}(contents::SimpleInternal...) where K\n\nConstruct a composite internal space from a set of simple internal spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Constraint","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Constraint","text":"Constraint{RS, N, C<:NTuple{N, Function}}\n\nThe constraint of the indexes of internal degrees of freedom in a coupling.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Constraint-Tuple{Index, Vararg{Index}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Constraint","text":"Constraint(indexes::Index...)\nConstraint(indexes::NTuple{N, Index}) where N\n\nConstruct a constraint based on the pattern of the input indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Constraint-Union{Tuple{}, Tuple{R}} where R","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Constraint","text":"Constraint{R}() where R\nConstraint{R}(condition::Union{Pattern, Diagonal}) where R\nConstraint{R}(representation::String, condition::Function) where R\n\nConstruct a constraint with only one condition.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Coupling","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Coupling","text":"Coupling{V, I<:ID{Index}, C<:Constraint} <: OperatorPack{V, Tuple{I, C}}\n\nThe coupling intra/inter internal degrees of freedom at different lattice points.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Coupling-Tuple{Index, Vararg{Index}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Coupling","text":"Coupling(indexes::Index...)\nCoupling(value, indexes::Index...)\nCoupling(value, indexes::Tuple{Vararg{Index}})\n\nConstruct a Coupling with the input indexes as the pattern.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Diagonal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Diagonal","text":"Diagonal{Fields} <: Function\n\nConstruct a pattern for a set of homogenous Indexes that all the specified fields of their contained iids should be diagonal, respectively.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Hilbert","text":"Hilbert{I<:Internal} <: CompositeDict{Int, I}\n\nHilbert space at a lattice.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert-Tuple{Vararg{Pair}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Hilbert","text":"Hilbert(ps::Pair...)\nHilbert(kv)\n\nConstruct a Hilbert space the same way as a Dict.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.IID","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.IID","text":"IID <: OperatorUnit\n\nThe id of an internal degree of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.IIDSpace","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.IIDSpace","text":"IIDSpace{I<:IID, V<:Internal} <: VectorSpace{IID}\n\nThe space expanded by a \"labeled\" iid.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Index","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Index","text":"Index{S<:Union{Int, Colon}, I<:SimpleIID} <: OperatorUnit\n\nThe index of a degree of freedom, which consist of the spatial part and the internal part.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Internal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Internal","text":"Internal{I<:IID} <: VectorSpace{I}\n\nThe whole internal degrees of freedom at a single point.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.MatrixCoupling","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.MatrixCoupling","text":"MatrixCoupling{I<:SimpleIID, C<:Tuple{Vararg{Component}}} <: VectorSpace{Coupling}\n\nA set of Couplings whose coefficients are specified by matrices acting on separated internal spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.MatrixCouplingProd","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.MatrixCouplingProd","text":"MatrixCouplingProd{V<:Number, C<:Tuple{Vararg{MatrixCoupling}}} <: VectorSpace{Coupling}\n\nThe product of a set of Couplings whose coefficients are specified by matrices.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.MatrixCouplingSum","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.MatrixCouplingSum","text":"MatrixCouplingSum{C<:MatrixCouplingProd, N} <: VectorSpace{Coupling}\n\nThe sum of a set of Couplings whose coefficients are specified by matrices.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Metric","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Metric","text":"Metric <: Function\n\nThe rules for measuring an operator unit so that different operator units can be compared.\n\nAs a function, every instance should accept only one positional argument, i.e. the operator unit to be measured.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.OperatorUnitToTuple","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.OperatorUnitToTuple","text":"OperatorUnitToTuple{Fields} <: Metric\n\nA rule that converts an operator unit to a tuple by iterating over a set of selected fields in a specific order.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.OperatorUnitToTuple-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.OperatorUnitToTuple","text":"(operatorunittotuple::OperatorUnitToTuple)(index::Index) -> Tuple\n\nConvert an index to a tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.OperatorUnitToTuple-Union{Tuple{Type{I}}, Tuple{I}} where I<:Index","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.OperatorUnitToTuple","text":"OperatorUnitToTuple(::Type{I}) where {I<:Index}\n\nConstruct the metric rule from the information of the Index type.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Pattern","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Pattern","text":"Pattern <: Function\n\nConstruct a pattern for a set of Indexes.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.SimpleIID","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.SimpleIID","text":"SimpleIID <: IID\n\nThe id of a simple internal degree of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.SimpleInternal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.SimpleInternal","text":"SimpleInternal{I<:SimpleIID} <: Internal{I}\n\nThe simple internal degrees of freedom at a single point.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Table","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Table","text":"Table(hilbert::Hilbert, by::Metric=OperatorUnitToTuple(typeof(hilbert))) -> Table\n\nGet the index-sequence table of a Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Table-2","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Table","text":"Table(operatorunits::AbstractVector{<:OperatorUnit}, by::Metric=OperatorUnitToTuple(eltype(operatorunits)))\n\nConvert a set of operator units to the corresponding table of operator unit vs. sequence pairs.\n\nThe input operator units are measured by the input by function with the duplicates removed. The resulting unique values are sorted, which determines the sequence of the input operatorunits. Note that two operator units have the same sequence if their converted values are equal to each other.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Table-3","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Table","text":"Table{I, B<:Metric} <: CompositeDict{I, Int}\n\nThe table of operator unit vs. sequence pairs.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Term","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Term","text":"Term{K, I, V, B, C<:TermCoupling, A<:TermAmplitude, M<:TermModulate}\n\nA term of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Term-Union{Tuple{K}, Tuple{Symbol, Any, Any, Any, Bool}} where K","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Term","text":"Term{K}(id::Symbol, value, bondkind, coupling, ishermitian::Bool; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=true) where K\n\nConstruct a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.TermAmplitude","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.TermAmplitude","text":"TermAmplitude(amplitude::Union{Function, Nothing}=nothing)\n\nThe function for the amplitude of a term.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.TermCoupling","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.TermCoupling","text":"TermCoupling{E<:Coupling, C} <: TermFunction\n\nThe function for the coupling of a term.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.TermFunction","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.TermFunction","text":"TermFunction <: Function\n\nAbstract type for concrete term functions.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.TermModulate","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.TermModulate","text":"TermModulate(id::Symbol, modulate::Function)\nTermModulate(id::Symbol, modulate::Bool)\n\nThe function for the modulation of a term.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.@indexes-Tuple","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.@indexes","text":"@indexes index₁ index₂ ...\n@indexes(index₁, index₂, ...; constraint=...)\n\nConstruct an set of indexes and its constraint according to the input index pattern and an optional constraint.\n\n\n\n\n\n","category":"macro"},{"location":"man/DegreesOfFreedom/#Base.:*-Tuple{Coupling, Coupling}","page":"Degrees of freedom","title":"Base.:*","text":"*(cp₁::Coupling, cp₂::Coupling) -> Coupling\n\nGet the multiplication between two coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.:*-Tuple{MatrixCoupling, MatrixCoupling}","page":"Degrees of freedom","title":"Base.:*","text":"*(mc₁::MatrixCoupling, mc₂::MatrixCoupling) -> MatrixCouplingProd\n*(mc::MatrixCoupling, mcp::MatrixCouplingProd) -> MatrixCouplingProd\n*(mcp::MatrixCouplingProd, mc::MatrixCoupling) -> MatrixCouplingProd\n*(mcp₁::MatrixCouplingProd, mcp₂::MatrixCouplingProd) -> MatrixCouplingProd\n*(mc::MatrixCoupling, factor::Number) -> MatrixCouplingProd\n*(factor::Number, mc::MatrixCoupling) -> MatrixCouplingProd\n*(factor::Number, mcp::MatrixCouplingProd) -> MatrixCouplingProd\n*(mcp::MatrixCouplingProd, factor::Number) -> MatrixCouplingProd\n*(mcs::MatrixCouplingSum, element::Union{Number, MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n*(element::Union{Number, MatrixCoupling, MatrixCouplingProd}, mcs::MatrixCouplingSum) -> MatrixCouplingSum\n*(mcs₁::MatrixCouplingSum, mcs₂::MatrixCouplingSum) -> MatrixCouplingSum\n\nThe product between MatrixCouplings and MatrixCouplingProds.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.:*-Union{Tuple{RS₂}, Tuple{RS₁}, Tuple{Constraint{RS₁, N} where N, Constraint{RS₂, N} where N}} where {RS₁, RS₂}","page":"Degrees of freedom","title":"Base.:*","text":"*(constraint₁::Constraint, constraint₂::Constraint) -> Constraint\n\nGet the combination of two sets of constraints.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.:+-Tuple{Union{MatrixCoupling, QuantumLattices.DegreesOfFreedom.MatrixCouplingProd}, Union{MatrixCoupling, QuantumLattices.DegreesOfFreedom.MatrixCouplingProd}}","page":"Degrees of freedom","title":"Base.:+","text":"+(mc₁::Union{MatrixCoupling, MatrixCouplingProd}, mc₂::Union{MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n+(mc::Union{MatrixCoupling, MatrixCouplingProd}, mcs::MatrixCouplingSum) -> MatrixCouplingSum\n+(mcs::MatrixCouplingSum, mc::Union{MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n+(mcs₁::MatrixCouplingSum, mcs₂::MatrixCouplingSum) -> MatrixCouplingSum\n\nThe addition between MatrixCouplings and MatrixCouplingProds.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.:/-Tuple{QuantumLattices.DegreesOfFreedom.MatrixCouplingProd, Number}","page":"Degrees of freedom","title":"Base.:/","text":"/(mcp::MatrixCouplingProd, factor::Number) -> MatrixCouplingProd\n/(mcs::MatrixCouplingSum, factor::Number) -> MatrixCouplingSum\n/(mc::MatrixCoupling, factor::Number) -> MatrixCouplingProd\n//(mcp::MatrixCouplingProd, factor::Number) -> MatrixCouplingProd\n//(mcs::MatrixCouplingSum, factor::Number) -> MatrixCouplingSum\n//(mc::MatrixCoupling, factor::Number) -> MatrixCouplingProd\n-(mc::MatrixCoupling) -> MatrixCouplingProd\n-(mcp::MatrixCouplingProd) -> MatrixCouplingProd\n-(mcs::MatrixCouplingSum) -> MatrixCouplingSum\n-(mc₁::Union{MatrixCoupling, MatrixCouplingProd}, mc₂::Union{MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n-(mc::Union{MatrixCoupling, MatrixCouplingProd}, mcs::MatrixCouplingSum) -> MatrixCouplingSum\n-(mcs::MatrixCouplingSum, mc::Union{MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n-(mcs₁::MatrixCouplingSum, mcs₂::MatrixCouplingSum) -> MatrixCouplingSum\n\nDefine right-division, minus and subtraction operator.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.:^-Tuple{Union{MatrixCoupling, QuantumLattices.DegreesOfFreedom.MatrixCouplingProd, QuantumLattices.DegreesOfFreedom.MatrixCouplingSum}, Int64}","page":"Degrees of freedom","title":"Base.:^","text":"^(mc::Union{MatrixCoupling, MatrixCouplingProd, MatrixCouplingSum}, n::Int) -> Union{MatrixCoupling, MatrixCouplingProd, MatrixCouplingSum}\n\nGet the nth power of a MatrixCoupling/MatrixCouplingProd/MatrixCouplingSum.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.adjoint-Tuple{CompositeIndex}","page":"Degrees of freedom","title":"Base.adjoint","text":"adjoint(index::CompositeIndex) -> typeof(index)\n\nGet the adjoint of an operator id.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.adjoint-Tuple{Index}","page":"Degrees of freedom","title":"Base.adjoint","text":"adjoint(index::Index) -> typeof(index)\n\nGet the adjoint of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.filter-Tuple{SimpleIID, CompositeInternal}","page":"Degrees of freedom","title":"Base.filter","text":"filter(iid::SimpleIID, ci::CompositeInternal) -> Union{Nothing, SimpleInternal, CompositeInternal}\nfilter(::Type{I}, ci::CompositeInternal) where {I<:SimpleIID} -> Union{Nothing, SimpleInternal, CompositeInternal}\n\nFilter the composite internal space and select those that matches I or the type of iid.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.filter-Tuple{SimpleIID, SimpleInternal}","page":"Degrees of freedom","title":"Base.filter","text":"filter(iid::SimpleIID, i::SimpleInternal) -> Union{Nothing, typeof(i)}\nfilter(::Type{I}, i::SimpleInternal) where {I<:SimpleIID} -> Union{Nothing, typeof(i)}\n\nFilter a simple internal space with respect to the input iid or type I.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.filter-Union{Tuple{C}, Tuple{SimpleIID, Type{C}}} where C<:CompositeInternal","page":"Degrees of freedom","title":"Base.filter","text":"filter(iid::SimpleIID, ::Type{C}) where {C<:CompositeInternal}\nfilter(::Type{I}, ::Type{C}) where {I<:SimpleIID, C<:CompositeInternal}\n\nFilter the type of a composite internal space and select those that matches I or the type of iid.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.filter-Union{Tuple{T}, Tuple{SimpleIID, Type{T}}} where T<:SimpleInternal","page":"Degrees of freedom","title":"Base.filter","text":"filter(iid::SimpleIID, ::Type{T}) where {T<:SimpleInternal}\nfilter(::Type{I}, ::Type{T}) where {I<:SimpleIID, T<:SimpleInternal}\n\nFilter the type of a simple internal space with respect to the input iid or type I.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.getindex-Tuple{Table, OperatorUnit}","page":"Degrees of freedom","title":"Base.getindex","text":"getindex(table::Table, operatorunit::OperatorUnit) -> Int\n\nInquiry the sequence of an operator unit.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.haskey-Tuple{Table, OperatorUnit}","page":"Degrees of freedom","title":"Base.haskey","text":"haskey(table::Table, operatorunit::OperatorUnit) -> Bool\nhaskey(table::Table, operatorunits::ID{OperatorUnit}) -> Tuple{Vararg{Bool}}\n\nJudge whether a single operator unit or a set of operator units have been assigned with sequences in table.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.keys-Tuple{Boundary}","page":"Degrees of freedom","title":"Base.keys","text":"keys(bound::Boundary) -> Tuple{Vararg{Symbol}}\nkeys(::Type{<:Boundary{Names}}) where Names -> Names\n\nGet the names of the boundary parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.keys-Union{Tuple{OperatorUnitToTuple{Fields}}, Tuple{Fields}} where Fields","page":"Degrees of freedom","title":"Base.keys","text":"keys(::OperatorUnitToTuple{Fields}) where Fields -> Fields\nkeys(::Type{<:OperatorUnitToTuple{Fields}}) where Fields -> Fields\n\nGet the names of the selected fields.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.match-Tuple{SimpleIID, SimpleInternal}","page":"Degrees of freedom","title":"Base.match","text":"match(iid::SimpleIID, i::SimpleInternal) -> Bool\nmatch(::Type{I}, ::Type{SI}) where {I<:SimpleIID, SI<:SimpleInternal}\n\nJudge whether a simple iid or a simple iid type matches a simple internal space or a simple internal space type.\n\nHere, \"match\" means that the eltype of the simple internal space has the same type name with the simple iid.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.match-Union{Tuple{RS}, Tuple{Constraint{RS, N} where N, Tuple{Index, Vararg{Index}}}} where RS","page":"Degrees of freedom","title":"Base.match","text":"match(constraint::Constraint, indexes::Tuple{Vararg{Index}}) -> Bool\n\nJudge whether a composite iid fulfills a constraint.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.merge!-Tuple{Boundary, Boundary}","page":"Degrees of freedom","title":"Base.merge!","text":"merge!(bound::Boundary, another::Boundary) -> typeof(bound)\n\nMerge the values and vectors of the twisted boundary condition from another one.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.one-Tuple{Term}","page":"Degrees of freedom","title":"Base.one","text":"one(term::Term) -> Term\n\nGet a unit term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.replace-Tuple{Boundary}","page":"Degrees of freedom","title":"Base.replace","text":"replace(bound::Boundary; values=bound.values, vectors=bound.vectors) -> Boundary\n\nReplace the values or vectors of a twisted boundary condition and get the new one.\n\nnote: Note\nThe plain boundary condition keeps plain even when replaced with new values or new vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.replace-Tuple{Term}","page":"Degrees of freedom","title":"Base.replace","text":"replace(term::Term; kwargs...) -> Term\n\nReplace some attributes of a term with key word arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.repr-Tuple{Term, Bond, Hilbert}","page":"Degrees of freedom","title":"Base.repr","text":"repr(term::Term, bond::Bond, hilbert::Hilbert) -> String\n\nGet the repr representation of a term on a bond with a given Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.union-Tuple{Vararg{Table}}","page":"Degrees of freedom","title":"Base.union","text":"union(tables::Table...) -> Table\n\nUnite several operator unit vs. sequence tables.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.valtype-Tuple{Term}","page":"Degrees of freedom","title":"Base.valtype","text":"valtype(term::Term)\nvaltype(::Type{<:Term)\n\nGet the value type of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.valtype-Union{Tuple{I}, Tuple{M}, Tuple{Type{M}, Type{I}}} where {M<:OperatorUnitToTuple, I<:Index}","page":"Degrees of freedom","title":"Base.valtype","text":"valtype(::Type{<:OperatorUnitToTuple}, ::Type{<:Index})\n\nGet the valtype of applying an OperatorUnitToTuple rule to an Index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.zero-Tuple{Term}","page":"Degrees of freedom","title":"Base.zero","text":"zero(term::Term) -> Term\n\nGet a zero term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LaTeXStrings.latexstring-Tuple{Coupling}","page":"Degrees of freedom","title":"LaTeXStrings.latexstring","text":"latexstring(coupling::Coupling) -> String\n\nConvert a Coupling to the latex format.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{CompositeIID}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(ciid::CompositeIID) -> Int\nrank(::Type{<:CompositeIID{T}}) where {T<:Tuple{Vararg{SimpleIID}}} -> Int\n\nGet the number of simple iids in a composite iid.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{CompositeInternal}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(ci::CompositeInternal) -> Int\nrank(::Type{<:CompositeInternal{K, T}}) where {K, T<:Tuple{Vararg{SimpleInternal}}} -> Int\n\nGet the number of simple internal spaces in a composite internal space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{Constraint, Integer}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(constraint::Constraint, i::Integer) -> Int\nrank(::Type{<:Constraint{RS}}, i::Integer) where RS -> Int\n\nGet the rank of the ith homogenous segment of the coupling indexes that a constraint can apply.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{Constraint}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(constraint::Constraint) -> Int\nrank(::Type{<:Constraint{RS}}) where RS -> Int\n\nGet the rank of the coupling indexes that a constraint can apply.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{Term}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(term::Term) -> Int\nrank(::Type{<:Term) -> Int\n\nGet the rank of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:⊕-Tuple{SimpleInternal, SimpleInternal}","page":"Degrees of freedom","title":"QuantumLattices.:⊕","text":"⊕(i₁::SimpleInternal, i₂::SimpleInternal) -> CompositeInternal{:⊕}\n⊕(i::SimpleInternal, ci::CompositeInternal{:⊕}) -> CompositeInternal{:⊕}\n⊕(ci::CompositeInternal{:⊕}, i::SimpleInternal) -> CompositeInternal{:⊕}\n⊕(ci₁::CompositeInternal{:⊕}, ci₂::CompositeInternal{:⊕}) -> CompositeInternal{:⊕}\n\nDirect product between simple internal spaces and composite internal spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:⊗-Tuple{SimpleIID, SimpleIID}","page":"Degrees of freedom","title":"QuantumLattices.:⊗","text":"⊗(iid₁::SimpleIID, iid₂::SimpleIID) -> CompositeIID\n⊗(iid::SimpleIID, ciid::CompositeIID) -> CompositeIID\n⊗(ciid::CompositeIID, iid::SimpleIID) -> CompositeIID\n⊗(ciid₁::CompositeIID, ciid₂::CompositeIID) -> CompositeIID\n\nDirect product between simple iids and composite iids.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:⊗-Tuple{SimpleInternal, SimpleInternal}","page":"Degrees of freedom","title":"QuantumLattices.:⊗","text":"⊗(i₁::SimpleInternal, i₂::SimpleInternal) -> CompositeInternal{:⊗}\n⊗(i::SimpleInternal, ci::CompositeInternal{:⊗}) -> CompositeInternal{:⊗}\n⊗(ci::CompositeInternal{:⊗}, i::SimpleInternal) -> CompositeInternal{:⊗}\n⊗(ci₁::CompositeInternal{:⊗}, ci₂::CompositeInternal{:⊗}) -> CompositeInternal{:⊗}\n\nDirect product between simple internal spaces and composite internal spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.iidtype-Tuple{CompositeIID, Integer}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.iidtype","text":"iidtype(ciid::CompositeIID, i::Integer)\niidtype(::Type{<:CompositeIID{T}}, i::Integer) where {T<:Tuple{Vararg{SimpleIID}}}\n\nGet the type of the ith simple iid in a composite iid.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.iidtype-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.iidtype","text":"iidtype(index::Index)\niidtype(::Type{I}) where {I<:Index}\n\nGet the type of the internal part of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.indextype-Tuple{QuantumLattices.DegreesOfFreedom.AbstractCompositeIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.indextype","text":"indextype(::AbstractCompositeIndex)\nindextype(::Type{<:AbstractCompositeIndex})\n\nGet the index type of a composite index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.indextype-Tuple{Type{<:SimpleInternal}, Type{<:Point}, Val}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.indextype","text":"indextype(I::Type{<:SimpleInternal}, P::Type{<:Point}, ::Val)\n\nGet the compatible composite index type based on the information of its internal part.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.ismodulatable-Tuple{Term}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.ismodulatable","text":"ismodulatable(term::Term) -> Bool\nismodulatable(::Type{<:Term}) -> Bool\n\nJudge whether a term could be modulated by its modulate function.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.plain","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.plain","text":"plain\n\nPlain boundary condition without any twist.\n\n\n\n\n\n","category":"function"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.sitestructure-Union{Tuple{termrank}, Tuple{Val, Val{termrank}, Integer}} where termrank","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.sitestructure","text":"sitestructure(::Val{termkind}, ::Val{termrank}, bondlength::Integer) where {termkind, termrank} -> NTuple{termrank, Int}\n\nGet the site structure, i.e. the acting centers of the coupling on a bond, of a certain kind of term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.statistics-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.statistics","text":"statistics(index::Index) -> Symbol\nstatistics(::Type{<:Index{I}}) where {I<:SimpleIID} -> Symbol\n\nGet the statistics of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.statistics-Tuple{QuantumLattices.DegreesOfFreedom.AbstractCompositeIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.statistics","text":"statistics(index::AbstractCompositeIndex) -> Symbol\nstatistics(::Type{<:AbstractCompositeIndex{I}}) where {I<:Index} -> Symbol\n\nGet the statistics of a composite operator id.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.statistics-Tuple{SimpleInternal}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.statistics","text":"statistics(i::SimpleInternal) -> Symbol\nstatistics(::Type{<:SimpleInternal{I}}) where {I<:SimpleIID} -> Symbol\n\nGet the statistics of a simple internal space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.optype-Union{Tuple{B}, Tuple{H}, Tuple{T}, Tuple{Type{T}, Type{H}, Type{B}}} where {T<:Term, H<:Hilbert, B<:Bond}","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.optype","text":"optype(::Type{T}, ::Type{H}, ::Type{B}) where {T<:Term, H<:Hilbert, B<:Bond}\n\nGet the compatible Operator type from the type of a term, a Hilbert space and a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.script-Tuple{Val{:integercoordinate}, CompositeIndex}","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{:integercoordinate}, index::CompositeIndex; vectors, kwargs...)\n\nGet the integral script of the icoordinate of an composite index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.script-Tuple{Val{:rcoordinate}, CompositeIndex}","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{:rcoordinate}, index::CompositeIndex; kwargs...) -> String\nscript(::Val{:icoordinate}, index::CompositeIndex; kwargs...) -> String\n\nGet the rcoordinate/icoordinate script of a composite index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.script-Tuple{Val{:site}, Index}","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{:site}, index::Index; kwargs...) -> String\nscript(attr::Val, index::Index; kwargs...) -> String\n\nGet the required script of a spin index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.script-Union{Tuple{attr}, Tuple{Val{attr}, CompositeIndex}} where attr","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{attr}, index::CompositeIndex; kwargs...) where attr\n\nGet the attr script of an index, which is contained in its index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.Spatials.icoordinate-Tuple{Operator{<:Number, <:Tuple{Vararg{CompositeIndex, N}} where N}}","page":"Degrees of freedom","title":"QuantumLattices.Spatials.icoordinate","text":"icoordinate(opt::Operator{<:Number, <:ID{CompositeIndex}}) -> SVector\n\nGet the whole icoordinate of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.Spatials.rcoordinate-Tuple{Operator{<:Number, <:Tuple{Vararg{CompositeIndex, N}} where N}}","page":"Degrees of freedom","title":"QuantumLattices.Spatials.rcoordinate","text":"rcoordinate(opt::Operator{<:Number, <:ID{CompositeIndex}}) -> SVector\n\nGet the whole rcoordinate of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.expand!-Tuple{Operators, Term, Bond, Hilbert}","page":"Degrees of freedom","title":"QuantumLattices.expand!","text":"expand!(operators::Operators, term::Term, bond::Bond, hilbert::Hilbert; half::Bool=false) -> Operators\nexpand!(operators::Operators, term::Term, bonds, hilbert::Hilbert; half::Bool=false) -> Operators\n\nExpand the operators of a term on a bond/set-of-bonds with a given Hilbert space.\n\nThe half parameter determines the behavior of generating operators, which falls into the following two categories\n\ntrue: \"Hermitian half\" of the generated operators\nfalse: \"Hermitian whole\" of the generated operators\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.expand-Tuple{SimpleIID, SimpleInternal}","page":"Degrees of freedom","title":"QuantumLattices.expand","text":"expand(iid::SimpleIID, internal::SimpleInternal) -> IIDSpace\nexpand(iids::NTuple{N, SimpleIID}, internals::NTuple{N, SimpleInternal}) where N -> IIDSpace\n\nGet the space expanded by a set of \"labeled\" iids.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.expand-Tuple{Term, Bond, Hilbert}","page":"Degrees of freedom","title":"QuantumLattices.expand","text":"expand(term::Term, bond::Bond, hilbert::Hilbert; half::Bool=false) -> Operators\nexpand(term::Term, bonds, hilbert::Hilbert; half::Bool=false) -> Operators\n\nExpand the operators of a term on a bond/set-of-bonds with a given Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.expand-Union{Tuple{termkind}, Tuple{Val{termkind}, Coupling, Bond, Hilbert}} where termkind","page":"Degrees of freedom","title":"QuantumLattices.expand","text":"expand(::Val{termkind}, coupling::Coupling, bond::Bond, hilbert::Hilbert) where termkind\n\nExpand a coupling with the given bond and Hilbert space of a certain kind of term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.id-Tuple{Term}","page":"Degrees of freedom","title":"QuantumLattices.id","text":"id(term::Term) -> Symbol\nid(::Type{<:Term) -> Symbol\n\nGet the id of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.kind-Tuple{Term}","page":"Degrees of freedom","title":"QuantumLattices.kind","text":"kind(term::Term) -> Symbol\nkind(::Type{<:Term) -> Symbol\n\nGet the kind of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.reset!-Tuple{Table, AbstractVector{<:OperatorUnit}}","page":"Degrees of freedom","title":"QuantumLattices.reset!","text":"reset!(table::Table, operatorunits::AbstractVector{<:OperatorUnit}) -> Table\n\nReset a table by a new set of operatorunits.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.reset!-Tuple{Table, Hilbert}","page":"Degrees of freedom","title":"QuantumLattices.reset!","text":"reset!(table::Table, hilbert::Hilbert) -> Table\n\nReset a table by a Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.update!-Tuple{Boundary}","page":"Degrees of freedom","title":"QuantumLattices.update!","text":"update!(bound::Boundary; parameters...) -> Boundary\n\nUpdate the values of the boundary twisted phase.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.update!-Tuple{Term, Vararg{Any}}","page":"Degrees of freedom","title":"QuantumLattices.update!","text":"update!(term::Term, args...; kwargs...) -> Term\n\nUpdate the value of a term by its modulate function.\n\n\n\n\n\n","category":"method"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = QuantumLattices","category":"page"},{"location":"unitcell description framework/Introduction/#UnitcellDescriptionIntroduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"A quantum lattice system can be completely described based on its unitcell. Basically, this description should contain three types of information:","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"the spatial information, such as the coordinates of the points contained in the unitcell;\nthe internal degrees of freedom, such as the local algebra acting on the local Hilbert space at each point;\nthe couplings among different degrees of freedom, such as the terms present in the Hamiltonian.","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"In theory, as long as the above information is told, one could easily write down the operator representation of the Hamiltonian of the system. For example, in the phrase \"the single orbital electronic Hubbard model with only nearest neighbor hopping on a one dimensional lattice with only two sites\", \"one dimensional lattice with only two sites\" is the spatial information, \"single orbital electronic\" defines the local Hilbert space and thus the local algebra, and \"Hubbard model with only nearest neighbor hopping\" describes the terms present in the Hamiltonian. From this phrase, we also know that the Hamiltonian of the system is","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"H=tc^_1c_2+tc^_2c_1+tc^_1c_2+tc^_2c_1+Uc^_1c_1c^_1c_1+Uc^_2c_2c^_2c_2","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"where t is the hopping amplitude， U is the Hubbard interaction strength and the electronic creation/annihilation operator c^dagger_isigmac_isigma carries a site index i (i=1 2) and a spin index sigma (sigma=uparrow downarrow). Actually, the unitcell description framework follows exactly after the above train of thought. For example, the aforementioned system can be constructed by the following codes:","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"using QuantumLattices\nusing SymPy: Sym, symbols\n\n# define the unitcell\nlattice = Lattice([zero(Sym)], [one(Sym)])\n\n# define the internal degrees of freedom, i.e., the single-orbital spin-1/2 fermionic algebra\nhilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice))\n\n# define the terms\nt = Hopping(:t, symbols(\"t\", real=true), 1)\nU = Hubbard(:U, symbols(\"U\", real=true))\n\n# get the Hamiltonian\noperators = expand(OperatorGenerator((t, U), bonds(lattice, 1), hilbert))","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"The last line displays all the generated operators in the Hamiltonian in the LaTeX format. Here, in the subscript of the electronic annihilation/creation operator, an extra orbital index is also displayed.","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"In the following pages listed below, we will explain in detail how these codes work. Firstly, in the page of Spatial information of a unitcell, we will introduce the construction of the unitcell as well as the ways to obtain the bonds at different orders of nearest neighbors. Secondly, in the page of Internal degrees of freedom, we will explain the hierarchy of the internal degrees of freedom and discuss how they are organized for different categories of quantum systems. Thirdly, in the page of Couplings among different degrees of freedom, we will discuss the ways to specify the terms present in the Hamiltonian. Finally, in the page of Generator of operators, we will show how to combine all to get the operator representation of the Hamiltonian of a quantum lattice system. For more sophisticated information, the manual of this package can also be referred.","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"SpatialInfoOfAUnitcell.md\",\n        \"InternalDegreesOfFreedom.md\",\n        \"CouplingsAmongDifferentDegreesOfFreedom.md\",\n        \"GeneratorOfOperators.md\",\n        ]\nDepth = 2","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"CurrentModule = QuantumLattices\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Spatial-information-of-a-unitcell","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"The first step toward the complete description of a quantum lattice system is the understanding of the spatial information of a unitcell.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Construction-of-a-lattice","page":"Spatial information of a unitcell","title":"Construction of a lattice","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"In general, a lattice has translation symmetry. This symmetry introduces an equivalence relation for the points in a lattice when they can be translated into each other by multiple times of the translation vectors. This observation sets the mathematical foundation of the unitcell construction. As a result, it is enough for a lattice to restrict all points within the origin unitcell together with the translation vectors.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Lattice is the simplest structure to encode all the spatial information within the origin unitcell. Apparently, it must contain all the coordinates of the points in the origin unitcell and the translation vectors of the lattice. It also appears to be useful to associate a lattice with a name. Therefore, in this package, Lattice has three attributes:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"name::Symbol: the name of the lattice\ncoordinates::Matrix{<:Number}: the coordinates of the points within the origin unitcell\nvectors::Vector{<:StaticArraysCore.SVector}: the translation vectors of the lattice","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Lattice can be constructed by offering the coordinates, with optional keyword arguments to specify its name and translation vectors:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> Lattice([0.0])\nLattice(lattice)\n  with 1 point:\n    [0.0]\n\njulia> Lattice((0.0, 0.0), (0.5, 0.5); vectors=[[1.0, 0.0], [0.0, 1.0]], name=:Square)\nLattice(Square)\n  with 2 points:\n    [0.0, 0.0]\n    [0.5, 0.5]\n  with 2 translation vectors:\n    [1.0, 0.0]\n    [0.0, 1.0]\n\njulia> Lattice(\n           (0.0, 0.0, 0.0);\n           name=:Cube,\n           vectors=[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n       )\nLattice(Cube)\n  with 1 point:\n    [0.0, 0.0, 0.0]\n  with 3 translation vectors:\n    [1.0, 0.0, 0.0]\n    [0.0, 1.0, 0.0]\n    [0.0, 0.0, 1.0]","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"The coordinates could be specified by vectors or tuples.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Iteration over a lattice will get the coordinates of the points in it:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice((0.0, 0.0), (0.5, 0.5); vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> length(lattice)\n2\n\njulia> [lattice[1], lattice[2]]\n2-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n [0.5, 0.5]\n\njulia> collect(lattice)\n2-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n [0.5, 0.5]","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"The reciprocal translation vectors of the dual lattice can be obtained by reciprocals:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice((0.0, 0.0); vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> reciprocals(lattice)\n2-element StaticArraysCore.SVector{2, StaticArraysCore.SVector{2, Float64}} with indices SOneTo(2):\n [6.283185307179586, -0.0]\n [-0.0, 6.283185307179586]","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Request-for-the-bonds-of-a-lattice","page":"Spatial information of a unitcell","title":"Request for the bonds of a lattice","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Before the introduction of how to obtain the bonds of a lattice, let's discuss more about the unitcell construction to clarify the logic behind the definitions of the Point type and the Bond type in this package.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Point","page":"Spatial information of a unitcell","title":"Point","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"With the translation symmetry, all points of a lattice are equivalent to those within the origin unitcell. However, it becomes complicated when the bonds are requested. The bonds inter different unitcells cannot be compressed into a single unitcell. Therefore, even in the unitcell construction framework, it turns out to be unavoidable to specify a point outside the origin unitcell, which requires extra information beyond a single coordinate if we want to remember which point it is equivalent to within the origin unitcell at the same time. In fact, it is customary in literature to express the coordinate mathbfR of a point in a lattice as mathbfR=mathbfR_i+mathbfr, where mathbfR_i is the integral coordinate of the unitcell the point belongs to and mathbfr is the relative displacement of the point in the unitcell. Apparently, any two of these three coordinates are complete to get the full information. In this package, we choose mathbfR and mathbfR_i as the complete set for a individual lattice point. Besides, we also associate a site index with a point for the fast lookup for its equivalence within the origin unitcell although it is redundant in theory. Thus, the Point defined in this package has three attributes as follows:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"site::Int: the site index of a point that specifies the equivalent point within the origin unitcell\nrcoordinate::StaticArraysCore.SVector: the real coordinate of the point (mathbfR)\nicoordinate::StaticArraysCore.SVector: the integral coordinate of the unitcell the point belongs to (mathbfR_i)","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"At the construction of a Point, rcoordinate and icoordinate can accept tuples or usual vectors as inputs, such as","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> Point(1, [0.0], [0.0])\nPoint(1, [0.0], [0.0])\n\njulia> Point(1, (1.5, 0.0), (1.0, 0.0))\nPoint(1, [1.5, 0.0], [1.0, 0.0])","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"icoordinate can be omitted, then it will be initialized by a zero StaticArraysCore.SVector:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> Point(1, [0.0, 0.5])\nPoint(1, [0.0, 0.5], [0.0, 0.0])","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Bond","page":"Spatial information of a unitcell","title":"Bond","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"A bond in the narrow sense consist of two points. However, in quantum lattice systems, it is common to refer to generic bonds with only one or more than two points. In addition, it is also convenient to associate a bond with a kind information, such as the order of the nearest neighbors of the bond. Thus, the Bond is defined as follows:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"kind: the kind information of a generic bond\npoints::Vector{<:Point}: the points a generic bond contains","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> Bond(Point(1, [0.0, 0.0], [0.0, 0.0])) # 1-point bond\nBond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))\n\njulia> Bond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(1, [1.0, 1.0], [1.0, 1.0])) # 2-point bond\nBond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(1, [1.0, 1.0], [1.0, 1.0]))\n\njulia> Bond(:plaquette, Point(1, [0.0, 0.0]), Point(2, [1.0, 0.0]), Point(3, [1.0, 1.0]), Point(4, [0.0, 1.0])) # generic bond with 4 points\nBond(:plaquette, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(2, [1.0, 0.0], [0.0, 0.0]), Point(3, [1.0, 1.0], [0.0, 0.0]), Point(4, [0.0, 1.0], [0.0, 0.0]))","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"It is noted that the kind attribute of a bond with only one point is set to be 0.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Iteration over a bond will get the points it contains:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> bond = Bond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(2, [1.0, 0.0], [0.0, 0.0]));\n\njulia> length(bond)\n2\n\njulia> [bond[1], bond[2]]\n2-element Vector{Point{2, Float64}}:\n Point(1, [0.0, 0.0], [0.0, 0.0])\n Point(2, [1.0, 0.0], [0.0, 0.0])\n\njulia> collect(bond)\n2-element Vector{Point{2, Float64}}:\n Point(1, [0.0, 0.0], [0.0, 0.0])\n Point(2, [1.0, 0.0], [0.0, 0.0])","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"The coordinate of a bond as a whole is also defined for those that only contain one or two points. The coordinate of a 1-point bond is defined to be the corresponding coordinate of this point, and the coordinate of a 2-point bond is defined to be the corresponding coordinate of the second point minus that of the first:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> bond1p = Bond(Point(1, [2.0], [1.0]));\n\njulia> rcoordinate(bond1p)\n1-element StaticArraysCore.SVector{1, Float64} with indices SOneTo(1):\n 2.0\n\njulia> icoordinate(bond1p)\n1-element StaticArraysCore.SVector{1, Float64} with indices SOneTo(1):\n 1.0\n\njulia> bond2p = Bond(1, Point(1, [1.0, 1.0], [1.0, 1.0]), Point(2, [0.5, 0.5], [0.0, 0.0]));\n\njulia> rcoordinate(bond2p)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n -0.5\n -0.5\n\njulia> icoordinate(bond2p)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n -1.0\n -1.0","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Generation-of-1-point-and-2-point-bonds-of-a-lattice","page":"Spatial information of a unitcell","title":"Generation of 1-point and 2-point bonds of a lattice","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"In this package, we provide the function bonds to get the 1-point and 2-point bonds of a lattice:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"bonds(lattice::Lattice, nneighbor::Int) -> Vector{<:Bond}\nbonds(lattice::Lattice, neighbors::Neighbors) -> Vector{<:Bond}","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"which is based on the KDTree type provided by the NearestNeighbors.jl package. In the first method, all the bonds up to the nneighborth nearest neighbors are returned, including the 1-point bonds:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> bonds(lattice, 2)\n5-element Vector{Bond{Int64, Point{2, Float64}}}:\n Bond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(1, Point(1, [0.0, -1.0], [0.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(1, Point(1, [-1.0, 0.0], [-1.0, 0.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"However, this method is not so efficient, as KDTree only searches the bonds with the lengths less than a value, and it does not know the bond lengths for each order of nearest neighbors. Such information must be computed as first. Therefore, in the second method, bonds can accept a new type, the Neighbors, as its second positional parameter to improve the efficiency, which could tell the program the information of the bond lengths in priori:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> bonds(lattice, Neighbors(0=>0.0, 1=>1.0, 2=>√2))\n5-element Vector{Bond{Int64, Point{2, Float64}}}:\n Bond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(1, Point(1, [0.0, -1.0], [0.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(1, Point(1, [-1.0, 0.0], [-1.0, 0.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Meanwhile, an instance of Neighbors could also serve as a filter of the generated bonds, which select those bonds with the given bond lengths:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> bonds(lattice, Neighbors(2=>√2))\n2-element Vector{Bond{Int64, Point{2, Float64}}}:\n Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"To obtain generic bonds containing more points, user are encouraged to implement their own bonds methods. Pull requests are welcomed.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Internal-degrees-of-freedom","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's move to the second step, the internal degrees of freedom.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Hierarchy-of-the-internal-degrees-of-freedom","page":"Internal degrees of freedom","title":"Hierarchy of the internal degrees of freedom","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"In general, a lattice Hamiltonian can be expressed by the generators of the algebra that acts on the Hilbert space of the system. For example for the complex fermionic (bosonic) system, the Hilbert space is the Fock space, and the lattice Hamiltonian can be expressed by the generators of the fermionic (bosonic) algebra, i.e., the the creation and annihilation operators c^dagger_alpha c_alpha left(b^dagger_alpha b_alpharight). For another example for the local spin-1/2 system, the Hilbert space is the otimes_alphalvertuparrowrangle lvertdownarrowrangle_alpha space, and the lattice Hamiltonian can be expressed by the generators of the SU(2) spin algebra, i.e., the spin operators S^x_alpha S^y_alpha S^z_alpha or S^+_alpha S^-_alpha S^z_alpha. In both examples, the subscript alpha denotes a complete set of indexes of the internal degrees of freedom of the quantum system. Therefore, the determination of the algebra acting on the system's Hilbert space and its corresponding generators lies at the center of the constructions of the operator representations of lattice Hamiltonians.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The global Hilbert space of a lattice system can be decomposed into the direct product of the local internal spaces \"living\" on individual points, leading to a similar decomposition of the global algebra into local ones. To incorporate with the unitcell construction of the lattice, an extra intermediate representation of the translation-equivalent internal degrees of freedom within the origin unitcell is also needed. Thus, from the microscopic to the macroscopic, we arrive at a three level hierarchy, namely the local-unitcell-global hierarchy, of the internal degrees of freedom.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the local or the individual-point level, the local algebra is represented by the type Internal, and a local generator of the local algebra is represented by the type IID. Both types are abstract types with their concrete subtypes to represent concrete local algebras and concrete local generators of different quantum lattice systems with different internal structures, respectively.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the unitcell level, the algebra of the system is represented by the type Hilbert, which defines the concrete local algebras point by point within the origin unitcell. Accordingly, the type Index, which combines a site index and an instance of IID, could specify a translation-equivalent generator within the origin unitcell.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the global or the whole-lattice level, we do not actually need a representation of the algebra of the system, but really do for the generators because we have to specify them outside the origin unitcell when the bond goes across the unitcell boundaries. The type CompositeIndex, which combines an instance of Index and the coordinates mathbfR and mathbfR_i of the underlying point, represents a generator at such a level.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The above discussions can be summarized by the following table, which also displays how the spatial part of a quantum lattice system is represented:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":" local (individual-point) level unitcell level global (whole-lattice) level\nspatial Point Lattice \nalgebra Internal and its concrete subtypes Hilbert \ngenerator IID and its concrete subtypes Index CompositeIndex","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Quantum-lattice-systems-with-different-internal-structures","page":"Internal degrees of freedom","title":"Quantum lattice systems with different internal structures","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"In this section, we will explain in detail for the common categories of quantum lattice systems implemented in this package about how their algebras and generators are organized according to the above three level hierarchy.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Canonical-complex-fermionic,-canonical-complex-bosonic-and-hard-core-bosonic-systems","page":"Internal degrees of freedom","title":"Canonical complex fermionic, canonical complex bosonic and hard-core bosonic systems","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Local-level:-Fock-and-FID","page":"Internal degrees of freedom","title":"Local level: Fock and FID","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Roughly speaking, these systems share similar internal structures of local Hilbert spaces termed as the Fock space where the generators of local algebras are the annihilation and creation operators. Besides the nambu index to distinguish whether it is an annihilation one or a creation one, such a generator usually adopts an orbital index and a spin index. Thus, the type FID<:IID, which specifies a certain local generator of a local Fock algebra, has the following attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"orbital::Int: the orbital index\nspin::Rational{Int}: the spin index, which must be a half integer\nnambu::Int: the nambu index, which must be 1(annihilation) or 2(creation).","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Correspondingly, the type Fock<:Internal, which specifies the local algebra acting on the local Fock space, has the following attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"norbital::Int: the number of allowed orbital indices\nnspin::Int: the number of allowed spin indices","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To distinguish whether the system is a fermionic one or a bosonic one, FID and Fock take a symbol :f(for fermionic) or :b(for bosonic) to be their first type parameters.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's see some examples.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"An FID instance can be initialized by giving all its three attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> FID{:f}(2, 1//2, 1)\nFID{:f}(2, 1//2, 1)\n\njulia> FID{:b}(2, 0, 1)\nFID{:b}(2, 0, 1)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The adjoint of an FID instance is also defined:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> FID{:f}(3, 3//2, 1)'\nFID{:f}(3, 3//2, 2)\n\njulia> FID{:b}(3, 3//2, 2)'\nFID{:b}(3, 3//2, 1)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Apparently, this operation is nothing but the \"Hermitian conjugate\".","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"A Fock instance can be initialized by giving all its attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Fock{:f}(1, 2)\n4-element Fock{:f}:\n FID{:f}(1, -1//2, 1)\n FID{:f}(1, 1//2, 1)\n FID{:f}(1, -1//2, 2)\n FID{:f}(1, 1//2, 2)\n\njulia> Fock{:b}(1, 1)\n2-element Fock{:b}:\n FID{:b}(1, 0, 1)\n FID{:b}(1, 0, 2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"As can be seen, a Fock instance behaves like a vector (because the parent type Internal is a subtype of AbstractVector), and its iteration just generates all the allowed FID instances on its associated spatial point:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> fck = Fock{:f}(2, 1);\n\njulia> fck |> typeof |> eltype\nFID{:f, Int64, Rational{Int64}, Int64}\n\njulia> fck |> length\n4\n\njulia> [fck[1], fck[2], fck[3], fck[4]]\n4-element Vector{FID{:f, Int64, Rational{Int64}, Int64}}:\n FID{:f}(1, 0, 1)\n FID{:f}(2, 0, 1)\n FID{:f}(1, 0, 2)\n FID{:f}(2, 0, 2)\n\njulia> fck |> collect\n4-element Vector{FID{:f, Int64, Rational{Int64}, Int64}}:\n FID{:f}(1, 0, 1)\n FID{:f}(2, 0, 1)\n FID{:f}(1, 0, 2)\n FID{:f}(2, 0, 2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"This is isomorphic to the mathematical fact that a local algebra is a vector space of the local generators.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Unitcell-level:-Hilbert-and-Index","page":"Internal degrees of freedom","title":"Unitcell level: Hilbert and Index","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To specify the Fock algebra at the unitcell level, Hilbert associate each point within the origin unitcell with an instance of Fock:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:f}(1, 2))\nHilbert{Fock{:f}} with 2 entries:\n  2 => Fock{:f}(norbital=1, nspin=2)\n  1 => Fock{:f}(norbital=1, nspin=2)\n\njulia> Hilbert(site=>Fock{:f}(2, 2) for site=1:2)\nHilbert{Fock{:f}} with 2 entries:\n  2 => Fock{:f}(norbital=2, nspin=2)\n  1 => Fock{:f}(norbital=2, nspin=2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"In general, at different sites, the local Fock algebra could be different:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Hilbert(site=>Fock{:f}(iseven(site) ? 2 : 1, 1) for site=1:2)\nHilbert{Fock{:f}} with 2 entries:\n  2 => Fock{:f}(norbital=2, nspin=1)\n  1 => Fock{:f}(norbital=1, nspin=1)\n\njulia> Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:b}(1, 2))\nHilbert{Fock} with 2 entries:\n  2 => Fock{:b}(norbital=1, nspin=2)\n  1 => Fock{:f}(norbital=1, nspin=2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Hilbert itself is a subtype of AbstractDict, the iteration over the keys gives the sites, and the iteration over the values gives the local algebras:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> hilbert = Hilbert(site=>Fock{:f}(iseven(site) ? 2 : 1, 1) for site=1:2);\n\njulia> collect(keys(hilbert))\n2-element Vector{Int64}:\n 2\n 1\n\njulia> collect(values(hilbert))\n2-element Vector{Fock{:f}}:\n Fock{:f}(norbital=2, nspin=1)\n Fock{:f}(norbital=1, nspin=1)\n\njulia> collect(hilbert)\n2-element Vector{Pair{Int64, Fock{:f}}}:\n 2 => Fock{:f}(norbital=2, nspin=1)\n 1 => Fock{:f}(norbital=1, nspin=1)\n\njulia> [hilbert[1], hilbert[2]]\n2-element Vector{Fock{:f}}:\n Fock{:f}(norbital=1, nspin=1)\n Fock{:f}(norbital=2, nspin=1)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To specify a translation-equivalent generator of the Fock algebra within the unitcell, Index just combines a site::Int attribute and an iid::FID attribute:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> index = Index(1, FID{:f}(1, -1//2, 2))\nIndex(1, FID{:f}(1, -1//2, 2))\n\njulia> index.site\n1\n\njulia> index.iid\nFID{:f}(1, -1//2, 2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The Hermitian conjugate of an Index is also defined:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Index(1, FID{:f}(1, -1//2, 2))'\nIndex(1, FID{:f}(1, -1//2, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Global-level:-CompositeIndex","page":"Internal degrees of freedom","title":"Global level: CompositeIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Since the local algebra of a quantum lattice system can be defined point by point, the global algebra can be completely compressed into the origin unitcell. However, the generator outside the origin unitcell cannot be avoided because we have to use them to compose the Hamiltonian on the bonds that goes across the unitcell boundaries. This situation is similar to the case of Lattice and Point. Therefore, we take a similar solution for the generators to that is adopted for the Point, i.e., we include the mathbfR coordinate (by the rcoordinate attribute) and the mathbfR_i coordinate (by the icoordinate attribute) of the underlying point together with the index::Index attribute in the CompositeIndex type to represent a generator that could be inside or outside the origin unitcell:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> index = CompositeIndex(Index(1, FID{:f}(1, 0, 2)), [0.5, 0.0], [0.0, 0.0])\nCompositeIndex(Index(1, FID{:f}(1, 0, 2)), [0.5, 0.0], [0.0, 0.0])\n\njulia> index.index\nIndex(1, FID{:f}(1, 0, 2))\n\njulia> index.rcoordinate\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 0.5\n 0.0\n\njulia> index.icoordinate\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 0.0\n 0.0\n\njulia> index' # the Hermitian conjugate of a CompositeIndex is also defined\nCompositeIndex(Index(1, FID{:f}(1, 0, 1)), [0.5, 0.0], [0.0, 0.0])","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#SU(2)-spin-systems","page":"Internal degrees of freedom","title":"SU(2) spin systems","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Local-level:-Spin-and-SID","page":"Internal degrees of freedom","title":"Local level: Spin and SID","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Spin<:Internal and SID<:IID are designed to deal with SU(2) spin systems at the local level.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Although spin systems are essentially bosonic, the commonly-used local Hilbert space is distinct from that of an usual bosonic system: it is the space spanned by the eigenstates of a local S^z operator rather than a Fock space. At the same time, a spin Hamiltonian is usually expressed by local spin operators, such as S^x, S^y, S^z, S^+ and S^-, instead of creation and annihilation operators. Therefore, it is convenient to define another set of concrete subtypes for spin systems.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To specify which one of the five S^x S^y S^z S^+ S^- a local spin operator is, the type SID has the following attribute:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"tag::Char: the tag, which must be 'x', 'y', 'z', '+' or '-'.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Correspondingly, the type Spin, which defines the local SU(2) spin algebra, does not need any attribute.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"For SID and Spin, it is also necessary to know what the total spin is, which is taken as their first type parameters and should be a half-integer or an integer.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's see examples.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"An SID instance can be initialized as follows","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> SID{3//2}('x')\nSID{3//2}('x')\n\njulia> SID{1//2}('z')\nSID{1//2}('z')\n\njulia> SID{1}('+')\nSID{1}('+')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The \"Hermitian conjugate\" of an SID instance can be obtained by the adjoint operation:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> SID{3//2}('x')'\nSID{3//2}('x')\n\njulia> SID{3//2}('y')'\nSID{3//2}('y')\n\njulia> SID{3//2}('z')'\nSID{3//2}('z')\n\njulia> SID{3//2}('+')'\nSID{3//2}('-')\n\njulia> SID{3//2}('-')'\nSID{3//2}('+')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The local spin space is determined by the total spin. The standard matrix representation of an SID instance on this local spin space can be obtained by the matrix function exported by this package:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> SID{1//2}('x') |> matrix\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.5+0.0im\n 0.5+0.0im  0.0+0.0im\n\njulia> SID{1//2}('y') |> matrix\n2×2 Matrix{ComplexF64}:\n 0.0-0.0im  -0.0+0.5im\n 0.0-0.5im   0.0-0.0im\n\njulia> SID{1//2}('z') |> matrix\n2×2 Matrix{ComplexF64}:\n -0.5+0.0im  -0.0+0.0im\n  0.0+0.0im   0.5+0.0im\n\njulia> SID{1//2}('+') |> matrix\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im\n\njulia> SID{1//2}('-') |> matrix\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"A Spin instance can be initialized as follows:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Spin{1}()\n5-element Spin{1}:\n SID{1}('x')\n SID{1}('y')\n SID{1}('z')\n SID{1}('+')\n SID{1}('-')\n\njulia> Spin{1//2}()\n5-element Spin{1//2}:\n SID{1//2}('x')\n SID{1//2}('y')\n SID{1//2}('z')\n SID{1//2}('+')\n SID{1//2}('-')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Similar to Fock, a Spin instance behaves like a vector whose iteration generates all the allowed SID instances on its associated spatial point:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> sp = Spin{1}();\n\njulia> sp |> typeof |> eltype\nSID{1, Char}\n\njulia> sp |> length\n5\n\njulia> [sp[1], sp[2], sp[3], sp[4], sp[5]]\n5-element Vector{SID{1, Char}}:\n SID{1}('x')\n SID{1}('y')\n SID{1}('z')\n SID{1}('+')\n SID{1}('-')\n\njulia> sp |> collect\n5-element Vector{SID{1, Char}}:\n SID{1}('x')\n SID{1}('y')\n SID{1}('z')\n SID{1}('+')\n SID{1}('-')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that a Spin instance generates SID instances not only limited to those corresponding to S^x, S^y, S^z, but also those to S^+ and S^- although the former three already forms a complete set of the generators of the local SU(2) spin algebra. This overcomplete feature is for the convenience to the construction of spin Hamiltonians.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex","page":"Internal degrees of freedom","title":"Unitcell and global levels: Hilbert, Index and CompositeIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the unitcell and global levels to construct the SU(2) spin algebra and spin generators, it is completely the same to that of the Fock algebra and Fock generators as long as we replace Fock and FID with Spin and SID, respectively:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Hilbert(1=>Spin{1//2}(), 2=>Spin{1}())\nHilbert{Spin} with 2 entries:\n  2 => Spin{1}()\n  1 => Spin{1//2}()\n\njulia> Index(1, SID{1//2}('+'))\nIndex(1, SID{1//2}('+'))\n\njulia> CompositeIndex(Index(1, SID{1//2}('-')), [0.5, 0.5], [1.0, 1.0])\nCompositeIndex(Index(1, SID{1//2}('-')), [0.5, 0.5], [1.0, 1.0])","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Phononic-systems","page":"Internal degrees of freedom","title":"Phononic systems","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Local-level:-Phonon-and-PID","page":"Internal degrees of freedom","title":"Local level: Phonon and PID","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Phononic systems are also bosonic systems. However, the canonical creation and annihilation operators of phonons depends on the eigenvalues and eigenvectors of the dynamical matrix, making them difficult to be defined locally at each point. Instead, we resort to the momentum (mathbfp) and displacement (mathbfu) operators of lattice vibrations as the generators, which can be easily defined locally. The type PID<:IID could specify such a local generator, which has the following attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"tag::Char: the tag, which must be either 'p' or 'u', to specify whether it is the momentum or the displacement operator, respectively\ndirection::Char: the direction, which must be one of 'x', 'y' and 'z', to indicate which spatial directional component of the generator it is","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Correspondingly, the type Phonon<:Internal, which defines the local mathbfu mathbfp algebra of the lattice vibrations, has the following attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"ndirection::Int: the spatial dimension of the lattice vibrations, which must be 1, 2, or 3","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's see examples:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> PID('u', 'x')\nPID('u', 'x')\n\njulia> PID('p', 'x')\nPID('p', 'x')\n\njulia> Phonon(1) # one-dimensional lattice vibration only has the x component\n2-element Phonon:\n PID('u', 'x')\n PID('p', 'x')\n\njulia> Phonon(2) # two-dimensional lattice vibration only has the x and y components\n4-element Phonon:\n PID('u', 'x')\n PID('p', 'x')\n PID('u', 'y')\n PID('p', 'y')\n\njulia> Phonon(3) # three-dimensional lattice vibration has the x, y and z components\n6-element Phonon:\n PID('u', 'x')\n PID('p', 'x')\n PID('u', 'y')\n PID('p', 'y')\n PID('u', 'z')\n PID('p', 'z')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Unitcell-and-global-levels:-Hilbert,-Index-and-CompositeIndex-2","page":"Internal degrees of freedom","title":"Unitcell and global levels: Hilbert, Index and CompositeIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the unitcell and global levels, lattice-vibration algebras and generators are the same to previous situations by Phonon and PID replaced with in the corresponding types:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Hilbert(site=>Phonon(2) for site=1:3)\nHilbert{Phonon} with 3 entries:\n  2 => Phonon(ndirection=2)\n  3 => Phonon(ndirection=2)\n  1 => Phonon(ndirection=2)\n\njulia> Index(1, PID('u', 'x'))\nIndex(1, PID('u', 'x'))\n\njulia> CompositeIndex(Index(1, PID('u', 'x')), [0.5, 0.5], [1.0, 1.0])\nCompositeIndex(Index(1, PID('u', 'x')), [0.5, 0.5], [1.0, 1.0])","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Operator-and-Operators","page":"Internal degrees of freedom","title":"Operator and Operators","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now we arrive at the core types of this package, the Operator and Operators. They are defined to deal with the mathematical operations, i.e., the +/-/* operations between two elements of the algebra acting on the Hilbert space, and the scalar multiplication between an element of the algebra and a number. Specifically, an Operator represents a product of several generators of the algebra specified at any of the three levels along with a coefficient, and an Operators represents the sum of several instances of Operator.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Operator can be initialized by two ways:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operator(2, FID{:f}(1, -1//2, 2), FID{:f}(1, -1//2, 1), SID{1//2}('z'))\nOperator(2, FID{:f}(1, -1//2, 2), FID{:f}(1, -1//2, 1), SID{1//2}('z'))\n\njulia> 2 * Index(1, FID{:f}(1, -1//2, 2)) * Index(2, SID{1//2}('z'))\nOperator(2, Index(1, FID{:f}(1, -1//2, 2)), Index(2, SID{1//2}('z')))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that the number of the generators can be any natural number.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Although generators at different levels can be producted to make an Operator, it is not recommended to do so because the logic will be muddled:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operator(\n           2,\n           FID{:f}(1, 0, 2),\n           CompositeIndex(Index(2, FID{:f}(1, 0, 1)), [0.0], [0.0])\n       ) # never do this !!!\nOperator(2, FID{:f}(1, 0, 2), CompositeIndex(Index(2, FID{:f}(1, 0, 1)), [0.0], [0.0]))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Operator can be iterated and indexed by integers, which will give the corresponding generators in the product:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> op = Operator(2, FID{:f}(1, 1//2, 2), FID{:f}(1, 1//2, 1));\n\njulia> length(op)\n2\n\njulia> [op[1], op[2]]\n2-element Vector{FID{:f, Int64, Rational{Int64}, Int64}}:\n FID{:f}(1, 1//2, 2)\n FID{:f}(1, 1//2, 1)\n\njulia> collect(op)\n2-element Vector{FID{:f, Int64, Rational{Int64}, Int64}}:\n FID{:f}(1, 1//2, 2)\n FID{:f}(1, 1//2, 1)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To get the coefficient of an Operator or all its individual generators as a whole, use the value and id function exported by this package, respectively:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> op = Operator(2, FID{:f}(1, 0, 2), FID{:f}(1, 0, 1));\n\njulia> value(op)\n2\n\njulia> id(op)\n(FID{:f}(1, 0, 2), FID{:f}(1, 0, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The product between two Operators, or the scalar multiplication between a number and an Operator is also an Operator:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operator(2, FID{:f}(1, 1//2, 2)) * Operator(3, FID{:f}(1, 1//2, 1))\nOperator(6, FID{:f}(1, 1//2, 2), FID{:f}(1, 1//2, 1))\n\njulia> 3 * Operator(2, FID{:f}(1, 1//2, 2))\nOperator(6, FID{:f}(1, 1//2, 2))\n\njulia> Operator(2, FID{:f}(1, 1//2, 2)) * 3\nOperator(6, FID{:f}(1, 1//2, 2))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The Hermitian conjugate of an Operator can be obtained by the adjoint operator:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> op = Operator(6, FID{:f}(2, 1//2, 2), FID{:f}(1, 1//2, 1));\n\njulia> op'\nOperator(6, FID{:f}(1, 1//2, 2), FID{:f}(2, 1//2, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"There also exists a special Operator, which only has the coefficient:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operator(2)\nOperator(2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Operators can be initialized by two ways:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operators(Operator(2, FID{:f}(1, 1//2, 1)), Operator(3, FID{:f}(1, 1//2, 2)))\nOperators with 2 Operator\n  Operator(3, FID{:f}(1, 1//2, 2))\n  Operator(2, FID{:f}(1, 1//2, 1))\n\njulia> Operator(2, FID{:f}(1, 1//2, 1)) - Operator(3, FID{:b}(1, 1//2, 2))\nOperators with 2 Operator\n  Operator(-3, FID{:b}(1, 1//2, 2))\n  Operator(2, FID{:f}(1, 1//2, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Similar items are automatically merged during the construction of Operators:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operators(Operator(2, FID{:f}(1, 1//2, 1)), Operator(3, FID{:f}(1, 1//2, 1)))\nOperators with 1 Operator\n  Operator(5, FID{:f}(1, 1//2, 1))\n\njulia> Operator(2, FID{:f}(1, 1//2, 1)) + Operator(3, FID{:f}(1, 1//2, 1))\nOperators with 1 Operator\n  Operator(5, FID{:f}(1, 1//2, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The multiplication between two Operatorses, or between an Operators and an Operator, or between a number and an Operators are defined:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ops = Operator(2, FID{:f}(1, 1//2, 1)) + Operator(3, FID{:f}(1, 1//2, 2));\n\njulia> op = Operator(2, FID{:f}(2, 1//2, 1));\n\njulia> ops * op\nOperators with 2 Operator\n  Operator(6, FID{:f}(1, 1//2, 2), FID{:f}(2, 1//2, 1))\n  Operator(4, FID{:f}(1, 1//2, 1), FID{:f}(2, 1//2, 1))\n\njulia> op * ops\nOperators with 2 Operator\n  Operator(4, FID{:f}(2, 1//2, 1), FID{:f}(1, 1//2, 1))\n  Operator(6, FID{:f}(2, 1//2, 1), FID{:f}(1, 1//2, 2))\n\njulia> another = Operator(2, FID{:f}(1, 1//2, 1)) + Operator(3, FID{:f}(1, 1//2, 2));\n\njulia> ops * another \nOperators with 4 Operator\n  Operator(6, FID{:f}(1, 1//2, 1), FID{:f}(1, 1//2, 2))\n  Operator(6, FID{:f}(1, 1//2, 2), FID{:f}(1, 1//2, 1))\n  Operator(9, FID{:f}(1, 1//2, 2), FID{:f}(1, 1//2, 2))\n  Operator(4, FID{:f}(1, 1//2, 1), FID{:f}(1, 1//2, 1))\n\njulia> 2 * ops\nOperators with 2 Operator\n  Operator(6, FID{:f}(1, 1//2, 2))\n  Operator(4, FID{:f}(1, 1//2, 1))\n\njulia> ops * 2\nOperators with 2 Operator\n  Operator(6, FID{:f}(1, 1//2, 2))\n  Operator(4, FID{:f}(1, 1//2, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that in the result, the distributive law automatically applies.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"As is usual, the Hermitian conjugate of an Operators can be obtained by the adjoint operator:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> op₁ = Operator(6, FID{:f}(1, 1//2, 2), FID{:f}(2, 1//2, 1));\n\njulia> op₂ = Operator(4, FID{:f}(1, 1//2, 1), FID{:f}(2, 1//2, 1));\n\njulia> ops = op₁ + op₂;\n\njulia> ops'\nOperators with 2 Operator\n  Operator(4, FID{:f}(2, 1//2, 2), FID{:f}(1, 1//2, 2))\n  Operator(6, FID{:f}(2, 1//2, 2), FID{:f}(1, 1//2, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Operators can be iterated, but cannot be indexed:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ops = Operator(2, FID{:f}(1, 1//2, 1)) + Operator(3, FID{:f}(1, 1//2, 2));\n\njulia> collect(ops)\n2-element Vector{Operator{Int64, Tuple{FID{:f, Int64, Rational{Int64}, Int64}}}}:\n Operator(3, FID{:f}(1, 1//2, 2))\n Operator(2, FID{:f}(1, 1//2, 1))\n\njulia> ops[1]\nERROR: MethodError: no method matching getindex(::Operators{Operator{Int64, Tuple{FID{:f, Int64, Rational{Int64}, Int64}}}, Tuple{FID{:f, Int64, Rational{Int64}, Int64}}}, ::Int64)\n[...]","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The different behaviors between Operator and Operators when they are indexed result from their underlying implementations: Operator is something like a tuple while Operators is something like a dictionary. Do not ask why not to implement them based on expression trees. If you have to ask, then the answer will be the authors of the package don't know how. So if you are not satisfied with this implementation, feel free to post a pull request.","category":"page"},{"location":"advanced topics/BoundaryConditions/","page":"Boundary conditions","title":"Boundary conditions","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"advanced topics/BoundaryConditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"CurrentModule = QuantumLattices.QuantumOperators","category":"page"},{"location":"man/QuantumOperators/#Quantum-operators","page":"Quantum operators","title":"Quantum operators","text":"","category":"section"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"Quantum operators form an algebra over a field, which are vector spaces with a bilinear operation (often called the \"multiplication\") between vectors defined.","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"With the help of the structure constants of the algebra, the result of the bilinear operation between any arbitrary two vectors can be expressed by a sum of individual ones. Therefore, in principle, an algebra can be represented by the complete basis set of its corresponding vector space and a rank-3 tensor encapsulating its structure constants. It is noted that the \"bilinear operation\" is not restricted to the usual multiplication. For example, it is the commutator, which is a composition of the usual multiplication and subtraction (for any A and B, the commutator [A, B] is defined as [A, B]≝AB-BA) that serves as the bilinear operator for Lie algebras.","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"In general, there are three basic operations on quantum operators, i.e. the scalar multiplication between a scalar and a quantum operator, the usual addition and the usual multiplication between quantum operators. Other complicated operations can be composed from these basic ones. These basic operations are implemented in this module.","category":"page"},{"location":"man/QuantumOperators/#OperatorUnit","page":"Quantum operators","title":"OperatorUnit","text":"","category":"section"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"OperatorUnit is the building block of quantum operators, which specifies the basis of the vector space of the corresponding algebra.","category":"page"},{"location":"man/QuantumOperators/#OperatorProd-and-OperatorSum","page":"Quantum operators","title":"OperatorProd and OperatorSum","text":"","category":"section"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"OperatorProd defines the product operator as an entity of basis quantum operators while OperatorSum defines the summation as an entity of OperatorProds. Both of them are subtypes of QuantumOperator, which is the abstract type for all quantum operators.","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"An OperatorProd must have two predefined contents:","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"value::Number: the coefficient of the quantum operator\nid::ID: the id of the quantum operator","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"Arithmetic operations (+, -, *, /) between a scalar, an OperatorProd or an OperatorSum is defined. See Manual for details.","category":"page"},{"location":"man/QuantumOperators/#Manual","page":"Quantum operators","title":"Manual","text":"","category":"section"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"Modules = [QuantumOperators]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.ID","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.ID","text":"ID{U<:OperatorUnit, N}\n\nThe id of a composite quantum operator, which is an ordered set of operator units.\n\nType alias for NTuple{N, U} where {U<:OperatorUnit}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.ID-Tuple{Vararg{OperatorUnit}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.ID","text":"ID(id::OperatorUnit...)\nID(u::OperatorUnit, id::ID{OperatorUnit})\nID(id::ID{OperatorUnit}, u::OperatorUnit)\nID(id₁::ID{OperatorUnit}, id₂::ID{OperatorUnit})\n\nGet the id from operator units/ids.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.ID-Union{Tuple{M}, Tuple{N}, Tuple{U}, Tuple{Type{U}, Vararg{Tuple{Vararg{Any, N}}, M}}} where {U<:OperatorUnit, N, M}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.ID","text":"ID(::Type{U}, attrs::Vararg{NTuple{N}, M}) where {U<:OperatorUnit, N, M}\n\nGet the composite id from the components of singular ids.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Identity","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Identity","text":"Identity <: LinearTransformation\n\nThe identity transformation.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.LaTeX","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.LaTeX","text":"LaTeX{SP, SB}(body, spdelimiter::String=\", \", sbdelimiter::String=\", \"; options...) where {SP, SB}\n\nLaTeX string representation of quantum operators.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.LinearFunction","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.LinearFunction","text":"LinearFunction{F<:Function} <: LinearTransformation\n\nWrapper a function to be a linear transformation.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.LinearTransformation","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.LinearTransformation","text":"LinearTransformation <: Transformation\n\nAbstract linear transformation on quantum operators.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.LinearTransformation-Tuple{OperatorSum}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.LinearTransformation","text":"(transformation::LinearTransformation)(ms::OperatorSum; kwargs...) -> OperatorSum\n\nGet the linear transformed quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.MatrixRepresentation","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.MatrixRepresentation","text":"MatrixRepresentation <: LinearTransformation\n\nThe matrix representation.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Numericalization","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Numericalization","text":"Numericalization{T<:Number} <: LinearTransformation\n\nThe numericalization transformation, which converts the value of a quantum operator to a number of type T.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Operator","text":"Operator{V<:Number, I<:ID{OperatorUnit}} <: OperatorProd{V, I}\n\nOperator.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorPack","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorPack","text":"OperatorPack{V, I<:Tuple} <: QuantumOperator\n\nThe entity that represent the pack of a number and several quantum units.\n\nBasically, a concrete subtype should contain two predefined contents:\n\nvalue::V: the coefficient of the pack\nid::I: the total id of the pack\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorProd","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorProd","text":"OperatorProd{V, I<:ID{OperatorUnit}} <: OperatorPack{V, I}\n\nA special kind of OperatorPack, where the relation between the coefficient and quantum units could be viewed as product.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorSum","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorSum","text":"OperatorSum{M<:OperatorPack, I<:Tuple} <: QuantumOperator\n\nThe sum of OperatorPacks.\n\nSimilar items are automatically merged with the aid of the id system.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorSum-Tuple{Vararg{QuantumOperator}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorSum","text":"OperatorSum(ms)\nOperatorSum(ms::QuantumOperator...)\nOperatorSum{M}(ms) where {M<:OperatorPack}\nOperatorSum{M}(ms::QuantumOperator...) where {M<:OperatorPack}\n\nGet the sum of OperatorPacks.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorUnit","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorUnit","text":"OperatorUnit <: QuantumOperator\n\nAn operator unit is the irreducible symbolic unit to represent a quantum operator.\n\nIt plays the role of the symbols as in usual computer algebras while it can host internal structures, which is convenient for quantum operators in representative of the internal degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Operators","text":"Operators{O<:Operator, I<:ID{OperatorUnit}}\n\nA set of operators.\n\nType alias for OperatorSum{O<:Operator, I<:ID{OperatorUnit}}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators-Tuple{Vararg{Operator}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Operators","text":"Operators(opts::Operator...)\nOperators{M}(opts::Operator...)\n\nGet a set of operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Permutation","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Permutation","text":"Permutation{T} <: LinearTransformation\n\nThe permutation transformation.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Permutation-Tuple{OperatorProd}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Permutation","text":"(permutation::Permutation)(m::OperatorProd; kwargs...) -> OperatorSum\n\nPermute the operator units of an OperatorProd to the descending order according to the table contained in permutation.\n\nnote: Note\nTo use this function, the user must implement a method of permute, which computes the result of the permutation of two operator units:permute(u₁::OperatorUnit, u₂::OperatorUnit) -> Union{OperatorProd, OperatorSum}Here, u₁ and u₂ are two arbitrary operator units contained in id(m).\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.QuantumOperator","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.QuantumOperator","text":"QuantumOperator\n\nThe abstract type of any quantum operator.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.RankFilter","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.RankFilter","text":"RankFilter{R} <: LinearTransformation\n\nRank filter, which filters out the OperatorPack with a given rank R.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.TabledUnitSubstitution","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.TabledUnitSubstitution","text":"TabledUnitSubstitution{U<:OperatorUnit, S<:OperatorSum, T<:AbstractDict{U, S}} <: UnitSubstitution{U, S}\n\nA concrete \"unit substitution\" transformation, which stores every substitution of the old OperatorUnits in its table as a dictionary.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Transformation","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Transformation","text":"Transformation <: Function\n\nAbstract transformation on quantum operators.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.UnitSubstitution","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.UnitSubstitution","text":"UnitSubstitution{U<:OperatorUnit, S<:OperatorSum} <: LinearTransformation\n\nThe \"unit substitution\" transformation, which substitutes each OperatorUnit in the old quantum operators to a new expression represented by an OperatorSum.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.UnitSubstitution-Tuple{OperatorProd}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.UnitSubstitution","text":"(unitsubstitution::UnitSubstitution)(m::OperatorProd; kwargs...) -> OperatorSum\n\nSubstitute every OperatorUnit in an OperatorProd with a new OperatorSum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:*-Tuple{Number, OperatorUnit}","page":"Quantum operators","title":"Base.:*","text":"*(factor::Number, m::OperatorUnit) -> Operator\n*(m::OperatorUnit, factor::Number) -> Operator\n*(m₁::OperatorUnit, m₂::OperatorUnit) -> Operator\n*(factor::Number, m::OperatorPack) -> OperatorPack\n*(m::OperatorPack, factor::Number) -> OperatorPack\n*(m₁::OperatorPack, m₂::OperatorUnit) -> OperatorPack\n*(m₁::OperatorUnit, m₁::OperatorPack) -> OperatorPack\n*(m₁::OperatorPack, m₂::OperatorPack) -> OperatorPack\n*(factor::Number, ms::OperatorSum) -> OperatorSum\n*(ms::OperatorSum, factor::Number) -> OperatorSum\n*(m::OperatorPack, ms::OperatorSum) -> OperatorSum\n*(ms::OperatorSum, m::OperatorPack) -> OperatorSum\n*(ms₁::OperatorSum, ms₂::OperatorSum) -> OperatorSum\n\nOverloaded * between quantum operators or a quantum operator and a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:+-Tuple{QuantumOperator}","page":"Quantum operators","title":"Base.:+","text":"+(m::QuantumOperator) -> typeof(m)\n+(m₁::QuantumOperator, m₂::QuantumOperator) -> OperatorSum\n+(factor::Number, m::QuantumOperator) -> OperatorSum\n+(m::QuantumOperator, factor::Number) -> OperatorSum\n\nOverloaded + between quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:--Tuple{QuantumOperator}","page":"Quantum operators","title":"Base.:-","text":"-(m::QuantumOperator) -> QuantumOperator\n-(m₁::QuantumOperator, m₂::QuantumOperator) -> OperatorSum\n-(factor::Number, m::QuantumOperator) -> OperatorSum\n-(m::QuantumOperator, factor::Number) -> OperatorSum\n\nOverloaded - between quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:/-Tuple{QuantumOperator, Number}","page":"Quantum operators","title":"Base.:/","text":"/(m::QuantumOperator, factor::Number) -> QuantumOperator\n\nOverloaded / between a quantum operator and a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.://-Tuple{QuantumOperator, Number}","page":"Quantum operators","title":"Base.://","text":"//(m::QuantumOperator, factor::Number) -> QuantumOperator\n\nOverloaded // between a quantum operator and a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:^-Tuple{QuantumOperator, Integer}","page":"Quantum operators","title":"Base.:^","text":"^(m::QuantumOperator, n::Integer) -> QuantumOperator\n\nOverloaded ^ between a quantum operator and an integer.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.adjoint-Tuple{Operators}","page":"Quantum operators","title":"Base.adjoint","text":"adjoint(opts::Operators) -> Operators\n\nGet the adjoint of a set of operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.adjoint-Tuple{Operator}","page":"Quantum operators","title":"Base.adjoint","text":"adjoint(m::Operator) -> Operator\n\nGet the adjoint of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.adjoint-Tuple{Tuple{Vararg{OperatorUnit, N}} where N}","page":"Quantum operators","title":"Base.adjoint","text":"adjoint(id::ID{OperatorUnit}) -> ID\n\nGet the adjoint of an id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.convert-Union{Tuple{M}, Tuple{Type{M}, Number}} where M<:OperatorPack","page":"Quantum operators","title":"Base.convert","text":"convert(::Type{M}, m::Number) where {M<:OperatorPack}\nconvert(::Type{M}, m::OperatorPack) where {M<:OperatorPack}\n\nConvert a number to a quantum operator.\nConvert a quantum operator from one type to another.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.convert-Union{Tuple{M}, Tuple{Type{M}, OperatorUnit}} where M<:(Operator)","page":"Quantum operators","title":"Base.convert","text":"convert(::Type{M}, u::OperatorUnit) where {M<:Operator{<:Number, <:ID{OperatorUnit}}}\n\nConvert an operator unit to an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.getindex-Tuple{OperatorProd, Integer}","page":"Quantum operators","title":"Base.getindex","text":"getindex(m::OperatorProd, i::Integer) -> OperatorUnit\ngetindex(m::OperatorProd, slice) -> OperatorProd\n\nOverloaded [].\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.getproperty-Tuple{Tuple{Vararg{OperatorUnit, N}} where N, Symbol}","page":"Quantum operators","title":"Base.getproperty","text":"getproperty(id::ID{OperatorUnit}, name::Symbol)\n\nGet the property of a composite id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.isapprox-Tuple{OperatorPack, OperatorPack}","page":"Quantum operators","title":"Base.isapprox","text":"isapprox(m₁::OperatorPack, m₂::OperatorPack; atol::Real=atol, rtol::Real=rtol) -> Bool\n\nCompare two OperatorPacks and judge whether they are approximate to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.isapprox-Tuple{OperatorSum, OperatorSum}","page":"Quantum operators","title":"Base.isapprox","text":"isapprox(ms₁::OperatorSum, ms₂::OperatorSum; atol::Real=atol, rtol::Real=rtol) -> Bool\n\nCompare two OperatorSums and judge whether they are approximate to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.length-Tuple{OperatorProd}","page":"Quantum operators","title":"Base.length","text":"length(m::OperatorProd) -> Int\n\nGet the length of an OperatorProd.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.map!-Tuple{LinearTransformation, Any, OperatorSum}","page":"Quantum operators","title":"Base.map!","text":"map!(transformation::LinearTransformation, destination, ms::OperatorSum; kwargs...) -> typeof(destination)\n\nIn place map of an OperatorSum by a linear transformation.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.map!-Tuple{LinearTransformation, OperatorSum}","page":"Quantum operators","title":"Base.map!","text":"map!(transformation::LinearTransformation, ms::OperatorSum; kwargs...) -> typeof(ms)\n\nIn place map of an OperatorSum by a linear transformation.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.one-Union{Tuple{Type{M}}, Tuple{M}} where M<:OperatorPack","page":"Quantum operators","title":"Base.one","text":"one(::Type{M}) where M<:OperatorPack\none(m::OperatorPack)\n\nGet the identity quantum operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.propertynames-Tuple{Tuple{Vararg{OperatorUnit, N}} where N}","page":"Quantum operators","title":"Base.propertynames","text":"propertynames(::Type{I}) where I<:ID{OperatorUnit} -> Tuple{Vararg{Symbol}}\n\nGet the property names of a composite id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.replace-Tuple{OperatorPack, Any}","page":"Quantum operators","title":"Base.replace","text":"replace(m::OperatorPack, v) -> OperatorPack\n\nReplace the value of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.replace-Tuple{QuantumOperator}","page":"Quantum operators","title":"Base.replace","text":"replace(m::QuantumOperator; kwargs...) -> typeof(m)\n\nReturn a copy of a concrete QuantumOperator with some of the field values replaced by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.show-Tuple{IO, MIME{Symbol(\"text/latex\")}, QuantumOperator}","page":"Quantum operators","title":"Base.show","text":"show(io::IO, ::MIME\"text/latex\", m::QuantumOperator)\n\nShow a quantum operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.split-Tuple{OperatorProd}","page":"Quantum operators","title":"Base.split","text":"split(m::OperatorProd) -> Tuple{valtype(m), Vararg{OperatorUnit}}\n\nSplit an OperatorProd into the coefficient and a sequence of OperatorUnits.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.valtype-Tuple{OperatorPack}","page":"Quantum operators","title":"Base.valtype","text":"valtype(m::OperatorPack)\nvaltype(::Type{T}) where {T<:OperatorPack}\n\nGet the type of the value of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.zero-Tuple{OperatorSum}","page":"Quantum operators","title":"Base.zero","text":"zero(ms::OperatorSum) -> OperatorSum\nzero(::Type{MS}) where {MS<:OperatorSum} -> OperatorSum\n\nGet the zero sum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LaTeXStrings.latexstring-Tuple{OperatorPack}","page":"Quantum operators","title":"LaTeXStrings.latexstring","text":"latexstring(opt::OperatorPack) -> String\n\nGet the string representation of an operator in the LaTeX format.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LaTeXStrings.latexstring-Tuple{OperatorSum}","page":"Quantum operators","title":"LaTeXStrings.latexstring","text":"latexstring(opts::OperatorSum) -> String\n\nGet the string representation of a set of operators in the LaTeX format.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LaTeXStrings.latexstring-Tuple{OperatorUnit}","page":"Quantum operators","title":"LaTeXStrings.latexstring","text":"latexstring(u::OperatorUnit) -> String\n\nLaTeX string representation of an operator unit.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.:⋅-Tuple{Union{OperatorUnit, OperatorPack}, OperatorSum}","page":"Quantum operators","title":"LinearAlgebra.:⋅","text":"⋅(m::Union{OperatorUnit, OperatorPack}, ms::OperatorSum) -> OperatorSum\n⋅(ms::OperatorSum, m::Union{OperatorUnit, OperatorPack}) -> OperatorSum\n⋅(ms₁::OperatorSum, ms₂::OperatorSum) -> OperatorSum\n\nOverloaded ⋅ between quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.ishermitian-Tuple{Operators}","page":"Quantum operators","title":"LinearAlgebra.ishermitian","text":"ishermitian(opts::Operators) -> Bool\n\nJudge whether a set of operators as a whole is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.ishermitian-Tuple{Operator}","page":"Quantum operators","title":"LinearAlgebra.ishermitian","text":"ishermitian(m::Operator) -> Bool\n\nJudge whether an operator is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.ishermitian-Tuple{Tuple{Vararg{OperatorUnit, N}} where N}","page":"Quantum operators","title":"LinearAlgebra.ishermitian","text":"ishermitian(id::ID{OperatorUnit}) -> Bool\n\nJudge whether an id is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.mul!-Tuple{OperatorSum, Number}","page":"Quantum operators","title":"LinearAlgebra.mul!","text":"mul!(ms::OperatorSum, factor::Number) -> OperatorSum\n\nGet the in-place multiplication of an OperatorSum with a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.rank-Tuple{OperatorPack}","page":"Quantum operators","title":"LinearAlgebra.rank","text":"rank(m::OperatorPack) -> Int\nrank(::Type{M}) where {M<:OperatorPack} -> Int\n\nGet the rank of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.rank-Tuple{Tuple{Vararg{OperatorUnit, N}} where N}","page":"Quantum operators","title":"LinearAlgebra.rank","text":"rank(id::ID{OperatorUnit}) -> Int\nrank(::Type{<:ID{OperatorUnit}}) -> Any\nrank(::Type{<:ID{OperatorUnit, N}}) where N -> Int\n\nGet the rank of an id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.:⊗-Tuple{Union{OperatorUnit, OperatorPack}, OperatorSum}","page":"Quantum operators","title":"QuantumLattices.:⊗","text":"⊗(m::Union{OperatorUnit, OperatorPack}, ms::OperatorSum) -> OperatorSum\n⊗(ms::OperatorSum, m::Union{OperatorUnit, OperatorPack}) -> OperatorSum\n⊗(ms₁::OperatorSum, ms₂::OperatorSum) -> OperatorSum\n\nOverloaded ⊗ between quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.idtype-Tuple{OperatorPack}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.idtype","text":"idtype(m::OperatorPack)\nidtype(::Type{T}) where {T<:OperatorPack}\n\nThe type of the id of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.latexformat-Tuple{Type{<:OperatorUnit}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.latexformat","text":"latexformat(T::Type{<:OperatorUnit}) -> LaTeX\nlatexformat(T::Type{<:OperatorUnit}, l::LaTeX) -> LaTeX\n\nGet/Set the LaTeX format for a subtype of OperatorUnit.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.latexname-Tuple{Type{<:OperatorUnit}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.latexname","text":"latexname(T::Type{<:OperatorUnit}) -> Symbol\n\nGet the name of a type of OperatorUnit in the latex format lookups.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.matrix","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix\n\nGeneric matrix representation.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.optype-Tuple{QuantumOperator}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.optype","text":"optype(m::QuantumOperator)\noptype(::Type{<:QuantumOperator})\n\nGet the corresponding OperatorPack type of a generic quantum operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.script-Tuple{Val{:BD}, OperatorUnit, LaTeX}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.script","text":"script(::Val{:BD}, u::OperatorUnit, l::LaTeX) -> Any\nscript(::Val{:SP}, u::OperatorUnit, l::LaTeX) -> Tuple\nscript(::Val{:SB}, u::OperatorUnit, l::LaTeX) -> Tuple\n\nGet the body/superscript/subscript of the LaTeX string representation of an operator unit.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.sequence-Tuple{OperatorProd, Any}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.sequence","text":"sequence(m::OperatorProd, table) -> NTuple{rank(m), Int}\n\nGet the sequence of the id of a quantum operator according to a table.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.add!-Tuple{Any, LinearTransformation, QuantumOperator}","page":"Quantum operators","title":"QuantumLattices.add!","text":"add!(destination, transformation::LinearTransformation, op::QuantumOperator; kwargs...) -> typeof(destination)\n\nAdd the result of the linear transformation on a quantum operator to the destination.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.add!-Tuple{OperatorSum}","page":"Quantum operators","title":"QuantumLattices.add!","text":"add!(ms::OperatorSum) -> typeof(ms)\nadd!(ms::OperatorSum, m::Union{Number, OperatorUnit, OperatorPack}) -> typeof(ms)\nadd!(ms::OperatorSum, mms::OperatorSum) -> typeof(ms)\n\nGet the in-place addition of quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.div!-Tuple{OperatorSum, Number}","page":"Quantum operators","title":"QuantumLattices.div!","text":"div!(ms::OperatorSum, factor::Number) -> OperatorSum\n\nGet the in-place division of an OperatorSum with a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.dtype-Tuple{OperatorPack}","page":"Quantum operators","title":"QuantumLattices.dtype","text":"dtype(m::OperatorPack)\ndtype(::Type{T}) where {T<:OperatorPack}\n\nThe data type of the coefficient of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.id-Tuple{OperatorPack}","page":"Quantum operators","title":"QuantumLattices.id","text":"id(m::OperatorPack) -> idtype(m)\n\nGet the id of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.sub!-Tuple{OperatorSum}","page":"Quantum operators","title":"QuantumLattices.sub!","text":"sub!(ms::OperatorSum) -> typeof(ms)\nsub!(ms::OperatorSum, m::Union{Number, OperatorUnit, OperatorPack}) -> typeof(ms)\nsub!(ms::OperatorSum, mms::OperatorSum) -> typeof(ms)\n\nGet the in-place subtraction of quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.value-Tuple{OperatorPack}","page":"Quantum operators","title":"QuantumLattices.value","text":"value(m::OperatorPack) -> valtype(m)\n\nGet the value of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"using QuantumLattices\nusing SymPy: Sym, symbols","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/#Generator-of-operators","page":"Generator of operators","title":"Generator of operators","text":"","category":"section"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"In previous pages we have introduced the essential elements in detail of a quantum lattice system in the unitcell description framework. In this page, we will discuss how such elements can be incorporated to get the operator representation of the lattice Hamiltonian.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/#Operator-formed-lattice-Hamiltonians","page":"Generator of operators","title":"Operator-formed lattice Hamiltonians","text":"","category":"section"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"The essential elements to obtain an operator-formed lattice Hamiltonian are 1) terms, 2) bonds and 3) Hilbert space.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Accordingly, OperatorGenerator is the type to incorporate all these elements:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"OperatorGenerator(terms::Tuple{Vararg{Term}}, bonds::Vector{<:Bond}, hilbert::Hilbert)","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Then, the operator representation of the lattice Hamiltonian can be obtained by the expand function:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"expand(gen::OperatorGenerator)","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"which is based on the expansion of terms introduced in the last section of the previous page Couplings among different degrees of freedom.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Now, let's go back to the example proposed in the page of Introduction:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"lattice = Lattice([zero(Sym)], [one(Sym)]);\nhilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice));\nt = Hopping(:t, symbols(\"t\", real=true), 1);\nU = Hubbard(:U, symbols(\"U\", real=true));\noperators = expand(OperatorGenerator((t, U), bonds(lattice, 1), hilbert))","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Note to run the above codes, SymPy.Sym and SymPy.symbols should be imported first.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"The LaTeX formatted outputs will be discussed in the page of LaTeX formatted outputs.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Here, we have two comments:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"In the construction of OperatorGenerator, a vector of Bonds other than a Lattice is required. Indeed, it is more flexible to control the generated operators by passing a vector of Bonds. By restricting the range of the input bonds, a certain subset of the lattice Hamiltonian can be easily obtained, which is sometimes useful in some quantum many-body algorithms.\nThe Hilbert space is essential because in general not all information of the local generators of a concrete quantum lattice system is contained in the terms. Remind: 1) the statistics of particles or the total spin of local spins is usually omitted in the coupling pattern of a term, and 2) the total number of local orbital/spin degrees of freedom, or the dimension of lattice vibrations, cannot be determined solely by the information provided by the coupling pattern of a term. Therefore, in order to obtain the lattice Hamiltonian, such incomplete information must be supplemented by the Hilbert space.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/#Parameters-tuning-of-lattice-Hamiltonians","page":"Generator of operators","title":"Parameters tuning of lattice Hamiltonians","text":"","category":"section"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"It is customary to tune the parameters of a lattice Hamiltonian. This can be achieved by the update! function exported by this package:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"update!(gen::OperatorGenerator; termid₁=termvalue₁, termid₁=termvalue₂, ...)","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Here, termidᵢ (i = 1, 2, ...) is the id of a term in the lattice Hamiltonian, and termvalueᵢ is the new overall coefficient of this term.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"The parameters of the terms in an OperatorGenerator can be requested by the type Parameters (a type alias of NamedTuple):","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Parameters(gen::OperatorGenerator) -> Parameters","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Let's see an example.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"julia> lattice = Lattice([0.0], [1.0]);\n\njulia> hilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice));\n\njulia> t = Hopping(:t, 1.0, 1);\n\njulia> gen = OperatorGenerator((t,), bonds(lattice, 1), hilbert);\n\njulia> Parameters(gen)\n(t = 1.0,)\n\njulia> expand(gen)\nOperators with 4 Operator\n  Operator(1.0, CompositeIndex(Index(2, FID{:f}(1, -1//2, 2)), [1.0], [0.0]), CompositeIndex(Index(1, FID{:f}(1, -1//2, 1)), [0.0], [0.0]))\n  Operator(1.0, CompositeIndex(Index(1, FID{:f}(1, -1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, -1//2, 1)), [1.0], [0.0]))\n  Operator(1.0, CompositeIndex(Index(2, FID{:f}(1, 1//2, 2)), [1.0], [0.0]), CompositeIndex(Index(1, FID{:f}(1, 1//2, 1)), [0.0], [0.0]))\n  Operator(1.0, CompositeIndex(Index(1, FID{:f}(1, 1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, 1//2, 1)), [1.0], [0.0]))\n\njulia> update!(gen; t=2.0);\n\njulia> Parameters(gen)\n(t = 2.0,)\n\njulia> expand(gen)\nOperators with 4 Operator\n  Operator(2.0, CompositeIndex(Index(2, FID{:f}(1, -1//2, 2)), [1.0], [0.0]), CompositeIndex(Index(1, FID{:f}(1, -1//2, 1)), [0.0], [0.0]))\n  Operator(2.0, CompositeIndex(Index(1, FID{:f}(1, -1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, -1//2, 1)), [1.0], [0.0]))\n  Operator(2.0, CompositeIndex(Index(2, FID{:f}(1, 1//2, 2)), [1.0], [0.0]), CompositeIndex(Index(1, FID{:f}(1, 1//2, 1)), [0.0], [0.0]))\n  Operator(2.0, CompositeIndex(Index(1, FID{:f}(1, 1//2, 2)), [0.0], [0.0]), CompositeIndex(Index(2, FID{:f}(1, 1//2, 1)), [1.0], [0.0]))","category":"page"},{"location":"#QuantumLattices.jl","page":"Home","title":"QuantumLattices.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov) (Image: ) (Image: ) (Image: 996.icu) (Image: LICENSE) (Image: LICENSE) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia package for the construction of quantum lattice systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to QuantumLattices. Here we provide a general framework to construct the operator-formed Hamiltonian of any quantum lattice system, with the inputs as simple as its description by the natural language. This operator-formed Hamiltonian supports complete symbolic computations when combined with SymPy, and can serve as a convenient frontend of quantum many-body algorithms, such as TBA (tight-bind approximation), LSWT (linear spin wave theory), SCMF (self-consistent mean field theory), ED (exact diagonalization), CPT/VCA (cluster perturbation theory / variational cluster approach), DMRG (density matrix renormalization group), etc. Generic interfaces are defined to provide a unified access to these algorithms with automatic project management.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Julia v1.8+, please type ] in the REPL to use the package mode, then type this command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add QuantumLattices","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The mathematical foundations of our package is that the operators in a lattice Hamiltonian:","category":"page"},{"location":"","page":"Home","title":"Home","text":"act on local Hilbert spaces, and\nform an algebra over the complex field.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Based on this, the package has the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unitcell Description Framework: the Hamiltonian can be constructed based on the unitcell of a lattice with the information of the local algebra acting on the local Hilbert space living on each point and the terms that couples different degrees of freedom on the same or different points. Such information can be input into the program as simple as describing the quantum system in a usual research paper.\nComplete Symbolic Computation: with only this package, symbolic computation between operators is realized while the coefficient of any operator remains numeric; by integrating it with SymPy, complete symbolic computation can be achieved and no modifications need be made on the methods in this package.\nGeneric Frontend of Many-Body Algorithms: with the operator-formed Hamiltonian as the foothold, quantum many-body algorithms can be initialized in quite similar ways with only minor modifications needed. Moreover, automatic project management is realized, including that of result recording, data caching, parameter updating, information logging, dependency managing, etc.","category":"page"},{"location":"#Supported-Systems","page":"Home","title":"Supported Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Four common categories of quantum lattice systems in condensed matter physics are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"canonical complex fermionic systems\ncanonical complex and hard-core bosonic systems\nSU(2) spin systems\nPhononic systems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, other systems can be supported easily by extending the generic protocols provided in this package.","category":"page"},{"location":"#Supported-Algorithms","page":"Home","title":"Supported Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Concrete algorithms could be considered as the \"backend\" of quantum lattice systems. They are developed in separate packages (still in progress):","category":"page"},{"location":"","page":"Home","title":"Home","text":"TBA: tight-binding approximation for complex-fermionic/complex-bosonic/phononic systems;\nSCMF: self-consistent mean field theory for complex fermionic systems;\nED: exact diagonalization for complex-fermionic/hard-core-bosonic/local-spin systems;\nCPT/VCA: cluster perturbation theory and variational cluster approach for complex fermionic and local spin systems;\nDMRG: density matrix renormalization group for complex-fermionic/hard-core-bosonic/local-spin systems;\nLSWT: linear spin wave theory for magnetically ordered local-spin systems.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tutorials: unitcell description\nTutorials: advanced topics","category":"page"},{"location":"#Note","page":"Home","title":"Note","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Due to the fast development of this package, releases with different minor version numbers are not guaranteed to be compatible with previous ones before the release of v1.0.0. Comments are welcomed in the GitHub issues.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"waltergu1989@gmail.com","category":"page"},{"location":"#Python-counterpart","page":"Home","title":"Python counterpart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HamiltonianPy: in fact, the authors of this Julia package worked on the python package at first and only turned to Julia later.","category":"page"}]
}
