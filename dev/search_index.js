var documenterSearchIndex = {"docs":
[{"location":"man/Essentials/Introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = QuantumLattices.Essentials","category":"page"},{"location":"man/Essentials/Introduction/#essentials","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/Essentials/Introduction/","page":"Introduction","title":"Introduction","text":"Essentials of the package, whose constants, types and functions will be imported when using import QuantumLattices or using QuantumLattices. Note that this submodule depends on the Prerequisites and Mathematics submodules although the variables in them are not exported to the scope of QuantumLattices by default.","category":"page"},{"location":"man/Essentials/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"Spatials.md\",\n        \"DegreesOfFreedom.md\",\n        \"Terms.md\",\n        \"FockPackage.md\",\n        \"SpinPackage.md\",\n        \"Frameworks.md\",\n        ]\nDepth = 2","category":"page"},{"location":"man/Essentials/Spatials/","page":"Spatials","title":"Spatials","text":"CurrentModule = QuantumLattices.Essentials.Spatials","category":"page"},{"location":"man/Essentials/Spatials/","page":"Spatials","title":"Spatials","text":"push!(LOAD_PATH,\"../../../../src/\")\nusing QuantumLattices","category":"page"},{"location":"man/Essentials/Spatials/#Spatials","page":"Spatials","title":"Spatials","text":"","category":"section"},{"location":"man/Essentials/Spatials/#Utilities","page":"Spatials","title":"Utilities","text":"","category":"section"},{"location":"man/Essentials/Spatials/#AbstractBond","page":"Spatials","title":"AbstractBond","text":"","category":"section"},{"location":"man/Essentials/Spatials/#Point","page":"Spatials","title":"Point","text":"","category":"section"},{"location":"man/Essentials/Spatials/#Bond","page":"Spatials","title":"Bond","text":"","category":"section"},{"location":"man/Essentials/Spatials/#AbstractLattice","page":"Spatials","title":"AbstractLattice","text":"","category":"section"},{"location":"man/Essentials/Spatials/#Lattice","page":"Spatials","title":"Lattice","text":"","category":"section"},{"location":"man/Essentials/Spatials/#SuperLattice","page":"Spatials","title":"SuperLattice","text":"","category":"section"},{"location":"man/Essentials/Spatials/#Cylinder","page":"Spatials","title":"Cylinder","text":"","category":"section"},{"location":"man/Essentials/Spatials/#Bonds","page":"Spatials","title":"Bonds","text":"","category":"section"},{"location":"man/Essentials/Spatials/#Manual","page":"Spatials","title":"Manual","text":"","category":"section"},{"location":"man/Essentials/Spatials/","page":"Spatials","title":"Spatials","text":"Modules = [Spatials]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.acrossbonds","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.acrossbonds","text":"acrossbonds\n\nIndicate that bonds across the unitcell are inquired, which are in fact those across the periodic boundaries.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.allbonds","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.allbonds","text":"allbonds\n\nIndicate that all bonds are inquired.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.insidebonds","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.insidebonds","text":"insidebonds\n\nIndicate that bonds inside the unitcell are inquired, which do not contain those across the periodic boundaries.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.interbonds","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.interbonds","text":"interbonds\n\nIndicate that bonds inter the sublattices are inquired.\n\nnote: Note\nThese bonds do not contain those accorss the periodic boundaries.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.intrabonds","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.intrabonds","text":"intrabonds\n\nIndicate that bonds intra the sublattices are inquired.\n\nnote: Note\nThese bonds do not contain those accorss the periodic boundaries.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.zerothbonds","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.zerothbonds","text":"zerothbonds\n\nIndicate that zeroth bonds, i.e. the points are inquired.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.AbstractBond","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.AbstractBond","text":"AbstractBond{N, P<:AbstractPID, D<:Number, R}\n\nAbstract bond.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.AbstractLattice","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.AbstractLattice","text":"AbstractLattice{N, P<:AbstractPID, D<:Number}\n\nAbstract type for all lattices.\n\nIt should have the following contents:\n\nname::String: the name of the lattice\npids::Vector{P}: the pids of the lattice\nrcoords::Matrix{D}: the rcoords of the lattice\nicoords::Matrix{D}: the icoords of the lattice\nvectors::Vector{SVector{N, D}}: the translation vectors of the lattice\nreciprocals::Vector{SVector{N, D}}: the reciprocals of the lattice\nneighbors::Dict{Int, Float}: the order-distance map of the nearest neighbors of the lattice\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.AbstractPID","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.AbstractPID","text":"abstract type AbstractPID <: SimpleID\n\nAbstract point id.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Bond","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.Bond","text":"Bond(neighbor::Int, spoint::Point, epoint::Point)\n\nA bond in a lattice.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Bonds","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.Bonds","text":"Bonds{T, L}(bonds::Tuple{Vararg{Vector{<:AbstractBond}}}) where {T, L<:AbstractLattice}\nBonds(lattice::AbstractLattice, types::LatticeBonds...)\n\nA set of lattice bonds.\n\nBonds itself is an AbstractVector of AbstractBond. The need for such a struct is to ensure the type stability during the iteration over a set of different concrete bonds. Although the default iterate function does not achieve this goal, users can get it with the generated function trick. Besides, it provides a high level of management of different categories of bonds based on the LatticeBonds system.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.BrillouinZone","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.BrillouinZone","text":"BrillouinZone(reciprocals::AbstractVector{<:AbstractVector}, momenta::AbelianNumbers{<:Momentum})\n\nThe Brillouin zone of a lattice.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.CPID","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.CPID","text":"CPID(scope, site::Int)\nCPID(site::Int)\nCPID(; scope='T', site::Int=1)\n\nComposite point id.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Cylinder","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.Cylinder","text":"Cylinder{P}(name::String, block::AbstractMatrix{<:Real}, translation::SVector{N, <:Real};\n    vector::Union{AbstractVector{<:Real}, Nothing}=nothing,\n    neighbors::Union{Dict{Int, <:Real}, Int}=1\n    ) where {P<:CPID, N}\n\nCylinder of 1d and quasi 2d lattices.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Cylinder-Tuple","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.Cylinder","text":"(cylinder::Cylinder)(scopes::Any...; coordination::Int=8) -> Lattice\n\nConstruct a lattice from a cylinder with the assigned scopes.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Lattice","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.Lattice","text":"Lattice{N}(name::String,\n    pids::Vector{<:AbstractPID}, rcoords::AbstractMatrix{<:Number}, icoords::AbstractMatrix{<:Number},\n    vectors::AbstractVector{<:AbstractVector{<:Number}},\n    neighbors::Union{Dict{Int, <:Real}, Int}=1;\n    coordination::Int=8\n    ) where N\nLattice(name::String,\n    points::AbstractVector{<:Point};\n    vectors::AbstractVector{<:AbstractVector{<:Number}}=SVector{0, SVector{points|>eltype|>dimension, points|>eltype|>dtype}}(),\n    neighbors::Union{Dict{Int, <:Real}, Int}=1,\n    coordination::Int=8\n    )\nLattice(name::String,\n    sublattices::AbstractVector{<:AbstractLattice};\n    vectors::AbstractVector{<:AbstractVector{<:Real}}=SVector{0, SVector{sublattices|>eltype|>dimension, sublattices|>eltype|>dtype}}(),\n    neighbors::Union{Dict{Int, <:Real}, Int}=1,\n    coordination::Int=8\n    )\n\nSimplest lattice.\n\nA simplest lattice can be construted from its contents, i.e. pids, rcoords and icoords, or from a couple of points, or from a couple of sublattices.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.LatticeIndex","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.LatticeIndex","text":"LatticeIndex{Kind}(index::Union{AbstractPID, Int}) where Kind\n\nLattice index.\n\nKind must be one of the followings:\n\n'R': for getting the rcoord of a lattice\n'I': for getting the icoord of a lattice\n'P': for getting the point of a lattice\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.PID","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.PID","text":"PID <: AbstractPID\n\nPoint id.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Point","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.Point","text":"Point(pid::AbstractPID, rcoord::SVector{N, D}, icoord::SVector{N, D}) where {N, D<:Number}\nPoint(pid::AbstractPID, rcoord::NTuple{N, <:Number}, icoord::NTuple{N, <:Number}=ntuple(i->0, N)) where N\nPoint(pid::AbstractPID, rcoord::AbstractVector{<:Number}, icoord::AbstractVector{<:Number}=zero(SVector{length(rcoord), Int}))\nPoint{N}(pid::AbstractPID, rcoord::AbstractVector{<:Number}, icoord::AbstractVector{<:Number}=zero(SVector{N, Int})) where N\n\nLabeled point.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.SuperLattice","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.SuperLattice","text":"SuperLattice(name::String,\n    sublattices::AbstractVector{<:AbstractLattice};\n    vectors::AbstractVector{<:AbstractVector{<:Real}}=SVector{0, SVector{sublattices|>eltype|>dimension, sublattices|>eltype|>dtype}}(),\n    neighbors::Dict{Int, <:Real}=Dict{Int, Float}()\n    )\n\nSuperLattice that is composed of serveral sublattices.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Spatials/#Base.:==-Tuple{AbstractBond, AbstractBond}","page":"Spatials","title":"Base.:==","text":"==(b₁::AbstractBond, b₂::AbstractBond) -> Bool\n\nOverloaded equivalent operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.:==-Tuple{AbstractLattice, AbstractLattice}","page":"Spatials","title":"Base.:==","text":"==(lattice1::AbstractLattice, lattice2::AbstractLattice) -> Bool\n\nOverloaded equivalent operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.:==-Tuple{Bonds, Bonds}","page":"Spatials","title":"Base.:==","text":"==(bonds1::Bonds, bonds2::Bonds) -> Bool\n\nOverloaded equivalent operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.eltype-Tuple{AbstractBond}","page":"Spatials","title":"Base.eltype","text":"eltype(bond::AbstractBond)\neltype(::Type{<:AbstractBond{N, P}}) where {N, P<:AbstractPID}\n\nGet the eltype of a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.empty!-Tuple{Bonds}","page":"Spatials","title":"Base.empty!","text":"empty!(bs::Bonds) -> Bonds\n\nEmpty a set of lattice bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.empty-Tuple{Bonds}","page":"Spatials","title":"Base.empty","text":"empty(bs::Bonds) -> Bonds\n\nGet an empty copy of a set of lattice bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.filter","page":"Spatials","title":"Base.filter","text":"filter(lbs::LatticeBonds, bs::Bonds, choice::Union{Val{:include}, Val{:exclude}}=Val(:include)) -> Bonds\nfilter(lbs::Tuple{Vararg{LatticeBonds}}, bs::Bonds, choice::Union{Val{:include}, Val{:exclude}}=Val(:include)) -> Bonds\n\nGet a subset of a set of lattice bonds.\n\nWhen choice=Val(:include), the lattice bonds indicated by lbs will be selected;  When choice=Val(:exclude), the lattice bonds not indicated by lbs will be selected.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Spatials/#Base.filter-Tuple{Function, Bonds}","page":"Spatials","title":"Base.filter","text":"filter(select::Function, bs::Bonds) -> Bonds\n\nGet a filtered set of bonds by a select function.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.getindex-Tuple{AbstractLattice, LatticeIndex{'R', Int64}}","page":"Spatials","title":"Base.getindex","text":"getindex(lattice::AbstractLattice, i::LatticeIndex{'R'}) -> SVector\ngetindex(lattice::AbstractLattice, i::LatticeIndex{'I'}) -> SVector\ngetindex(lattice::AbstractLattice, i::LatticeIndex{'P'}) -> Point\n\nGet a rcoord, an icoord or a point of a lattice according to the type of the input index.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.getindex-Tuple{Bond, Integer}","page":"Spatials","title":"Base.getindex","text":"getindex(bond::Bond, i::Integer) -> Point\n\nGet the ith point of a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.getindex-Tuple{Bonds, Int64}","page":"Spatials","title":"Base.getindex","text":"getindex(bs::Bonds, i::Int) -> eltype(bs)\n\nGet the ith bond in the set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.getindex-Tuple{Point, Integer}","page":"Spatials","title":"Base.getindex","text":"getindex(p::Point, i::Integer) -> Point\n\nGet the ith point of a point, which by definition i should only be 1 and the result is the point itself.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.insert!-Union{Tuple{S}, Tuple{Cylinder, Vararg{S, N} where N}} where S","page":"Spatials","title":"Base.insert!","text":"insert!(cylinder::Cylinder, ps::S...; cut=length(cylinder)÷2+1, scopes::Union{<:AbstractVector{S}, Nothing}=nothing, coordination=8) where S -> Cylinder\n\nInsert a couple of blocks into a cylinder.\n\nThe position of the cut of the cylinder is specified by the keyword argument cut, which is the center of the cylinder by default. All pids corresponding to a same newly inserted block share the same scope, which is specified by the parameter ps. Optionally, the scopes of the old pids in the cylinder can be replaced if the parameter scopes is assigned other than nothing. Note the length of ps is equal to the number of newly inserted blocks, while that of scopes should be equal to the old length of the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.isequal-Tuple{AbstractBond, AbstractBond}","page":"Spatials","title":"Base.isequal","text":"isequal(b₁::AbstractBond, b₂::AbstractBond) -> Bool\n\nOverloaded equivalent function.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.isequal-Tuple{AbstractLattice, AbstractLattice}","page":"Spatials","title":"Base.isequal","text":"isequal(lattice1::AbstractLattice, lattice2::AbstractLattice) -> Bool\n\nOverloaded equivalent function.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.isequal-Tuple{Bonds, Bonds}","page":"Spatials","title":"Base.isequal","text":"isequal(bonds1::Bonds, bonds2::Bonds) -> Bool\n\nOverloaded equivalent function.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.iterate","page":"Spatials","title":"Base.iterate","text":"iterate(bs::Bonds, state=(1, 0))\n\nIterate over the lattice bonds in the set.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Spatials/#Base.iterate-2","page":"Spatials","title":"Base.iterate","text":"iterate(bond::AbstractBond, state=1)\n\nIterate over the points in a bond.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Spatials/#Base.keytype-Tuple{AbstractLattice}","page":"Spatials","title":"Base.keytype","text":"keytype(lattice::AbstractLattice)\nkeytype(::Type{<:AbstractLattice{N, P} where N}) where {P<:AbstractPID}\n\nGet the pid type of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.length-Tuple{AbstractBond}","page":"Spatials","title":"Base.length","text":"length(bond::AbstractBond) -> Int\nlength(::Type{<:AbstractBond{N, <:AbstractPID, <:Number, R} where N}) where R -> Int\n\nGet the number of points of a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.length-Tuple{AbstractLattice}","page":"Spatials","title":"Base.length","text":"length(lattice::AbstractLattice) -> Int\n\nGet the number of points contained in a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.reverse-Tuple{Bond}","page":"Spatials","title":"Base.reverse","text":"reverse(bond::Bond) -> Bond\n\nGet the reversed bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.show-Tuple{IO, AbstractLattice}","page":"Spatials","title":"Base.show","text":"show(io::IO, lattice::AbstractLattice)\n\nShow a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.show-Tuple{IO, Bond}","page":"Spatials","title":"Base.show","text":"show(io::IO, bond::Bond)\n\nShow a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.show-Tuple{IO, Point}","page":"Spatials","title":"Base.show","text":"show(io::IO, p::Point)\n\nShow a labeled point.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.size-Tuple{Bonds}","page":"Spatials","title":"Base.size","text":"size(bs::Bonds) -> Tuple{Int}\n\nGet the size of the set of lattice bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.summary-Tuple{IO, Bonds}","page":"Spatials","title":"Base.summary","text":"summary(io::IO, bs::Bonds)\n\nPrint the brief description of a set of lattice bonds to an io.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#Base.valtype-Tuple{AbstractLattice}","page":"Spatials","title":"Base.valtype","text":"valtype(lattice::AbstractLattice)\nvaltype(::Type{<:AbstractLattice{N, P}}) where {N, P<:AbstractPID}\n\nGet the point type of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.azimuth-Tuple{AbstractVector{var\"#s78\"} where var\"#s78\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.azimuth","text":"azimuth(v::AbstractVector{<:Number}) -> Number\n\nGet the azimuth angle in radians of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.azimuthd-Tuple{AbstractVector{var\"#s78\"} where var\"#s78\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.azimuthd","text":"azimuthd(v::AbstractVector{<:Number}) -> Number\n\nGet the azimuth angle in degrees of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.bonds!-Tuple{Vector{T} where T, AbstractLattice}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.bonds!","text":"bonds!(bonds::Vector, lattice::AbstractLattice, inquiries::LatticeBonds...) -> Vector\nbonds!(bonds::Vector, lattice::AbstractLattice, ::Val{zerothbonds}) -> Vector\nbonds!(bonds::Vector, lattice::AbstractLattice, ::Val{insidebonds}) -> Vector\nbonds!(bonds::Vector, lattice::AbstractLattice, ::Val{acrossbonds}) -> Vector\n\nGenerate the required bonds of a lattice and append them to the input bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.bonds!-Tuple{Vector{T} where T, SuperLattice, Val{QuantumLattices.Essentials.Spatials.IntraBonds()}}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.bonds!","text":"bonds!(bonds::Vector, lattice::SuperLattice, ::Val{intrabonds}) -> Vector\nbonds!(bonds::Vector, lattice::SuperLattice, ::Val{interbonds}) -> Vector\n\nGenerate the required bonds of a superlattice and append them to the input bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.bonds-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.bonds","text":"bonds(lattice::AbstractLattice, inquiry=allbonds) -> Vector{eltype(lattice|>typeof, inquiry)}\nbonds(lattice::AbstractLattice, inquiries...) -> Vector{mapreduce(inquiry->eltype(lattice|>typeof, inquiry), typejoin, inquiries)}\n\nGenerate the required bonds of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.bondtypes-Tuple{Bonds}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.bondtypes","text":"bondtypes(bs::Bonds) -> Tuple{Vararg{LatticeBonds}}\nbondtypes(::Type{<:Bonds{T}}) where T -> Tuple{Vararg{LatticeBonds}}\n\nGet the bondtypes of a set of lattice bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.distance-Tuple{AbstractVector{var\"#s74\"} where var\"#s74\"<:Number, AbstractVector{var\"#s69\"} where var\"#s69\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.distance","text":"distance(p₁::AbstractVector{<:Number}, p₂::AbstractVector{<:Number}) -> Number\n\nGet the distance between two points.\n\nnote: Note\nCompared to norm(p₁-p₂), this function avoids the memory allocation for p₁-p₂, thus is more efficient.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.icoord-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.icoord","text":"icoord(bond::Bond) -> SVector\n\nGet the icoord of the bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.interlinks-Tuple{AbstractMatrix{var\"#s100\"} where var\"#s100\"<:Number, AbstractMatrix{var\"#s99\"} where var\"#s99\"<:Number, Dict{Int64, var\"#s98\"} where var\"#s98\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.interlinks","text":"interlinks(cluster₁::AbstractMatrix{<:Number}, cluster₂::AbstractMatrix{<:Number}, neighbors::Dict{Int, <:Number}) -> Vector{Tuple{Int, Int, Int}}\n\nUse kdtree to get the intercluster nearest neighbors.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.intralinks-Union{Tuple{N}, Tuple{AbstractMatrix{var\"#s94\"} where var\"#s94\"<:Number, AbstractVector{var\"#s79\"} where var\"#s79\"<:(AbstractVector{var\"#s78\"} where var\"#s78\"<:Number), Dict{Int64, var\"#s77\"} where var\"#s77\"<:Number}, Tuple{AbstractMatrix{var\"#s74\"} where var\"#s74\"<:Number, AbstractVector{var\"#s69\"} where var\"#s69\"<:(AbstractVector{var\"#s55\"} where var\"#s55\"<:Number), Dict{Int64, var\"#s12\"} where var\"#s12\"<:Number, Tuple{Vararg{Int64, N}}}} where N","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.intralinks","text":"intralinks(cluster::AbstractMatrix{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, neighbors::Dict{Int, <:Number},\n    maxtranslations::NTuple{N, Int}=ntuple(i->length(neighbors), length(vectors))\n    ) where N -> Vector{Tuple{Int, Int, Int, Vector{<:Number}}}\n\nUse kdtree to get the intracluster nearest neighbors.\n\nAs is similar to minimumlengths, when vectors is nonempty, the cluster assumes periodic boundaries. neighbors provides the map between the bond length and the order of nearest neighbors. Note only those with the lengths present in neighbors will be included in the result. maxtranslations determines the maximum number of translations along those directions specified by vectors when the tiled supercluster is construted (See minimumlengths for the explanation of the method for periodic lattices).\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.isintracell-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.isintracell","text":"isintracell(bond::Bond) -> Bool\n\nJudge whether a bond is intra the unit cell of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.isintracell-Tuple{Point}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.isintracell","text":"isintracell(p::Point) -> Bool\n\nJudge whether a point is intra the unitcell.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.isintratriangle-Tuple{AbstractVector{var\"#s4\"} where var\"#s4\"<:Number, AbstractVector{var\"#s3\"} where var\"#s3\"<:Number, AbstractVector{var\"#s2\"} where var\"#s2\"<:Number, AbstractVector{var\"#s1\"} where var\"#s1\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.isintratriangle","text":"isintratriangle(p::AbstractVector{<:Number}, p₁::AbstractVector{<:Number}, p₂::AbstractVector{<:Number}, p₃::AbstractVector{<:Number};\n    vertexes::NTuple{3, Bool}=(true, true, true), edges::NTuple{3, Bool}=(true, true, true), atol::Real=atol, rtol::Real=rtol\n    ) -> Bool\n\nJudge whether a point belongs to the interior of a triangle whose vertexes are p₁, 'p₂' and p₃ with the give tolerance. vertexes and edges define whether the interior should contain the vertexes or edges, respectively.\n\nnote: Note\nThe vertexes are in the order (p₁, p₂, p₃) and the edges are in the order (p1p2, p2p3, p3p1).\nThe edges do not contain the vertexes.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.isonline-Tuple{AbstractVector{var\"#s6\"} where var\"#s6\"<:Number, AbstractVector{var\"#s4\"} where var\"#s4\"<:Number, AbstractVector{var\"#s3\"} where var\"#s3\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.isonline","text":"isonline(p::AbstractVector{<:Number}, p₁::AbstractVector{<:Number}, p₂::AbstractVector{<:Number};\n    ends::Tuple{Bool, Bool}=(true, true), atol::Real=atol, rtol::Real=rtol\n    ) -> Bool\n\nJudge whether a point is on a line segment whose end points are p₁ and p₂ with the given tolerance. ends defines whether the line segment should contain its ends.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.isparallel-Tuple{AbstractVector{var\"#s11\"} where var\"#s11\"<:Number, AbstractVector{var\"#s10\"} where var\"#s10\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.isparallel","text":"isparallel(v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}; atol::Real=atol, rtol::Real=rtol) -> Int\n\nJudge whether two vectors are parallel to each other with the given tolerance, 0 for not parallel, 1 for parallel and -1 for antiparallel.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.issubordinate-Tuple{AbstractVector{var\"#s99\"} where var\"#s99\"<:Number, AbstractVector{var\"#s98\"} where var\"#s98\"<:(AbstractVector{var\"#s97\"} where var\"#s97\"<:Number)}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.issubordinate","text":"issubordinate(rcoord::AbstractVector{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}; atol::Real=atol, rtol::Real=rtol) -> Bool\n\nJudge whether a coordinate belongs to a lattice defined by vectors with the given tolerance.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.latticebondsstructure-Tuple{Type{var\"#s106\"} where var\"#s106\"<:AbstractLattice}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.latticebondsstructure","text":"latticebondsstructure(::Type{<:AbstractLattice}) -> SimpleTree{LatticeBonds, Nothing}\n\nThe tree structure of the lattice bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.latticebondsstructure-Tuple{Type{var\"#s153\"} where var\"#s153\"<:SuperLattice}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.latticebondsstructure","text":"latticebondsstructure(::Type{<:SuperLattice}) -> SimpleTree{LatticeBonds, Nothing}\n\nThe tree structure of the lattice bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.latticetype-Tuple{Bonds}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.latticetype","text":"latticetype(bs::Bonds)\nlatticetype(::Type{<:Bonds{T, L} where T}) where {L<:AbstractLattice}\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.latticetype-Tuple{SuperLattice}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.latticetype","text":"latticetype(sl::SuperLattice)\nlatticetype(::Type{<:SuperLattice{L}}) where {L<:AbstractLattice}\n\nGet the sublattice type of a superlattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.minimumlengths","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.minimumlengths","text":"minimumlengths(cluster::AbstractMatrix{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, nneighbor::Int=1; coordination::Int=8) -> Vector{Float}\n\nUse kdtree to search the lowest several minimum bond lengths within a lattice translated by a cluster.\n\nWhen the translation vectors are not empty, the lattice will be considered periodic in the corresponding directions. Otherwise the lattice will be open in all directions. To search for the bonds accorss the periodic boundaries, the cluster will be pretranslated to become a supercluster, which has open boundaries but is large enough to contain all the nearest neighbors within the required order. The coordination parameter sets the average number of each order of nearest neighbors. If it is to small, larger bond lengths may not be searched, and the result will contain Inf. This is a sign that you may need a larger coordination. Another situation that Inf appears in the result occurs when the minimum lengths are searched in open lattices. Indeed, the cluster may be too small so that the required order just goes beyond it. In this case the warning message can be safely ignored.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.nneighbor-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.nneighbor","text":"nneighbor(lattice::AbstractLattice) -> Int\n\nGet the highest order of nearest neighbors.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.pidtype-Tuple{AbstractBond}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.pidtype","text":"pidtype(bond::AbstractBond)\npidtype(::Type{<:AbstractBond{N, P} where N}) where {P<:AbstractPID}\n\nGet the pid type of a concrete bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.polar-Tuple{AbstractVector{var\"#s78\"} where var\"#s78\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.polar","text":"polar(v::AbstractVector{<:Number}) -> Number\n\nGet the polar angle in radians of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.polard-Tuple{AbstractVector{var\"#s78\"} where var\"#s78\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.polard","text":"polard(v::AbstractVector{<:Number}) -> Number\n\nGet the polar angle in degrees of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.rcoord-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.rcoord","text":"rcoord(bond::Bond) -> SVector\n\nGet the rcoord of the bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.reciprocals-Tuple{AbstractVector{var\"#s106\"} where var\"#s106\"<:(AbstractVector{var\"#s105\"} where var\"#s105\"<:Number)}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.reciprocals","text":"reciprocals(vectors::AbstractVector{AbstractVector{<:Number}}) -> Vector{Vector{<:Number}}\n\nGet the reciprocals dual to the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.rotate-Tuple{AbstractMatrix{var\"#s79\"} where var\"#s79\"<:Number, Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.rotate","text":"rotate(cluster::AbstractMatrix{<:Number}, angle::Number; axis::Tuple{Union{AbstractVector{<:Number}, Nothing}, Tuple{<:Number, <:Number}}=(nothing, (0, 0))) -> Matrix{<:Number}\n\nGet a rotated cluster of the original one by a certain angle around an axis.\n\nThe axis is determined by a point it gets through (nothing can be used to denote the origin), and its polar as well as azimuth angles in radians. The default axis is the z axis.\n\nnote: Note\nThe result is given by the Rodrigues' rotation formula.\nOnly 2 and 3 dimensional vectors can be rotated.\nWhen the input vectors are 2 dimensional, both the polar and azimuth of the axis must be 0.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.tile-Union{Tuple{M}, Tuple{N}, Tuple{AbstractMatrix{var\"#s96\"} where var\"#s96\"<:Number, AbstractVector{var\"#s95\"} where var\"#s95\"<:(AbstractVector{var\"#s94\"} where var\"#s94\"<:Number)}, Tuple{AbstractMatrix{var\"#s79\"} where var\"#s79\"<:Number, AbstractVector{var\"#s78\"} where var\"#s78\"<:(AbstractVector{var\"#s77\"} where var\"#s77\"<:Number), Tuple{Vararg{Tuple{Vararg{var\"#s74\", N}} where var\"#s74\"<:Number, M}}}} where {N, M}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.tile","text":"tile(cluster::AbstractMatrix{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, translations::NTuple{M, NTuple{N, <:Number}}=()) where {N, M} -> Matrix{<:Number}\n\nTile a supercluster by translations of the input cluster.\n\nBasically, the final supercluster is composed of several parts, each of which is a translation of the original cluster, with the translation vectors specified by vectors and each set of the translation indices contained in translations. When translation vectors are empty, a copy of the original cluster will be returned.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.translate-Tuple{AbstractMatrix{var\"#s107\"} where var\"#s107\"<:Number, AbstractVector{var\"#s106\"} where var\"#s106\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.translate","text":"translate(cluster::AbstractMatrix{<:Number}, vector::AbstractVector{<:Number}) -> Matrix{vector|>eltype}\n\nGet the translated cluster of the original one by a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.volume-Tuple{AbstractVector{var\"#s74\"} where var\"#s74\"<:Number, AbstractVector{var\"#s69\"} where var\"#s69\"<:Number, AbstractVector{var\"#s55\"} where var\"#s55\"<:Number}","page":"Spatials","title":"QuantumLattices.Essentials.Spatials.volume","text":"volume(v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}, v₃::AbstractVector{<:Number}) -> Number\n\nGet the volume spanned by three vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.dtype-Tuple{AbstractBond}","page":"Spatials","title":"QuantumLattices.Essentials.dtype","text":"dtype(bond::AbstractBond)\ndtype(::Type{<:AbstractBond{N, <:AbstractPID, D} where N}) where {D<:Number}\n\nGet the data type of a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.dtype-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.Essentials.dtype","text":"dtype(lattice::AbstractLattice)\ndtype(::Type{<:AbstractLattice{N, <:AbstractPID, D} where N}) where {D<:Number}\n\nGet the data type of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.dtype-Tuple{BrillouinZone}","page":"Spatials","title":"QuantumLattices.Essentials.dtype","text":"dtype(bz::BrillouinZone)\ndtype(::Type{<:BrillouinZone{<:Momentum, N, D} where N}) where {D<:Number}\n\nGet the data type of a Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.kind-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Essentials.kind","text":"kind(bond::Bond) -> Int\n\nGet the bond kind of a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.kind-Tuple{Point}","page":"Spatials","title":"QuantumLattices.Essentials.kind","text":"kind(::Point) -> 0\nkind(::Type{<:Point}) -> 0\n\nGet the bond kind of a point, which is defined to be 0.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Essentials.reset!-Tuple{Bonds, AbstractLattice}","page":"Spatials","title":"QuantumLattices.Essentials.reset!","text":"reset!(bs::Bonds, lattice::AbstractLattice) -> Bonds\n\nReset a set of lattice bonds by a new lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Interfaces.decompose-Tuple{AbstractVector{var\"#s79\"} where var\"#s79\"<:Number, AbstractVector{var\"#s78\"} where var\"#s78\"<:Number}","page":"Spatials","title":"QuantumLattices.Interfaces.decompose","text":"decompose(v₀::AbstractVector{<:Number}, v₁::AbstractVector{<:Number}) -> Tuple{Number}\ndecompose(v₀::AbstractVector{<:Number}, v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}) -> Tuple{Number, Number}\ndecompose(v₀::AbstractVector{<:Number}, v₁::AbstractVector{<:Number}, v₂::AbstractVector{<:Number}, v₃::AbstractVector{<:Number}) -> Tuple{Number, Number, Number}\n\nDecompose a vector with respect to input basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Interfaces.dimension-Tuple{AbstractBond}","page":"Spatials","title":"QuantumLattices.Interfaces.dimension","text":"dimension(bond::AbstractBond) -> Int\ndimension(::Type{<:AbstractBond{N}}) where N -> Int\n\nGet the space dimension of a concrete bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Interfaces.dimension-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.Interfaces.dimension","text":"dimension(lattice::AbstractLattice) -> Int\ndimension(::Type{<:AbstractLattice{N}}) where N -> Int\n\nGet the space dimension of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Interfaces.expand-Union{Tuple{VS}, Tuple{L}, Tuple{Type{L}, Val{VS}}} where {L<:AbstractLattice, VS}","page":"Spatials","title":"QuantumLattices.Interfaces.expand","text":"expand(::Type{L}, ::Val{VS}) where {L<:AbstractLattice, VS} -> Tuple\n\nExpand the lattice bond types to the leaf level.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Interfaces.rank-Tuple{AbstractBond}","page":"Spatials","title":"QuantumLattices.Interfaces.rank","text":"rank(bond::AbstractBond) -> Int\nrank(::Type{<:AbstractBond{N, <:AbstractPID, <:Number, R} where N}) where R -> Int\n\nGet the rank of a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Spatials/#QuantumLattices.Interfaces.rank-Tuple{Bonds}","page":"Spatials","title":"QuantumLattices.Interfaces.rank","text":"rank(bs::Bonds) -> Int\nrank(::Type{<:Bonds{T}}) where T -> Int\n\nGet the rank of a set of lattice bonds.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"CurrentModule = QuantumLattices\nDocTestFilters = [r\"im +[-\\+]0\\.0[-\\+]\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#Internal-degrees-of-freedom","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's move to the second step. A main feature of a quantum lattice system is that one can decompose the whole Hilbert space into local ones. Correspondingly, the Hamiltonian of the system can always be expressed by products/sums of local generators of the algebras acting on these local Hilbert spaces. Thus, a parallel to the spatial info of the unitcell of the lattice system is the internal degrees of freedom that \"lives\" in each spatial point.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#Internal,-IID-and-Index","page":"Internal degrees of freedom","title":"Internal, IID and Index","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Different kinds of quantum lattice systems can have different species of local Hilbert spaces. For example, the local Hilbert space of a complex fermionic/bosonic system is the Fock space whereas that of a spin-1/2 system is the two-dimensional lvertuparrowrangle lvertdownarrowrangle space. The abstract type Internal is an abstraction of local Hilbert spaces. More precisely, it is an abstraction of local algebras acting on these local Hilbert spaces. To specify a generator of such a local algebra, two sets of tags are needed: one identifies which the local algebra is and the other represents which the internal degree of freedom is. The former is already encoded by a PID object, and the latter will be stored in an object of a concrete subtype of the abstract type IID. These two sets of tags are combined to be the Index type, which contains the complete information of a local generator.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"In this package, we implement two groups of concrete subtypes to handle with the following two sets of systems, respectively:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Canonical fermionic, canonical bosonic and hard-core bosonic systems,\nSU(2) spin systems.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#Fock-and-FID","page":"Internal degrees of freedom","title":"Fock and FID","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"This group of concrete subtypes are designed to deal with canonical fermionic, canonical bosonic and hard-core bosonic systems.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Roughly speaking, these systems share similar internal structures of local Hilbert spaces termed as the Fock space where the generators of local algebras are the annihilation and creation operators. Besides the spatial index, such an operator usually adopts an orbital index and a spin index. It also needs a nambu index to distinguish whether it is an annihilation one or a creation one. Thus, the type FID<:IID, which specifies a certain internal degree of freedom of a local Fock space, has the following attributes:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"orbital::Int: the orbital index\nspin::Int: the spin index\nnambu::Int: the nambu index, which must be 0, 1(annihilation) or 2(creation).","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Correspondingly, the type Fock<:Internal, which specifies the whole internal structure of a local Fock space, has the following attributes:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"atom::Int: the atom index associated with a local Hilbert space\nnorbital::Int: the number of allowed orbital indices\nnspin::Int: the number of allowed spin indices\nnnambu::Int: the number of allowed nambu indices, which must be either 1 or 2.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that we also associate an atom index with each Fock instance, which proves to be helpful in future usages.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"One more remark. The :nambu attribute of an FID instance can be 1 or 2, which means it represents an annihilation operator or a creation operator, respectively. This corresponds to a usual complex fermionic/bosonic system. The :nambu attribute can also be 0. In this case, it corresponds to a real fermionic/bosonic system where annihilation and creation operators are identical to each other, e.g. a Majorana fermionic system. Accordingly, The :nnambu attribute of a Fock instance can be either 2 or 1. Being 2, it allows usual complex annihilation/creation operators, while being 1 it only allows real fermionic/bosonic operators.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To distinguish whether the system is a fermionic one or a bosonic one, FID and Fock take a symbol :f(for fermionic) or :b(for bosonic) to be their first type parameters.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's see some examples.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"An FID instance can be initialized by giving all its three attributes:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> FID{:f}(2, 2, 1)\nFID{:f}(2, 2, 1)\n\njulia> FID{:b}(2, 2, 1)\nFID{:b}(2, 2, 1)","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Or you can only specify part of the three by key word arguments and the others will get default values:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> FID{:f}() # default values: orbital=1, spin=1, nambu=1\nFID{:f}(1, 1, 1)\n\njulia> FID{:b}(spin=2, nambu=0)\nFID{:b}(1, 2, 0)","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The adjoint of an FID instance is also defined:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> FID{:f}(orbital=3, spin=4, nambu=1)'\nFID{:f}(3, 4, 2)\n\njulia> FID{:b}(orbital=3, spin=4, nambu=2)'\nFID{:b}(3, 4, 1)\n\njulia> FID{:b}(orbital=3, spin=4, nambu=0)'\nFID{:b}(3, 4, 0)","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Apparently, this operation is nothing but the \"Hermitian conjugate\".","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"A Fock instance can be initialized by giving all its attributes or by key word arguments to specify those beyond the default values:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Fock{:f}(1, 1, 2, 2)\n4-element Fock{:f}:\n FID{:f}(1, 1, 1)\n FID{:f}(1, 2, 1)\n FID{:f}(1, 1, 2)\n FID{:f}(1, 2, 2)\n\njulia> Fock{:b}() # default values: atom=1, norbital=1, nspin=2, nnambu=2\n4-element Fock{:b}:\n FID{:b}(1, 1, 1)\n FID{:b}(1, 2, 1)\n FID{:b}(1, 1, 2)\n FID{:b}(1, 2, 2)\n\njulia> Fock{:b}(atom=2, norbital=2, nspin=1, nnambu=1)\n2-element Fock{:b}:\n FID{:b}(1, 1, 0)\n FID{:b}(2, 1, 0)","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"As can be seen, a Fock instance behaves like a vector (because the parent type Internal is a subtype of AbstractVector), and its iteration just generates all the allowed FID instances on its associated spatial point:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> fck = Fock{:f}(atom=1, norbital=2, nspin=1, nnambu=2);\n\njulia> fck |> typeof |> eltype\nFID{:f}\n\njulia> fck |> length\n4\n\njulia> [fck[1], fck[2], fck[3], fck[4]]\n4-element Vector{FID{:f}}:\n FID{:f}(1, 1, 1)\n FID{:f}(2, 1, 1)\n FID{:f}(1, 1, 2)\n FID{:f}(2, 1, 2)\n\njulia> fck |> collect\n4-element Vector{FID{:f}}:\n FID{:f}(1, 1, 1)\n FID{:f}(2, 1, 1)\n FID{:f}(1, 1, 2)\n FID{:f}(2, 1, 2)","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#Spin-and-SID","page":"Internal degrees of freedom","title":"Spin and SID","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"push!(LOAD_PATH, \"../../../src/\")\nusing QuantumLattices","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"This group of concrete subtypes are designed to deal with SU(2) spin systems.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Although spin systems are essentially bosonic, the commonly-used local Hilbert space is distinct from that of a canonical bosonic system: it is the space spanned by the eigenstates of a local S^z operator rather than a \"Fock space\". At the same time, a spin Hamiltonian is usually expressed by local spin operators, such as S^x, S^y, S^z, S^+ and S^-, instead of creation and annihilation operators. Therefore, it is convenient to define another set of concrete subtypes for spin systems.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Apart from the spatial indices, a local spin operator can have an orbital index. Besides, it also needs an index to indicate which spin operator it is. Thus, the type SID, which specifies the internal degree of freedom of a local spin operator, has the following attributes:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"orbital::Int: the orbital index\ntag::Char: the tag, which must be 'x', 'y', 'z', '+' or '-'.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Correspondingly, the type Spin, which defines the whole internal structure of a local spin space, has the following attributes:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"atom::Int: the atom index associated with a local spin space\nnorbital::Int: the number of allowed orbital indices","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"For SID and Spin, it is also necessary to know what the total spin is, which is taken as their first type parameters and should be a half-integer or an integer.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's see examples.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"An SID instance can be initialized as follows","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> SID{3//2}(1, 'x')\nSID{3//2}(1, 'x')\n\njulia> SID{1//2}('z') # default values: orbital=1\nSID{1//2}(1, 'z')\n\njulia> SID{1}('+', orbital=2)\nSID{1}(2, '+')","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The \"Hermitian conjugate\" of an SID instance can be obtained by the adjoint operation:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> SID{3//2}(1, 'x')'\nSID{3//2}(1, 'x')\n\njulia> SID{3//2}(1, 'y')'\nSID{3//2}(1, 'y')\n\njulia> SID{3//2}(1,'z')'\nSID{3//2}(1, 'z')\n\njulia> SID{3//2}(1, '+')'\nSID{3//2}(1, '-')\n\njulia> SID{3//2}(1, '-')'\nSID{3//2}(1, '+')","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Regardless of the local orbital space, the local spin space is determined by the total spin. The standard matrix representation of an SID instance on this local spin space can be obtained by the Matrix function:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> SID{1//2}(1, 'x') |> Matrix\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.5+0.0im\n 0.5+0.0im  0.0+0.0im\n\njulia> SID{1//2}(1, 'y') |> Matrix\n2×2 Matrix{ComplexF64}:\n 0.0-0.0im  -0.0+0.5im\n 0.0-0.5im   0.0-0.0im\n\njulia> SID{1//2}(1, 'z') |> Matrix\n2×2 Matrix{ComplexF64}:\n -0.5+0.0im  -0.0+0.0im\n  0.0+0.0im   0.5+0.0im\n\njulia> SID{1//2}(1, '+') |> Matrix\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im\n\njulia> SID{1//2}(1, '-') |> Matrix\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"A Spin instance can be initialized as follows:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Spin{1}(1, 2)\n10-element Spin{1}:\n SID{1}(1, 'x')\n SID{1}(2, 'x')\n SID{1}(1, 'y')\n SID{1}(2, 'y')\n SID{1}(1, 'z')\n SID{1}(2, 'z')\n SID{1}(1, '+')\n SID{1}(2, '+')\n SID{1}(1, '-')\n SID{1}(2, '-')\n\njulia> Spin{1//2}() # default values: atom=1, norbital=1\n5-element Spin{1//2}:\n SID{1//2}(1, 'x')\n SID{1//2}(1, 'y')\n SID{1//2}(1, 'z')\n SID{1//2}(1, '+')\n SID{1//2}(1, '-')\n\njulia> Spin{1}(atom=2, norbital=1)\n5-element Spin{1}:\n SID{1}(1, 'x')\n SID{1}(1, 'y')\n SID{1}(1, 'z')\n SID{1}(1, '+')\n SID{1}(1, '-')","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Similar to Fock, a Spin instance behaves like a vector whose iteration generates all the allowed SID instances on its associated spatial point:","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> sp = Spin{1}(atom=1, norbital=1);\n\njulia> sp |> typeof |> eltype\nSID{1}\n\njulia> sp |> length\n5\n\njulia> [sp[1], sp[2], sp[3], sp[4], sp[5]]\n5-element Vector{SID{1}}:\n SID{1}(1, 'x')\n SID{1}(1, 'y')\n SID{1}(1, 'z')\n SID{1}(1, '+')\n SID{1}(1, '-')\n\njulia> sp |> collect\n5-element Vector{SID{1}}:\n SID{1}(1, 'x')\n SID{1}(1, 'y')\n SID{1}(1, 'z')\n SID{1}(1, '+')\n SID{1}(1, '-')","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that a Spin instance generates SID instances corresponding to not only S^x, S^y and S^z,  but also S^+ and S^- although the former three already forms a complete set of generators of local spin algebras. This overcomplete feature is for the convenience to the construction of spin Hamiltonians.","category":"page"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#Index","page":"Internal degrees of freedom","title":"Index","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#Config","page":"Internal degrees of freedom","title":"Config","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#OID","page":"Internal degrees of freedom","title":"OID","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#Operator-and-Operators","page":"Internal degrees of freedom","title":"Operator and Operators","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/InternalDegreesOfFreedom/#latex-formatted-output","page":"Internal degrees of freedom","title":"latex-formatted output","text":"","category":"section"},{"location":"man/Essentials/Terms/","page":"Terms","title":"Terms","text":"CurrentModule = QuantumLattices.Essentials.Terms","category":"page"},{"location":"man/Essentials/Terms/","page":"Terms","title":"Terms","text":"push!(LOAD_PATH,\"../../../../src/\")\nusing QuantumLattices","category":"page"},{"location":"man/Essentials/Terms/#Terms","page":"Terms","title":"Terms","text":"","category":"section"},{"location":"man/Essentials/Terms/#Subscripts","page":"Terms","title":"Subscripts","text":"","category":"section"},{"location":"man/Essentials/Terms/#Coupling-and-Couplings","page":"Terms","title":"Coupling and Couplings","text":"","category":"section"},{"location":"man/Essentials/Terms/#Term","page":"Terms","title":"Term","text":"","category":"section"},{"location":"man/Essentials/Terms/#Generator","page":"Terms","title":"Generator","text":"","category":"section"},{"location":"man/Essentials/Terms/#Manual","page":"Terms","title":"Manual","text":"","category":"section"},{"location":"man/Essentials/Terms/","page":"Terms","title":"Terms","text":"Modules = [Terms]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.AbstractGenerator","page":"Terms","title":"QuantumLattices.Essentials.Terms.AbstractGenerator","text":"AbstractGenerator{TS<:NamedContainer{Term}, BS<:Bonds, C<:Config, T<:Table, B<:Boundary, OS<:GenOperators}\n\nAbstract generator.\n\nBy protocol, a concrete generator should have the following predefined contents:\n\nterms::TS: the terms contained in a generator\nbonds::BS: the bonds on which the terms are defined\nconfig::C: the configuration of the interanl degrees of freedom\nhalf::Bool: true for generating an Hermitian half of the operators and false for generating the whole\ntable::Table: the index-sequence table\nboundary::B: boundary twist for the generated operators, nothing for no twist\noperators::OS: the generated operators\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Coupling","page":"Terms","title":"QuantumLattices.Essentials.Terms.Coupling","text":"Coupling{V, I<:ID{SimpleID}} <: Element{V, I}\n\nThe coupling intra/inter interanl degrees of freedom at different lattice points.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Couplings","page":"Terms","title":"QuantumLattices.Essentials.Terms.Couplings","text":"Couplings(cps::Coupling...)\n\nA pack of couplings intra/inter interanl degrees of freedom at different lattice points.\n\nAlias for Elements{<:ID{SimpleID}, <:Coupling}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.GenOperators","page":"Terms","title":"QuantumLattices.Essentials.Terms.GenOperators","text":"GenOperators(terms::Tuple{Vararg{Term}}, bonds::Bonds, config::Config, half::Bool; table::Union{Nothing, Table}=nothing)\n\nA set of operators. This is the core of AbstractGenerator.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Generator","page":"Terms","title":"QuantumLattices.Essentials.Terms.Generator","text":"Generator(terms::Tuple{Vararg{Term}}, bonds::Bonds, config::Config;\n    half::Bool=false, table::Union{Table,Nothing}=nothing, boundary::Boundary=plain\n    )\n\nA generator of operators based on terms, configuration of internal degrees of freedom, and boundary twist.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Parameters","page":"Terms","title":"QuantumLattices.Essentials.Terms.Parameters","text":"Parameters{Names}(values::Number...) where Names\n\nA NamedTuple that contain the key-value pairs.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Parameters-Union{Tuple{AbstractGenerator{TS, BS, C, T, B, OS} where {BS<:Bonds, C<:Config, T<:Table, B<:Boundary, OS<:GenOperators}}, Tuple{TS}} where TS<:(NamedTuple{Names, var\"#s12\"} where {Names, var\"#s12\"<:Tuple{Vararg{Term, N} where N}})","page":"Terms","title":"QuantumLattices.Essentials.Terms.Parameters","text":"Parameters(gen::AbstractGenerator) -> Parameters\n\nGet the parameters of the terms of a generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.SubID","page":"Terms","title":"QuantumLattices.Essentials.Terms.SubID","text":"SubID{O<:Tuple, C<:Tuple, S<:Tuple{Vararg{Int}}} <: SimpleID\n\nThe id of a subscript set.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Subscripts","page":"Terms","title":"QuantumLattices.Essentials.Terms.Subscripts","text":"Subscripts{DS, RS, OP<:Tuple, CP<:AbstractString, M<:Tuple{Vararg{Function}}, C<:Tuple{Vararg{Function}}} <: CompositeTuple{OP}\n\nA subscript set of a certain internal degree of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Subscripts-Tuple{Int64}","page":"Terms","title":"QuantumLattices.Essentials.Terms.Subscripts","text":"Subscripts(N::Int)\nSubscripts(opattern::Tuple{Vararg{Union{Integer, Symbol}}})\nSubscripts(opattern::Tuple{Vararg{Union{Integer, Symbol}}}, cpattern::AbstractString)\n\nConstruct a subscript set of a certain internal degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Subscripts-Tuple{Tuple{Vararg{Int64, N} where N}}","page":"Terms","title":"QuantumLattices.Essentials.Terms.Subscripts","text":"(subscripts::Subscripts)(values::Tuple{Vararg{Int}}) -> NTuple{dimension(subscripts), Int}\n\nConstruct a subscript set from an independent variable set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.Term","page":"Terms","title":"QuantumLattices.Essentials.Terms.Term","text":"Term{K, R, I}(value, bondkind, couplings::TermCouplings, amplitude::TermAmplitude, modulate::TermModulate, factor) where {K, R, I}\nTerm{K, R}(id::Symbol, value, bondkind;\n    couplings::Union{Function, Coupling, Couplings, TermCouplings},\n    amplitude::Union{Function, TermAmplitude, Nothing}=nothing,\n    modulate::Union{Function, TermModulate, Bool}=false\n    ) where {K, R}\n\nA term of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.TermAmplitude","page":"Terms","title":"QuantumLattices.Essentials.Terms.TermAmplitude","text":"TermAmplitude(amplitude::Union{Function, Nothing}=nothing)\n\nThe function for the amplitude of a term.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.TermCouplings","page":"Terms","title":"QuantumLattices.Essentials.Terms.TermCouplings","text":"TermCouplings(coupling::Coupling)\nTermCouplings(couplings::Couplings)\nTermCouplings(couplings::Function)\n\nThe function for the couplings of a term.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.TermFunction","page":"Terms","title":"QuantumLattices.Essentials.Terms.TermFunction","text":"TermFunction <: Function\n\nAbstract type for concrete term functions.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.TermModulate","page":"Terms","title":"QuantumLattices.Essentials.Terms.TermModulate","text":"TermModulate(id::Symbol, modulate::Function)\nTermModulate(id::Symbol, modulate::Bool)\n\nThe function for the modulation of a term.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.@couplings-Tuple{Any}","page":"Terms","title":"QuantumLattices.Essentials.Terms.@couplings","text":"@couplings cps -> Couplings\n\nConvert an expression/literal to a set of couplings.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.@subscripts-Tuple{Expr}","page":"Terms","title":"QuantumLattices.Essentials.Terms.@subscripts","text":"@subscripts expr::Expr -> Subscripts\n\nConstruct a subscript set from an opattern and optionally with a constrain.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.@subscripts_str-Tuple{Any}","page":"Terms","title":"QuantumLattices.Essentials.Terms.@subscripts_str","text":"subscripts\"...\" -> Subscripts\n\nConstruct a subscript set from a literal string.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/Terms/#Base.:*-Union{Tuple{RS₂}, Tuple{DS₂}, Tuple{RS₁}, Tuple{DS₁}, Tuple{Subscripts{DS₁, RS₁, OP, CP, M, C} where {OP<:Tuple, CP<:Tuple, M<:Tuple{Vararg{Function, N} where N}, C<:Tuple{Vararg{Function, N} where N}}, Subscripts{DS₂, RS₂, OP, CP, M, C} where {OP<:Tuple, CP<:Tuple, M<:Tuple{Vararg{Function, N} where N}, C<:Tuple{Vararg{Function, N} where N}}}} where {DS₁, RS₁, DS₂, RS₂}","page":"Terms","title":"Base.:*","text":"*(subs₁::Subscripts, subs₂::Subscripts) -> Subscripts\n\nGet the multiplication between two subscript sets.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.:+-Tuple{Term}","page":"Terms","title":"Base.:+","text":"+(term::Term) -> Term\n-(term::Term) -> Term\n*(term::Term, factor) -> Term\n*(factor, term::Term) -> Term\n/(term::Term, factor) -> Term\n\nAllowed arithmetic operations for a term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.:==-Tuple{AbstractGenerator, AbstractGenerator}","page":"Terms","title":"Base.:==","text":"==(gen₁::AbstractGenerator, gen₂::AbstractGenerator) -> Bool\n\nJudge whether generators are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.:==-Tuple{GenOperators, GenOperators}","page":"Terms","title":"Base.:==","text":"==(genops1::GenOperators, genops2::GenOperators) -> Bool\n\nJudge whether two sets of operators are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.:==-Tuple{Term, Term}","page":"Terms","title":"Base.:==","text":"==(term1::Term, term2::Term) -> Bool\n\nJudge whether two terms are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.:==-Union{Tuple{DS₂}, Tuple{DS₁}, Tuple{Subscripts{DS₁, RS, OP, CP, M, C} where {RS, OP<:Tuple, CP<:Tuple, M<:Tuple{Vararg{Function, N} where N}, C<:Tuple{Vararg{Function, N} where N}}, Subscripts{DS₂, RS, OP, CP, M, C} where {RS, OP<:Tuple, CP<:Tuple, M<:Tuple{Vararg{Function, N} where N}, C<:Tuple{Vararg{Function, N} where N}}}} where {DS₁, DS₂}","page":"Terms","title":"Base.:==","text":"==(subs₁::Subscripts, subs₂::Subscripts) -> Bool\n\nJudge whether two subscript sets are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.eltype-Tuple{GenOperators}","page":"Terms","title":"Base.eltype","text":"eltype(ops::GenOperators)\neltype(::Type{<:GenOperators})\n\nGet the eltype of a set of operators, which is defined to be the common operator type of all operators it contains.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.empty!-Tuple{GenOperators}","page":"Terms","title":"Base.empty!","text":"empty!(ops::GenOperators) -> GenOperators\n\nEmpty a set of operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.empty!-Tuple{Generator}","page":"Terms","title":"Base.empty!","text":"empty!(gen::Generator) -> Generator\n\nEmpty the :bonds, :config, :table and :operators of a generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.empty-Tuple{GenOperators}","page":"Terms","title":"Base.empty","text":"empty(ops::GenOperators) -> GenOperators\n\nGet an empty copy of a set of operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.empty-Tuple{Generator}","page":"Terms","title":"Base.empty","text":"empty(gen::Generator) -> Generator\n\nGet an empty copy of a generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.isequal-Tuple{AbstractGenerator, AbstractGenerator}","page":"Terms","title":"Base.isequal","text":"isequal(gen₁::AbstractGenerator, gen₂::AbstractGenerator) -> Bool\n\nJudge whether generators are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.isequal-Tuple{GenOperators, GenOperators}","page":"Terms","title":"Base.isequal","text":"isequal(genops1::GenOperators, genops2::GenOperators) -> Bool\n\nJudge whether two sets of operators are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.isequal-Tuple{Term, Term}","page":"Terms","title":"Base.isequal","text":"isequal(term1::Term, term2::Term) -> Bool\n\nJudge whether two terms are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.isequal-Union{Tuple{DS₂}, Tuple{DS₁}, Tuple{Subscripts{DS₁, RS, OP, CP, M, C} where {RS, OP<:Tuple, CP<:Tuple, M<:Tuple{Vararg{Function, N} where N}, C<:Tuple{Vararg{Function, N} where N}}, Subscripts{DS₂, RS, OP, CP, M, C} where {RS, OP<:Tuple, CP<:Tuple, M<:Tuple{Vararg{Function, N} where N}, C<:Tuple{Vararg{Function, N} where N}}}} where {DS₁, DS₂}","page":"Terms","title":"Base.isequal","text":"isequal(subs₁::Subscripts, subs₂::Subscripts) -> Bool\n\nJudge whether two subscript sets are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.isvalid-Tuple{Subscripts, Tuple{Vararg{Int64, N} where N}}","page":"Terms","title":"Base.isvalid","text":"isvalid(subscripts::Subscripts, values::Tuple{Vararg{Int}}) -> Bool\n\nJudge whether an independent variable set are valid to construct a subscript set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.match","page":"Terms","title":"Base.match","text":"match(params₁::Parameters, params₂::Parameters, atol=atol, rtol=rtol) -> Bool\n\nJudge whether the second set of parameters matches the first.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Terms/#Base.one-Tuple{Term}","page":"Terms","title":"Base.one","text":"one(term::Term) -> Term\n\nGet a unit term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.replace-Tuple{Term}","page":"Terms","title":"Base.replace","text":"replace(term::Term; kwargs...) -> Term\n\nReplace some attributes of a term with key word arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.repr-Tuple{Term, AbstractBond, Config}","page":"Terms","title":"Base.repr","text":"repr(term::Term, bond::AbstractBond, config::Config) -> String\n\nGet the repr representation of a term on a bond with a given config.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.show-Tuple{IO, Subscripts}","page":"Terms","title":"Base.show","text":"show(io::IO, subscripts::Subscripts)\n\nShow a subscript set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.show-Tuple{IO, Term}","page":"Terms","title":"Base.show","text":"show(io::IO, term::Term)\n\nShow a term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.split-Union{Tuple{Subscripts{DS, RS, OP, CP, M, C} where {OP<:Tuple, CP<:Tuple, M<:Tuple{Vararg{Function, N} where N}, C<:Tuple{Vararg{Function, N} where N}}}, Tuple{RS}, Tuple{DS}} where {DS, RS}","page":"Terms","title":"Base.split","text":"split(subscripts::Subscripts) -> Tuple{Vararg{Subscripts}}\n\nSplit a subscript set into individual independent segments.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.valtype-Tuple{Term}","page":"Terms","title":"Base.valtype","text":"valtype(term::Term)\nvaltype(::Type{<:Term)\n\nGet the value type of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#Base.zero-Tuple{Term}","page":"Terms","title":"Base.zero","text":"zero(term::Term) -> Term\n\nGet a zero term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.DegreesOfFreedom.isHermitian-Tuple{Term}","page":"Terms","title":"QuantumLattices.Essentials.DegreesOfFreedom.isHermitian","text":"isHermitian(term::Term) -> Bool\nisHermitian(::Type{<:Term}) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.abbr-Tuple{Term}","page":"Terms","title":"QuantumLattices.Essentials.Terms.abbr","text":"abbr(term::Term) -> Symbol\nabbr(::Type{<:Term}) -> Symbol\n\nGet the abbreviation of the kind of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.couplingcenters-Tuple{Coupling, Point, Val}","page":"Terms","title":"QuantumLattices.Essentials.Terms.couplingcenters","text":"couplingcenters(coupling::Coupling, bond::AbstractBond, info::Val) -> NTuple{rank(coupling), Int}\n\nGet the centers of the coupling on a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.couplinginternals-Tuple{Coupling, AbstractBond, Config, Val}","page":"Terms","title":"QuantumLattices.Essentials.Terms.couplinginternals","text":"couplinginternals(coupling::Coupling, bond::AbstractBond, config::Config, info::Val) -> NTuple{rank(coupling), valtype(config)}\n\nGet the interanl spaces that correspond to where each order of the coupling acts on.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.couplingpoints-Tuple{Coupling, AbstractBond, Val}","page":"Terms","title":"QuantumLattices.Essentials.Terms.couplingpoints","text":"couplingpoints(coupling::Coupling, bond::AbstractBond, info::Val) -> NTuple{rank(coupling), eltype(bond)}\n\nGet the points that correspond to where each order of the coupling acts on.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.ismodulatable-Tuple{Term}","page":"Terms","title":"QuantumLattices.Essentials.Terms.ismodulatable","text":"ismodulatable(term::Term) -> Bool\nismodulatable(::Type{<:Term}) -> Bool\n\nJudge whether a term could be modulated by its modulate function.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.otype-Tuple{AbstractGenerator}","page":"Terms","title":"QuantumLattices.Essentials.Terms.otype","text":"otype(gen::AbstractGenerator)\notype(::Type{<:AbstractGenerator})\n\nGet the operator type of the generated opeators.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.Terms.otype-Tuple{Type{var\"#s153\"} where var\"#s153\"<:Term, Type{var\"#s152\"} where var\"#s152\"<:Config, Type{var\"#s109\"} where var\"#s109\"<:AbstractBond}","page":"Terms","title":"QuantumLattices.Essentials.Terms.otype","text":"otype(T::Type{<:Term}, C::Type{<:Config}, B::Type{<:AbstractBond})\n\nGet the compatible operator type from the type of a term, a configuration of the internal degrees of freedom and a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.kind-Tuple{Term}","page":"Terms","title":"QuantumLattices.Essentials.kind","text":"kind(term::Term) -> Symbol\nkind(::Type{<:Term) -> Symbol\n\nGet the kind of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.reset!-Tuple{GenOperators, Tuple{Vararg{Term, N} where N}, Bonds, Config, Bool}","page":"Terms","title":"QuantumLattices.Essentials.reset!","text":"reset!(genops::GenOperators, terms::Tuple{Vararg{Term}}, bonds::Bonds, config::Config, half::Bool; table::Union{Nothing, Table}=nothing) -> GenOperators\n\nReset a set of operators by new terms, bonds, config, etc..\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.reset!-Tuple{Generator, AbstractLattice}","page":"Terms","title":"QuantumLattices.Essentials.reset!","text":"reset!(gen::Generator, lattice::AbstractLattice) -> Generator\n\nReset a generator by a new lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.update!-Tuple{Term, Vararg{Any, N} where N}","page":"Terms","title":"QuantumLattices.Essentials.update!","text":"update!(term::Term, args...; kwargs...) -> Term\n\nUpdate the value of a term by its modulate function.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Essentials.update!-Union{Tuple{AbstractGenerator{TS, BS, C, T, B, OS} where {BS<:Bonds, C<:Config, T<:Table, B<:Boundary, OS<:GenOperators}}, Tuple{TS}} where TS<:(NamedTuple{Names, var\"#s12\"} where {Names, var\"#s12\"<:Tuple{Vararg{Term, N} where N}})","page":"Terms","title":"QuantumLattices.Essentials.update!","text":"update!(gen::AbstractGenerator; kwargs...) -> typeof(gen)\n\nUpdate the coefficients of the terms in a generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.dimension-Tuple{Subscripts, Int64}","page":"Terms","title":"QuantumLattices.Interfaces.dimension","text":"dimension(subscripts::Subscripts, i::Int) -> Int\ndimension(::Type{<:Subscripts}, i::Int) -> Int\n\nGet the total number of the whole variables of the ith segment of a subscript set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.dimension-Tuple{Subscripts}","page":"Terms","title":"QuantumLattices.Interfaces.dimension","text":"dimension(subscripts::Subscripts) -> Int\ndimension(::Type{<:Subscripts}) -> Int\n\nGet the total number of the whole variables of a subscript set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.expand","page":"Terms","title":"QuantumLattices.Interfaces.expand","text":"expand(term::Term, bond::AbstractBond, config::Config, half::Bool=false; table::Union{Nothing, Table}=nothing) -> Operators\nexpand(term::Term, bonds::Bonds, config::Config, half::Bool=false; table::Union{Nothing, Table}=nothing) -> Operators\n\nExpand the operators of a term on a bond/set-of-bonds with a given config.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.expand!","page":"Terms","title":"QuantumLattices.Interfaces.expand!","text":"expand!(operators::Operators, term::Term, bond::AbstractBond, config::Config, half::Bool=false; table::Union{Nothing, Table}=nothing) -> Operators\nexpand!(operators::Operators, term::Term, bonds::Bonds, config::Config, half::Bool=false; table::Union{Nothing, Table}=nothing) -> Operators\n\nExpand the operators of a term on a bond/set-of-bonds with a given config.\n\nThe half parameter determines the behavior of generating operators, which falls into the following two categories\n\ntrue: \"Hermitian half\" of the generated operators\nfalse: \"Hermitian whole\" of the generated operators\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.expand!-Tuple{Dict{I, O} where {I<:(Tuple{Vararg{AbstractOID, N}} where N), O<:Operator}, AbstractGenerator}","page":"Terms","title":"QuantumLattices.Interfaces.expand!","text":"expand!(operators::Operators, gen::AbstractGenerator) -> Operators\n\nExpand the operators of a generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.expand!-Tuple{Dict{I, O} where {I<:(Tuple{Vararg{AbstractOID, N}} where N), O<:Operator}, GenOperators, Boundary}","page":"Terms","title":"QuantumLattices.Interfaces.expand!","text":"expand!(operators::Operators, ops::GenOperators, boundary::Boundary; kwargs...) -> Operators\n\nExpand the operators with the given boundary twist and term coefficients.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.expand-Tuple{AbstractGenerator}","page":"Terms","title":"QuantumLattices.Interfaces.expand","text":"expand(gen::AbstractGenerator) -> Operators\nexpand(gen::AbstractGenerator, name::Symbol) -> Operators\nexpand(gen::AbstractGenerator, i::Int) -> Operators\nexpand(gen::AbstractGenerator, name::Symbol, i::Int) -> Operators\n\nExpand the operators of a generator:\n\nthe total operators;\nthe operators of a specific term;\nthe operators on a specific bond;\nthe operators of a specific term on a specific bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.expand-Tuple{Subscripts, Tuple{Vararg{Int64, N} where N}}","page":"Terms","title":"QuantumLattices.Interfaces.expand","text":"expand(subscripts::Subscripts, dimensions::Tuple{Vararg{Int}}) -> SbExpand\n\nExpand a subscript set with the given variable ranges.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.id-Tuple{Term}","page":"Terms","title":"QuantumLattices.Interfaces.id","text":"id(term::Term) -> Symbol\nid(::Type{<:Term) -> Symbol\n\nGet the id of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.id-Union{Tuple{Subscripts{DS, RS, OP, CP, M, C} where {RS, OP<:Tuple, CP<:Tuple, M<:Tuple{Vararg{Function, N} where N}, C<:Tuple{Vararg{Function, N} where N}}}, Tuple{DS}} where DS","page":"Terms","title":"QuantumLattices.Interfaces.id","text":"id(subs::Subscripts) -> SubID\n\nGet the id of a subscript set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.rank-Tuple{Subscripts, Int64}","page":"Terms","title":"QuantumLattices.Interfaces.rank","text":"rank(subscripts::Subscripts, i::Int) -> Int\nrank(::Type{<:Subscripts}, i::Int) -> Int\n\nGet the number of the independent variables of the ith segment of a subscript set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.rank-Tuple{Subscripts}","page":"Terms","title":"QuantumLattices.Interfaces.rank","text":"rank(subscripts::Subscripts) -> Int\nrank(::Type{<:Subscripts}) -> Int\n\nGet the total number of the independent variables of a subscript set.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Interfaces.rank-Tuple{Term}","page":"Terms","title":"QuantumLattices.Interfaces.rank","text":"rank(term::Term) -> Int\nrank(::Type{<:Term) -> Int\n\nGet the rank of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Terms/#QuantumLattices.Mathematics.AlgebraOverFields.idtype-Tuple{GenOperators}","page":"Terms","title":"QuantumLattices.Mathematics.AlgebraOverFields.idtype","text":"idtype(ops::GenOperators)\nidtype(::Type{<:GenOperators})\n\nGet the idtype of a set of operators, which is defined to be the common idtype of all operators it contains.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"CurrentModule = QuantumLattices.Prerequisites.Traits\nDocTestFilters = [r\"var\\\".*\\\"\", r\"generic function with [0-9]* method\", r\".*s \\(.*\\% GC\\)\", r\"evals/sample:.*\"]\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../../src/\")\n    using QuantumLattices.Prerequisites.Traits\n    import QuantumLattices.Prerequisites.Traits: isparameterbound, parameternames, contentnames, getcontent\nend","category":"page"},{"location":"man/Prerequisites/Traits/#Traits","page":"Traits","title":"Traits","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"This module defines some trait functions and trait types that are useful to the package.","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Generally speaking, traits in Julia could fall into two categories according to their usages, the first may be term as \"type helpers\" and the second are usually called \"Holy traits\" named after Tim Holy. Type helpers aim at the inquiry, alteration and computation of the compile-time information of types, while Holy traits can be applied as an alternative to multi-inheritance by use of the Julia multidispatch feature.","category":"page"},{"location":"man/Prerequisites/Traits/#Type-helpers","page":"Traits","title":"Type helpers","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Type helpers are important for the generic programming in Julia, especially in the design of generic interfaces and abstract types.","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Let's see a simple situation, i.e. the elemental addition of two vectors of numbers. The numbers can assume different types and the type of the result depends on both of them, for example, the result between two vectors of integers is a vector of integers while that between a vector of integers and a vector of floats is a vector of floats. Of course, one can explicitly define every elemental addition function between any two different types of vectors of numbers, like this:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"# wrong design pattern\n\nfunction elementaladdition(v1::Vector{Int64}, v2::Vector{Int64})\n    result = Int[]\n    ...\nend\nfunction elementaladdition(v1::Vector{Int64}, v2::Vector{Float64})\n    result = Float64[]\n    ...\nend\n...\n...","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Writing down all such methods is already a heavy repetition. What's worse, you will quickly find that a lot more functions, such as the elemental subtraction, elemental multiplication and elemental division, are waiting for you to implement. This is a total disaster.","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The correct strategy is to define the promotion rule of any two types of numbers and use it to define the type of the result:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"# correct design pattern\n\npromotion(::Type{Int64}, ::Type{Int64}) = Int64\npromotion(::Type{Int64}, ::Type{Float64}) = Float64\n...\n...\n\nfunction elementaladdition(v1::Vector{T1}, v2::Vector{T2}) where {T1<:Number, T2<:Number}\n    result = promotion(T1, T2)[]\n    ...\nend\nfunction elementalsubtraction(v1::Vector{T1}, v2::Vector{T2}) where {T1<:Number, T2<:Number}\n    result = promotion(T1, T2)[]\n    ...\nend\n...\n...","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The promotion rule applies equally to all the arithmetic operations on numbers. Therefore, tedious code repetition could be avoided with it. In fact, similar promotion rules have already been defined in Julia base, and the default implementations of arithmetic operations in Julia are indeed based on them (see Base.promote_rule and Base.promote_type). When new user-defined numeric types are introduced, the only things you need to do is to add new promotion rules and implement a few basic arithmetic functions for these new types. Then quite a lot of generic codes could apply to them without any modification.","category":"page"},{"location":"man/Prerequisites/Traits/#Type-helpers-with-type-parameters","page":"Traits","title":"Type helpers with type parameters","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The input and output types of a promotion rule are known at compile time, thus, the promotion rule is a trait function aiming at the computation of compile-time information of types. Trait functions dealing with the inquiries of compile-time information of types are also widely used in Julia, such as the eltype function of Vector:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> eltype(Vector{String})\nString","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"For a user-defined parametric type, it is also useful to provide an inquiry function to access to the type parameters:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> struct Hi{T<:Number}\n           content::T\n       end\n       contenttype(::Type{Hi{T}}) where T<:Number = T\n       contenttype(Hi{Int64})\nInt64","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"However, the above defined function contenttype could not apply to a UnionAll type, such as Hi{<:Real}:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> contenttype(Hi{<:Real})\nERROR: MethodError: no method matching contenttype(::Type{Hi{var\"#s1\"} where var\"#s1\"<:Real})\n[...]","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"In fact in Julia base, all such inquiry functions, e.g., the eltype function, work poor for the UnionAll types:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> eltype(Vector{<:Real})\nAny","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"In concept, eltype(Vector{<:Real} should return Real instead of Any as every element in Vector{<:Real} is indeed a real number. Similarly, we expect that contenttype(Hi{<:Real}) should also give us Real. Unfortunately, functions defined in the similar form like this could never achieve such goals. Julia base doesn't provide generic functions to access or change the information of the parameters of a type. In this module, we try to fill this gap with a set of generic trait functions.","category":"page"},{"location":"man/Prerequisites/Traits/#Access-or-change-the-type-parameters-by-their-position-orders","page":"Traits","title":"Access or change the type parameters by their position orders","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The most direct information of the parameters of a type is their position orders. We provide parametertype to access to them by such information:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> parametertype(Hi{<:Real}, 1)\nReal\n\njulia> parametertype(Vector{<:Real}, 1)\nReal\n\njulia> parametertype(Vector{<:Real}, 2)\n1","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"You can use parametercount to inquire the total number of the parameters of a type:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> parametercount(Hi)\n1\n\njulia> parametercount(Vector)\n2","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"It is noted that Vector has 2 type parameters because it is just a type alias for Array{T, 1} where T.","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"To change the parameters of a type, reparameter can be used:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> reparameter(Hi{Int64}, 1, Real)\nHi{Real}\n\njulia> reparameter(Vector{Int64}, 1, Real)\nVector{Real} (alias for Array{Real, 1})\n\njulia> reparameter(Vector{<:Real}, 2, 3)\nArray{var\"#s1\",3} where var\"#s1\"<:Real\n\njulia> reparameter(Hi{Int64}, 1, Real, false)\nHi{Real}\n\njulia> reparameter(Hi{Int64}, 1, Real, true)\nHi{var\"#s2\"} where var\"#s2\"<:Real","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"We want to remark that by providing the fourth positional argument with the true value, a UnionAll type could be generated. When the fourth positional argument is omitted, it is actually determined by another trait function, i.e., isparameterbound. This function judges whether an input type should be considered as the upper bound of the new parameter of a type. By default, it is always defined to be false. This function can be overloaded to change the behavior for a certain type:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> isparameterbound(::Type{<:Hi}, ::Val{1}, D) = !isconcretetype(D);\n\njulia> reparameter(Hi, 1, Real)\nHi{var\"#s3\"} where var\"#s3\"<:Real","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The second positional argument of isparameterbound must be of type Val because in principle you should be able to assign different behaviors for different parameters of a type separately. If it is of type Integer, a single overloading would change the behaviors for all.","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Besides, you can inquire all the parameters of a type by parametertypes:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> parametertypes(Hi{<:Real})\nTuple{Real}\n\njulia> parametertypes(Vector{Int64})\nTuple{Int64, 1}","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The obtained type parameters are stored as those of a Tuple.","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"At the same time, you can change all the parameters of a type by fulltype:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> fulltype(Hi{Int64}, Tuple{Real})\nHi{var\"#s4\"} where var\"s#4\"<:Real\n\njulia> fulltype(Hi{Int64}, Tuple{Real}, (false,))\nHi{Real}\n\njulia> fulltype(Vector{Int64}, Tuple{Real, 2})\nMatrix{Real} (alias for Array{Real, 2})\n\njulia> fulltype(Vector{Int64}, Tuple{Real, 2}, (true, false))\nMatrix{var\"#s5\"} where var\"#s5\"<:Real (alias for Array{var\"#s5\", 2} where var\"#s5\"<:Real)","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Like reparameter, the last positional argument of fulltype could determine whether the corresponding types specified by the type parameters of the input Tuple should be considered as the upper bounds of the new parameters of a type. When this argument is omitted, it is determined by another trait function isparameterbounds, which successively calls the isparameterbound function to determine the behaviors for all the parameters of a type as the literal indicates.","category":"page"},{"location":"man/Prerequisites/Traits/#Associate-type-parameters-with-names","page":"Traits","title":"Associate type parameters with names","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Sometimes, it is more convenient to associate names with the parameters of a type, and then access or change them by their names. This can be done by overloading the parameternames trait function for a certain type:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> parameternames(::Type{<:Hi}) = (:content,)\nparameternames (generic function with 3 methods)","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Now, you can inquire the name of a type parameter by parametername with the given position order or vice versa by parameterorder:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> parametername(Hi, 1)\n:content\n\njulia> parameterorder(Hi, :content)\n1","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"You can also inquire whether a type has a parameter with the given name by hasparameter:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> hasparameter(Hi, :content)\ntrue\n\njulia> hasparameter(Hi, :others)\nfalse","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"And parametertype and reparameter can be applied by the name of a type parameter instead of its position order:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> parametertype(Hi{<:Real}, :content)\nReal\n\njulia> reparameter(Hi{Int}, :content, Real)\nHi{Real}\n\njulia> reparameter(Hi{Int}, :content, Real, true)\nHi{var\"#s6\"} where var\"#s6\"<:Real","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"To change the reparameter behavior when its last positional argument is omitted, you should overload the isparameterbound function accordingly, e.g.:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> isparameterbound(::Type{<:Hi}, ::Val{:content}, D) = !isconcretetype(D);\n\njulia> reparameter(Hi{Int}, :content, Real)\nHi{var\"#s7\"} where var\"#s7\"<:Real","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"note: Note\nAccessing or altering a parameter of a type by its name is independent from that by its position order. Thus, even the following methodisparameterbound(::Type{<:Hi}, ::Val{1}, D)has been overloaded, it doesn't affect the result of the function call likereparameter(Hi{Int}, :content, Real)Rather, it only affect the result of the function call likereparameter(Hi{Int}, 1, Real)To change the default behavior of the former function call, you must overload the following method manually as wellisparameterbound(::Type{<:Hi}, ::Val{:content}, D)","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"A new trait function parameterpair is provided to inquire the name-type pair of a parameter of a type:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> parameterpair(Hi{<:Real}, 1)\nPair{:content, Real}\n\njulia> parameterpair(Hi{<:Real}, :content)\nPair{:content, Real}","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"And a new trait function parameterpairs can be used to inquire all the name-type pairs of the parameters of a type:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> parameterpairs(Hi{<:Real})\nNamedTuple{(:content,), Tuple{Real}}","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The parameters of a type can be altered all at once by giving the name-type pairs to fulltype:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}}, (false,))\nHi{Real}\n\njulia> fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}}, (true,))\nHi{var\"#s8\"} where var\"#s8\"<:Real\n\njulia> fulltype(Hi{Int}, NamedTuple{(:content,),Tuple{Real}})\nHi{var\"#s9\"} where var\"#s9\"<:Real","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Here, the last positional argument can be omitted whose default value would be determined by the isparameterbounds function which successively calls the isparameterbound function on each of the named parameter. Note that similar to the situation of the reparameter function in this subsection, the isparameterbound function called here is also the version that takes the parameter name as the input rather than that of the position order.","category":"page"},{"location":"man/Prerequisites/Traits/#Type-helpers-with-predefined-contents","page":"Traits","title":"Type helpers with predefined contents","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Julia abstract types don't have any field or attribute. They are only tags on the type tree. However, we may expect sometimes an abstract type to possess some kind of predefined content so that the design of some methods could be highly simplified. For example, we may need an abstract type that describes a composite vector. Apparently, it should have a field that is the vector contained in it. Of course, we can appoint a fixed field name with it and force every concrete subtype must contain such a field. In such a design pattern, the name of this field in every concrete subtype must be kept unchanged, which may be annoying when it conflicts with that of another field. What's worse, a predefined content of an abstract type is not always limited to a certain field. Maybe we need more than one fields to construct such a content. The just mentioned design pattern cannot deal with such situations.","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Here, we provide a set of trait functions to help the design of abstract types with predefined contents. We take the case of composite vector for illustration, and the generalization to other situations is straightforward. First, the trait function contentnames should be overloaded to define the names of the predefined contents:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> abstract type CompositeVector{T} end\n       contentnames(::Type{<:CompositeVector}) = (:content,);","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Then you can inquire the total number of predefined contents by contentcount, inquire the name of a predefined content with its position order by contentname, and judge whether a type has a predefined content with a given name by hascontent:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> contentcount(CompositeVector)\n1\n\njulia> contentname(CompositeVector, 1)\n:content\n\njulia> hascontent(CompositeVector, :content)\ntrue\n\njulia> hascontent(CompositeVector, :value)\nfalse","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The key is the interface getcontent, which defines how to get the value of the predefined content. For the simple case when the predefined content just corresponds to a field, and also the field name of the predefined content coincides with the content name, the overloading of getcontent can be omitted, e.g.:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> struct AnotherCompositeVector{T} <: CompositeVector{T}\n           content::Vector{T}\n       end;\n\njulia> v = AnotherCompositeVector([1, 2, 3])\n       getcontent(v, :content)\n3-element Vector{Int64}:\n 1\n 2\n 3","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"For the cases when a predefined contents does not share the same name with a certain field, or even it is not limited to only one certain field, you must implement your own getcontent manually. Let's see two typical examples:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> struct DifferentFieldName{T} <: CompositeVector{T}\n           data::Vector{T}\n       end\n       getcontent(v::DifferentFieldName, ::Val{:content}) = v.data;\n\njulia> struct BeyondSingleField{T} <: CompositeVector{T}\n           firsthalf::Vector{T}\n           secondhalf::Vector{T}\n       end\n       getcontent(v::BeyondSingleField, ::Val{:content}) = [v.firsthalf; v.secondhalf];\n\njulia> v = DifferentFieldName([1, 2, 3])\n       getcontent(v, :content)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> v = BeyondSingleField([1, 2, 3], [4, 5, 6])\n       getcontent(v, :content)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Note that for the method overloading of getcontent, the second argument is of type Val{:content}. This is convenient because in principle an abstract type could have more than only one predefined content, thus, the behaviors of the getcontent function could be defined separately for different predefined contents in this way. In fact, the function call getcontent(m, contentname) is just an alias for getcontent(m, contentname|>Val).","category":"page"},{"location":"man/Prerequisites/Traits/#Holy-traits","page":"Traits","title":"Holy traits","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"As an emergent feature of Julia, basically speaking, a Holy trait is a Julia type that could direct the generic function of a user-defined type to a certain implementation based on the Julia multi-dispatch mechanism. For different user-defined types, they could be assigned with different Holy traits, leading to different implementations of the same generic interface. Since the information of Holy traits are known at compile time, such design pattern doesn't affect the runtime efficiency as long as type stability is ensured.","category":"page"},{"location":"man/Prerequisites/Traits/#Alternative-of-multi-inheritance","page":"Traits","title":"Alternative of multi-inheritance","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Maybe the most common application of Holy traits is to serve as the alternative of multi-inheritance. Let's see a simple scenario. You have defined an abstract type. It is natural to demand that for every concrete subtype of it, a pair of instances could be compared and judge whether they are equivalent to each other by the value. Unfortunately, for a new user-defined type, the default == function in Julia actually judges whether they are the same object, but not equal to each other by the value. Therefore, you need to define your own == function for this abstract type. However, you may need define a lot of abstract types when you are developing a Julia package. It is annoying if such simple functions must be written for each of them. In other languages like Python, this could be solved with the help of multi-inheritance. But Julia does not support multi-inheritance. The common way is to use Holy traits. For example, the above issue could be solved like this:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> struct Equivalence end\n       const equivalence = Equivalence()\n       function Base.:(==)(::Equivalence, o1, o2)\n           n1, n2 = fieldcount(typeof(o1)), fieldcount(typeof(o2))\n           n1≠n2 && return false\n           for i = 1:n1\n               getfield(o1, i)≠getfield(o2, i) && return false\n           end\n           return true\n       end;\n\njulia> abstract type TypeWithEquivalence end\n       Base.:(==)(o1::TypeWithEquivalence, o2::TypeWithEquivalence) = ==(equivalence, o1, o2);\n\njulia> struct ConcreteTypeWithEquivalence{F1, F2} <: TypeWithEquivalence\n           f1::F1\n           f2::F2\n       end;\n\njulia> a1 = ConcreteTypeWithEquivalence((\"a\", \"b\", \"c\"), [1, 2, 3])\n       a2 = ConcreteTypeWithEquivalence((\"a\", \"b\", \"c\"), [1.0, 2.0, 3.0])\n       a1 == a2\ntrue","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Here, the type Equivalence is the Holy trait that helps the abstract type TypeWithEquivalence to implement the == function, which applies equally to any other types.","category":"page"},{"location":"man/Prerequisites/Traits/#Type-stability-and-the-generated-function-trick","page":"Traits","title":"Type stability and the generated function trick","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"However, the story does not end up here. If you are concerned about the code efficiency, you may find that the above implementation is not type stable:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> using BenchmarkTools\n       @benchmark $a1 == $a2\nBenchmarkTools.Trial:\n  memory estimate:  256 bytes\n  allocs estimate:  6\n  --------------\n  minimum time:     90.938 ns (0.00% GC)\n  median time:      97.188 ns (0.00% GC)\n  mean time:        112.537 ns (11.85% GC)\n  maximum time:     3.194 μs (94.84% GC)\n  --------------\n  samples:          10000\n  evals/sample:     960","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"The memory allocation occurs when the == function tries to compare the values of getfield(o1, i) and getfield(o2, i) because in principle the types of these values depend on the runtime value of the variable i. To ensure type stability, the generated function trick can be utilized:","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"julia> struct EfficientEquivalence end\n       const efficientequivalence = EfficientEquivalence()\n       @generated function Base.:(==)(::EfficientEquivalence, o1, o2)\n           n1, n2 = fieldcount(o1), fieldcount(o2)\n           n1≠n2 && return false\n           expr = :(getfield(o1, 1) == getfield(o2, 1))\n           for i = 2:n1\n               expr = Expr(:&&, expr, :(getfield(o1, $i) == getfield(o2, $i)))\n           end\n           return expr\n       end;\n\njulia> abstract type TypeWithEfficientEquivalence end\n       function Base.:(==)(o1::TypeWithEfficientEquivalence, o2::TypeWithEfficientEquivalence)\n           return ==(efficientequivalence, o1, o2)\n       end;\n\njulia> struct ConcreteTypeWithEfficientEquivalence{F1, F2} <: TypeWithEfficientEquivalence\n           f1::F1\n           f2::F2\n       end;\n\njulia> a1 = ConcreteTypeWithEfficientEquivalence((\"a\", \"b\", \"c\"), [1, 2, 3])\n       a2 = ConcreteTypeWithEfficientEquivalence((\"a\", \"b\", \"c\"), [1.0, 2.0, 3.0])\n       a1 == a2\ntrue\n\njulia> @benchmark $a1 == $a2\nBenchmarkTools.Trial:\n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     13.413 ns (0.00% GC)\n  median time:      13.714 ns (0.00% GC)\n  mean time:        13.938 ns (0.00% GC)\n  maximum time:     306.206 ns (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     999","category":"page"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"At runtime of the generated == function, it compares the values of getfield(o1, 1) and getfield(o2, 1), getfield(o1, 2) and getfield(o2, 2), etc., whose types are known at compile time. Therefore, type stability could be ensured.","category":"page"},{"location":"man/Prerequisites/Traits/#EfficientOperations","page":"Traits","title":"EfficientOperations","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"EfficientOperations is a Holy trait defined in this module that packs several common operations, such as ==/isequal, </isless, isapprox and replace, to help other (abstract) types to implement such functions by passing efficientoperations as the first argument, just as illustrated above. See the manual for more detailed information.","category":"page"},{"location":"man/Prerequisites/Traits/#Manual","page":"Traits","title":"Manual","text":"","category":"section"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"Modules = [Traits]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.efficientoperations","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.efficientoperations","text":"efficientoperations\n\nIndicate that the efficient operations, i.e. \"==\"/\"isequal\", \"<\"/\"isless\" or \"replace\", will be used.\n\n\n\n\n\n","category":"constant"},{"location":"man/Prerequisites/Traits/#Core.DataType-Tuple{DataType}","page":"Traits","title":"Core.DataType","text":"DataType(T::DataType) -> DataType\nDataType(T::UnionAll) -> DataType\n\nGet the DataType.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#Base.:<-Tuple{QuantumLattices.Prerequisites.Traits.EfficientOperations, Any, Any}","page":"Traits","title":"Base.:<","text":"<(::EfficientOperations, o1, o2) -> Bool\n\nCompare two objects and judge whether the first is less than the second.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#Base.:==-Tuple{QuantumLattices.Prerequisites.Traits.EfficientOperations, Any, Any}","page":"Traits","title":"Base.:==","text":"==(::EfficientOperations, o1, o2) -> Bool\n\nCompare two objects and judge whether they are eqaul to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#Base.isapprox-Tuple{QuantumLattices.Prerequisites.Traits.EfficientOperations, Any, Any}","page":"Traits","title":"Base.isapprox","text":"isapprox(::EfficientOperations, o1, o2; atol=atol, rtol=rtol) -> Bool\nisapprox(::EfficientOperations, fields::Union{Union{Nothing, Integer, Symbol}, Tuple{Vararg{Union{Integer, Symbol}}}}, o1, o2; atol=atol, rtol=rtol) -> Bool\nisapprox(::EfficientOperations, ::Val{fields}, o1, o2; atol=atol, rtol=rtol) where fields -> Bool\n\nCompare two objects and judge whether they are inexactly equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#Base.isequal-Tuple{QuantumLattices.Prerequisites.Traits.EfficientOperations, Any, Any}","page":"Traits","title":"Base.isequal","text":"isequal(::EfficientOperations, o1, o2) -> Bool\n\nCompare two objects and judge whether they are eqaul to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#Base.isless-Tuple{QuantumLattices.Prerequisites.Traits.EfficientOperations, Any, Any}","page":"Traits","title":"Base.isless","text":"isless(::EfficientOperations, o1, o2) -> Bool\n\nCompare two objects and judge whether the first is less than the second.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#Base.replace-Tuple{QuantumLattices.Prerequisites.Traits.EfficientOperations, Any}","page":"Traits","title":"Base.replace","text":"replace(::EfficientOperations, o; kwargs...) -> typeof(o)\n\nReturn a copy of the input object with some of the field values replaced by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#Base.supertype-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"Traits","title":"Base.supertype","text":"supertype(T, termination::Symbol) -> DataType\n\nGet the supertype of T till termination.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.contentcount-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.contentcount","text":"contentcount(::Type{T}) where T -> Int\n\nFor a type T, get the number of its predefined contents.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.contentname-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.contentname","text":"contentname(::Type{T}, i::Integer) where T -> Symbol\n\nFor a type T, get the name of its ith predefined content.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.contentnames-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.contentnames","text":"contentnames(::Type{T}) where T -> Tuple{Vararg{Symbol}}\n\nFor a type T, define the names of its predefined contents.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.contentorder-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.contentorder","text":"contentorder(::Type{T}, name::Symbol) where T -> Int\n\nFor a type T, get the position order of a predefined content by the name.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.contenttype-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.contenttype","text":"contenttype(::Type{T}, name::Symbol) where T\ncontenttype(::Type{T}, ::Val{name}) where {T, name}\n\nFor a type T, get the type of a predefined content by the name.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.contenttypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.contenttypes","text":"contenttypes(::Type{T}) where T\n\nFor a type T, get the types of its predefined contents.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.dissolve","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.dissolve","text":"dissolve(m, f::Function=identity, args::Tuple=(), kwargs::NamedTuple=NamedTuple()) -> Tuple\n\nConvert m to a tuple by the function f applied elementally to its contents with the extra positional arguments (args) and keyword arguments (kwargs). \n\nThe underlying called interface is the dissolve function when f is applied to each content of m:\n\ndissolve(m, Val(name), f, args, kwargs)\n\nHere, name is the name of a content of m.\n\nBasically, the rule of how f operates on each field of m can be overriden by redefining the above dissolve function. !!!note    The default dissolve function ignores the operation of function f and just return the content value of m.\n\n\n\n\n\n","category":"function"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.dissolve-Union{Tuple{name}, Tuple{Any, Val{name}, Function, Tuple, NamedTuple}} where name","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.dissolve","text":"dissolve(m, ::Val{name}, f::Function, args::Tuple, kwargs::NamedTuple) where name\n\nDisolve the content specified by name of m by the function f applied with the extra positional arguments (args) and keyword arguments (kwargs).\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.fulltype-Union{Tuple{PS}, Tuple{T}, Tuple{Type{T}, Type{PS}}, Tuple{Type{T}, Type{PS}, Tuple{Vararg{Bool, N} where N}}} where {T, PS<:Tuple}","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.fulltype","text":"fulltype(::Type{T}, ::Type{PS}, ubs::Tuple{Vararg{Bool}}=isparameterbounds(T, PS)) where {T, PS<:Tuple}\nfulltype(::Type{T}, ::Type{PS}, ubs::Tuple{Vararg{Bool}}=isparameterbounds(T, PS)) where {T, PS<:NamedTuple}\n\nGet the full type of type T with the type parameters replaced by those of PS.\n\nHere, ubs determines whether the new type parameter should be considered as the upper bound accordingly.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.getcontent-Tuple{Any, Integer}","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.getcontent","text":"getcontent(m, i::Integer)\ngetcontent(m, name::Symbol)\ngetcontent(m, ::Val{name}) where name\n\nGet the value of the predefined content of m. \n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.hascontent-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.hascontent","text":"hascontent(::Type{T}, name::Symbol) where T -> Bool\n\nFor a type T, judge whether it has a predefined content specified by name.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.hasparameter-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.hasparameter","text":"hasparameter(::Type{T}, name::Symbol) where T -> Bool\n\nFor type T, judge whether it has a type parameter specified by name.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.isparameterbound-Union{Tuple{T}, Tuple{Type{T}, Integer, Any}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.isparameterbound","text":"isparameterbound(::Type{T}, i::Integer, D) where T -> Bool\nisparameterbound(::Type{T}, name::Symbol, D) where T -> Bool\nisparameterbound(::Type{}, ::Val{}, ::Any) -> Bool\n\nFor a type T, judge whether a type D should be considered as the upper bound of one of its type parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.isparameterbounds-Union{Tuple{PS}, Tuple{T}, Tuple{Type{T}, Type{PS}}} where {T, PS<:Tuple}","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.isparameterbounds","text":"isparameterbounds(::Type{T}, ::Type{PS}) where {T, PS<:Tuple} -> Tuple{Vararg{Bool}}\nisparameterbounds(::Type{T}, ::Type{PS}) where {T, PS<:NamedTuple} -> Tuple{Vararg{Bool}}\n\nFor a type T, judge whether the types specified by PS should be considered as the upper bounds of its corresponding type parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.parametercount-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.parametercount","text":"parametercount(::Type{T}) where T -> Int\n\nFor a type T, get the number of its type parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.parametername-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.parametername","text":"parametername(::Type{T}, i::Integer) where T -> Symbol\n\nFor a type T, get the name of its ith type parameter.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.parameternames-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.parameternames","text":"parameternames(::Type{T}) where T -> Tuple{Vararg{Symbol}}\n\nFor a type T, get the names of all its type parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.parameterorder-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.parameterorder","text":"parameterorder(::Type{T}, name::Symbol) where T -> Int\n\nFor a type T, get the order of one of its type parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.parameterpair-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.parameterpair","text":"parameterpair(::Type{T}, name::Symbol) where T\nparameterpair(::Type{T}, i::Integer) where T\n\nFor type T, get the name-type pair of one of its type parameters.\n\nThe result is stored in the type parameters of a Pair.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.parameterpairs-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.parameterpairs","text":"parameterpairs(::Type{T}) where T\n\nFor a type T, get the name-type pairs of all its type parameters.\n\nThe return types are stored in the type parameters of a NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.parametertype-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.parametertype","text":"parametertype(::Type{T}, name::Symbol) where T\nparametertype(::Type{T}, i::Integer) where T\n\nFor a type T, get the type of one of its type parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.parametertypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.parametertypes","text":"parametertypes(::Type{T}) where T\n\nFor a type T, get the types of all its type parameters.\n\nThe returned types are stored in the type parameters of a Tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.promoteparameters-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{T1}, Type{T2}}} where {T1<:NamedTuple, T2<:NamedTuple}","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.promoteparameters","text":"promoteparameters(::Type{T1}, ::Type{T2}) where {T1<:NamedTuple, T2<:NamedTuple}\n\nPromote the types specified by two named tuples with the same names accordingly.\n\nThe result is stored in the type parameters of a NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.rawtype-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.rawtype","text":"rawtype(::Type{T}) where T -> DataType/UnionAll\n\nGet the \"raw part\" of a type. That is, the type without all its type parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/#QuantumLattices.Prerequisites.Traits.reparameter-Union{Tuple{T}, Tuple{Type{T}, Integer, Any}, Tuple{Type{T}, Integer, Any, Bool}} where T","page":"Traits","title":"QuantumLattices.Prerequisites.Traits.reparameter","text":"reparameter(::Type{T}, i::Integer, P, ub::Bool=isparameterbound(T, i, P)) where T\nreparameter(::Type{T}, name::Symbol, P, ub::Bool=isparameterbound(T, name, P)) where T\n\nFor a type T, replace the type of its ith type parameter with P. Here, ub determines whether P should be considered as the upper bound. \n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Traits/","page":"Traits","title":"Traits","text":"DocTestSetup = nothing","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"CurrentModule = QuantumLattices.Mathematics.AlgebraOverFields","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"push!(LOAD_PATH, \"../../../../src/\")\nusing QuantumLattices.Mathematics.AlgebraOverFields","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/#Algebra-over-fields","page":"Algebra over fields","title":"Algebra over fields","text":"","category":"section"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"An algebra over a field is a vector space over that field, in which a bilinear operator (often called the \"multiplication\") between vectors is defined.","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"With the help of the structure constants of the algebra, the result of the bilinear operation between any arbitrary two vectors can be expressed by a sum of individual ones. Therefore, in principle, an algebra can be represented by the complete basis set of its corresponding vector space and a rank-3 tensor encapsulating its structure constants. It is noted that the \"bilinear operation\" is not restricted to the usual multiplication only. For example, it is the commutator, which is a composition of the usual multiplication and subtraction (for any A and B, the commutator [A, B] is defined as [A, B]≝AB-BA) that serves as the bilinear operator for Lie algebras. In this module, for scalars in the field and elements in the algebra, we only provide the interfaces of the scalar multiplication (including the scalar division) between a scalar and an element, the addition (including the subtraction) and the usual multiplication between two elements. Other complicated operations should be composed from these basic ones.","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/#SimpleID-and-ID","page":"Algebra over fields","title":"SimpleID and ID","text":"","category":"section"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"SimpleID is the building block of the id system of an algebra over a field, while ID defines the specific identifier of an element in that algebra.","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"Generally, the usual multiplication between two elements of an algebra is not commutable, and the rank of the multiplication is just the add-up before the simplification with the help of the algebra structure. We thus use a simple id to denote a single basis of the corresponding vector space, and an id to denote the identifier of an element. With the help of the direct product (⊗) of two ids, an over complete id system designed for the whole algebra is constructed. This id system is redundant because it does not reflects the structure constants of the algebra, which reduces independent basis elements. Extra mechanisms should be provided to kill this redundancy, which goes beyond the current module. Users should define them themselves.","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/#Element-and-Elements","page":"Algebra over fields","title":"Element and Elements","text":"","category":"section"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"Element defines a single element of an algebra while Elements defines an expression composed of several elements from an algebra.","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"An Element must have two predefined contents:","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"value::Number: the coefficient of the element\nid::ID: the id of the element","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"Arithmetic operations (+, -, *, /) between a scalar, an Element or an Elements is defined. See Manual for details.","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/#Manual","page":"Algebra over fields","title":"Manual","text":"","category":"section"},{"location":"man/Mathematics/AlgebraOverFields/","page":"Algebra over fields","title":"Algebra over fields","text":"Modules = [AlgebraOverFields]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.Element","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.Element","text":"Element{V, I<:ID{SimpleID}}\n\nAn element of an algebra over a field.\n\nBasically, a concrete subtype should contain two predefined contents:\n\nvalue::V: the coefficient of the element\nid::I: the id of the element\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.Elements","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.Elements","text":"Elements{I<:ID{SimpleID}, M<:Element} <: AbstractDict{I, M}\n\nAn set of elements of an algebra over a field.\n\nType alias for Dict{I<:ID{SimpleID}, M<:Element}. Similar iterms are automatically merged thanks to the id system.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.Elements-Tuple{Any}","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.Elements","text":"Elements(ms)\nElements(ms::Pair{I, M}...) where {I<:ID{SimpleID}, M<:Element}\nElements(ms::Element...)\n\nGet the set of elements with similar items merged.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.ID","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.ID","text":"ID{I<:SimpleID, N}\n\nThe (composite) id system of an algebra over a field.\n\nType alias for NTuple{N, I} where {N, I<:SimpleID}.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.ID-Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N} where N}","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.ID","text":"ID(ids::SimpleID...)\nID(ids::NTuple{N, SimpleID}) where N\n\nGet the composite id from simple ids.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.ID-Union{Tuple{M}, Tuple{N}, Tuple{SID}, Tuple{Type{SID}, Vararg{Tuple{Vararg{Any, N}}, M}}} where {SID<:QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N, M}","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.ID","text":"ID(::Type{SID}, attrs::Vararg{NTuple{N}, M}) where {SID<:SimpleID, N, M}\n\nGet the composite id from the components of simple ids.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.Scalar","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.Scalar","text":"Scalar{V}\n\nScalar element.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.SimpleID","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.SimpleID","text":"SimpleID <: NamedVector\n\nA simple id is the building block of the id system of an algebra over a field.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/AlgebraOverFields/#Base.:*-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Nothing}","page":"Algebra over fields","title":"Base.:*","text":"*(m::Element, ::Nothing) -> Nothing\n*(::Nothing, m::Element) -> Nothing\n*(factor::Number, m::Element) -> Element\n*(m::Element, factor::Number) -> Element\n*(m1::Element, m2::Element) -> Element\n*(ms::Elements, ::Nothing) -> Nothing\n*(::Nothing, ms::Elements) -> Nothing\n*(factor::Number, ms::Elements) -> Elements\n*(ms::Elements, factor::Number) -> Elements\n*(m::Element, ms::Elements) -> Elements\n*(ms::Elements, m::Element) -> Elements\n*(ms1::Elements, ms2::Elements) -> Elements\n\nOverloaded * operator for element-scalar multiplications and element-element multiplications of an algebra over a field.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.:*-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, QuantumLattices.Mathematics.AlgebraOverFields.SimpleID}","page":"Algebra over fields","title":"Base.:*","text":"*(sid1::SimpleID, sid2::SimpleID) -> ID{SimpleID}\n*(sid::SimpleID, cid::ID{SimpleID}) -> ID{SimpleID}\n*(cid::ID{SimpleID}, sid::SimpleID) -> ID{SimpleID}\n*(cid1::ID{SimpleID}, cid2::ID{SimpleID}) -> ID{SimpleID}\n\nGet the product of the id system.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.:+-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.:+","text":"+(m::Element) -> typeof(m)\n+(m::Element, ::Nothing) -> typeof(m)\n+(::Nothing, m::Element) -> typeof(m)\n+(m::Element, factor::Number) -> Elements\n+(factor::Number, m::Element) -> Elements\n+(m1::Element, m2::Element) -> Elements\n+(ms::Elements) -> typeof(ms)\n+(ms::Elements, ::Nothing) -> typeof(ms)\n+(::Nothing, ms::Elements) -> typeof(ms)\n+(ms::Elements, factor::Number) -> Elements\n+(factor::Number, ms::Elements) -> Elements\n+(ms::Elements, m::Element) -> Elements\n+(m::Element, ms::Elements) -> Elements\n+(ms1::Elements, ms2::Elements) -> Elements\n\nOverloaded + operator between elements of an algebra over a field.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.:--Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.:-","text":"-(m::Element) -> typeof(m)\n-(m::Element, ::Nothing) -> typeof(m)\n-(::Nothing, m::Element) -> typeof(m)\n-(m::Element, factor::Number) -> Elements\n-(factor::Number, m::Element) -> Elements\n-(m1::Element, m2::Element) -> Elements\n-(ms::Elements) -> typeof(ms)\n-(ms::Elements, ::Nothing) -> typeof(ms)\n-(::Nothing, ms::Elements) -> typeof(ms)\n-(ms::Elements, factor::Number) -> Elements\n-(factor::Number, ms::Elements) -> Elements\n-(m::Element, ms::Elements) -> Elements\n-(ms::Elements, m::Element) -> Elements\n-(ms1::Elements, ms2::Elements) -> Elements\n\nOverloaded - operator between elements of an algebra over a field.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.:/-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Number}","page":"Algebra over fields","title":"Base.:/","text":"/(m::Element, factor::Number) -> Element\n/(m::Element, factor::Scalar) -> Element\n/(ms::Elements, factor::Number) -> Elements\n/(ms::Elements, factor::Scalar) -> Elements\n\nOverloaded / operator for element-scalar division of an algebra over a field.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.://-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Integer}","page":"Algebra over fields","title":"Base.://","text":"//(m::Element, factor::Integer) -> Element\n//(m::Element, factor::Scalar) -> Element\n//(ms::Elements, factor::Integer) ->  Elements\n//(ms::Elements, factor::Scalar) -> Elements\n\nOverloaded // operator for element-scalar division of an algebra over a field.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.:==-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}, Nothing}","page":"Algebra over fields","title":"Base.:==","text":"==(ms::Elements, ::Nothing) -> Bool\n==(::Nothing, ms::Elements) -> Bool\n\nJudge whether a set of elements is identically empty.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.:==-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.:==","text":"==(m1::Element, m2::Element) -> Bool\n\nCompare two elements and judge whether they are equal to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.:^-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Integer}","page":"Algebra over fields","title":"Base.:^","text":"^(m::Element, n::Integer) -> Element\n^(ms::Elements, n::Integer) -> Elements\n\nOverloaded ^ operator for element-integer power of an algebra over a field.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.convert-Union{Tuple{M}, Tuple{Type{M}, QuantumLattices.Mathematics.AlgebraOverFields.Scalar{V} where V}} where M<:(QuantumLattices.Mathematics.AlgebraOverFields.Scalar{V} where V)","page":"Algebra over fields","title":"Base.convert","text":"convert(::Type{M}, m::Scalar) where M<:Scalar\nconvert(::Type{M}, m::Number) where M<:Scalar\nconvert(::Type{M}, m::Element) where M<:Element\n\nConvert a scalar element from one type to another;\nConvert a scalar to a scalar element;\nConvert an element from one type to another.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.getindex-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Any}","page":"Algebra over fields","title":"Base.getindex","text":"getindex(m::Element, i) -> Element\n\nOverloaded [] operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.getproperty-Tuple{Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N, Symbol}","page":"Algebra over fields","title":"Base.getproperty","text":"getproperty(cid::ID{SimpleID}, name::Symbol)\n\nGet the property of a composite id.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.isapprox-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.isapprox","text":"isapprox(m1::Element, m2::Element; atol::Real=atol, rtol::Real=rtol) -> Bool\n\nCompare two elements and judge whether they are inexactly equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.isequal-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}, Nothing}","page":"Algebra over fields","title":"Base.isequal","text":"isequal(ms::Elements, ::Nothing) -> Bool\nisequal(::Nothing, ms::Elements) -> Bool\n\nJudge whether a set of elements is identically empty.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.isequal-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.isequal","text":"isequal(m1::Element, m2::Element) -> Bool\n\nCompare two elements and judge whether they are equal to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.isless-Tuple{Type{var\"#s11\"} where var\"#s11\"<:QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N, Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N}","page":"Algebra over fields","title":"Base.isless","text":"isless(::Type{<:SimpleID}, cid1::ID{SimpleID}, cid2::ID{SimpleID}) -> Bool\n\nCompare two ids and judge whether the first is less than the second.\n\nThe comparison rule are as follows:\n\nids with smaller ranks are always less than those with higher ranks;\nif two ids are of the same rank, the comparison goes just like that between tuples.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.length-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.length","text":"length(m::Element) -> Int\n\nGet the length of an element.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.one-Union{Tuple{Type{M}}, Tuple{M}} where M<:QuantumLattices.Mathematics.AlgebraOverFields.Element","page":"Algebra over fields","title":"Base.one","text":"one(::Type{M}) where M<:Element\none(m::Element)\n\nGet the identity operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.permute!-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}, QuantumLattices.Mathematics.AlgebraOverFields.Element, Any}","page":"Algebra over fields","title":"Base.permute!","text":"permute!(result::Elements, m::Element, table) -> Elements\npermute!(result::Elements, ms::Elements, table) -> Elements\n\nPermute the ids of an-element/a-set-of-elements to the descending order according to a table, and store the permuted elements in result.\n\nnote: Note\nTo use this function, the user must implement a method of permute, which computes the result of the permutation of two ids and takes the following interface:permute(id₁::SimpleID, id₂::SimpleID) -> Union{Element, Elements}Here, id₁ and id₂ are two arbitary simple ids contained in id(m).\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.promote_rule-Union{Tuple{M2}, Tuple{M1}, Tuple{Type{M1}, Type{M2}}} where {M1<:QuantumLattices.Mathematics.AlgebraOverFields.Element, M2<:QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.promote_rule","text":"promote_rule(::Type{M1}, ::Type{M2}) where {M1<:Element, M2<:Element}\n\nDefine the promote rule for Element types.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.promote_type-Tuple{Type{Tuple{}}, Type{var\"#s11\"} where var\"#s11\"<:Tuple{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N} where N}}","page":"Algebra over fields","title":"Base.promote_type","text":"promote_type(::Type{Tuple{}}, I::Type{<:ID{SimpleID, N}}) where N\npromote_type(I::Type{<:ID{SimpleID, N}}, ::Type{Tuple{}}) where N\n\nDefine the promote rule for ID types.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.promote_type-Union{Tuple{V}, Tuple{M}, Tuple{Type{M}, Type{V}, Val{:*}}} where {M<:QuantumLattices.Mathematics.AlgebraOverFields.Element, V<:Number}","page":"Algebra over fields","title":"Base.promote_type","text":"promote_type(::Type{M}, ::Type{V}, ::Val{:*}) where {M<:Element, V<:Number}\npromote_type(::Type{V}, ::Type{M}, ::Val{:*}) where {M<:Element, V<:Number}\n\nDefine the promote rule for the multiplication between an Element and a scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.propertynames-Tuple{Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N}","page":"Algebra over fields","title":"Base.propertynames","text":"propertynames(::Type{I}) where I<:ID{SimpleID} -> Tuple{Vararg{Symbol}}\n\nGet the property names of a composite id.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.replace-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Number}","page":"Algebra over fields","title":"Base.replace","text":"replace(m::Element, v::Number) -> Element\n\nReplace the value of an element.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.replace-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Vararg{Pair{var\"#s8\", var\"#s6\"} where {var\"#s8\"<:QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, var\"#s6\"<:Union{QuantumLattices.Mathematics.AlgebraOverFields.Element, Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}}}, N} where N}","page":"Algebra over fields","title":"Base.replace","text":"replace(m::Element, pairs::Pair{<:SimpleID, <:Union{Element, Elements}}...) -> Element/Elements\nreplace(ms::Elements, pairs::Pair{<:SimpleID, <:Union{Element, Elements}}...) -> Elements\n\nReplace the rank-1 components of an element with new element/elements.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.replace-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.replace","text":"replace(m::Element; kwargs...) -> typeof(m)\n\nReturn a copy of a concrete Element with some of the field values replaced by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.repr-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}}","page":"Algebra over fields","title":"Base.repr","text":"repr(ms::Elements) -> String\n\nGet the repr representation of a set of elements.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.show-Tuple{IO, Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}}","page":"Algebra over fields","title":"Base.show","text":"show(io::IO, ms::Elements)\n\nShow a set of elements.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.show-Tuple{IO, Tuple{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N} where N}}","page":"Algebra over fields","title":"Base.show","text":"show(io::IO, cid::Tuple{SimpleID, Vararg{SimpleID}})\n\nShow a composite id.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.split-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.split","text":"split(m::Element) -> Tuple{Any, Vararg{Element}}\n\nSplit an element into the coefficient and a sequence of rank-1 elements.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.valtype-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"Base.valtype","text":"valtype(m::Element)\nvaltype(::Type{T}) where {T<:Element}\n\nGet the type of the value of an element.\n\nThe result is also the type of the field over which the algebra is defined.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#Base.zero-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}}","page":"Algebra over fields","title":"Base.zero","text":"zero(ms::Elements) -> Nothing\nzero(::Type{<:Elements}) -> Nothing\n\nGet a zero set of elements.\n\nA zero set of elements is defined to be the one with no elements.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.:⊗-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.:⊗","text":"⊗(m::Element, ms::Elements) -> Elements\n⊗(ms::Elements, m::Element) -> Elements\n⊗(ms1::Elements, ms2::Elements) -> Elements\n\nOverloaded ⊗ operator for element-element multiplications of an algebra over a field.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.:⋅-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.:⋅","text":"⋅(m::Element, ms::Elements) -> Elements\n⋅(ms::Elements, m::Element) -> Elements\n⋅(ms1::Elements, ms2::Elements) -> Elements\n\nOverloaded ⋅ operator for element-element multiplications of an algebra over a field.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.add!-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.add!","text":"add!(ms::Elements) -> typeof(ms)\nadd!(ms::Elements, ::Nothing) -> typeof(ms)\nadd!(ms::Elements, m::Number) -> typeof(ms)\nadd!(ms::Elements, m::Element) -> typeof(ms)\nadd!(ms::Elements, mms::Elements) -> typeof(ms)\n\nGet the inplace addition of elements to a set.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.div!-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}, QuantumLattices.Mathematics.AlgebraOverFields.Scalar{V} where V}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.div!","text":"div!(ms::Elements, factor::Scalar) -> Elements\ndiv!(ms::Elements, factor::Number) -> Elements\n\nGet the inplace division of element with a scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.id-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.id","text":"id(m::Element) -> idtype(m)\n\nGet the id of an element.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.mul!-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}, QuantumLattices.Mathematics.AlgebraOverFields.Scalar{V} where V}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.mul!","text":"mul!(ms::Elements, factor::Scalar) -> Elements\nmul!(ms::Elements, factor::Number) -> Elements\n\nGet the inplace multiplication of elements with a scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.permute-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Any}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.permute","text":"permute(m::Element, table) -> Elements\npermute(ms::Elements, table) -> Elements\n\nPermute the ids of an-element/a-set-of-elements to the descending order according to a table.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.permute-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, QuantumLattices.Mathematics.AlgebraOverFields.SimpleID}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.permute","text":"permute(id₁::SimpleID, id₂::SimpleID) -> Tuple{Vararg{Element}}\n\nPermutation rule of two ids.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.rank-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.rank","text":"rank(m::Element) -> Int\nrank(::Type{M}) where M<:Element -> Int\n\nGet the rank of an element.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.rank-Tuple{Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.rank","text":"rank(id::ID{SimpleID}) -> Int\nrank(::Type{<:ID{SimpleID}}) -> Any\nrank(::Type{<:ID{SimpleID, N}}) where N -> Int\n\nGet the rank of a composite id.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.sub!-Tuple{Dict{I, M} where {I<:(Tuple{Vararg{QuantumLattices.Mathematics.AlgebraOverFields.SimpleID, N}} where N), M<:QuantumLattices.Mathematics.AlgebraOverFields.Element}}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.sub!","text":"sub!(ms::Elements) -> typeof(ms)\nsub!(ms::Elements, ::Nothing) -> typeof(ms)\nadd!(ms::Elements, m::Number) -> typeof(ms)\nsub!(ms::Elements, m::Element) -> typeof(ms)\nsub!(ms::Elements, mms::Elements) -> typeof(ms)\n\nGet the inplace subtraction of elements from a set.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Interfaces.value-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"QuantumLattices.Interfaces.value","text":"value(m::Element) -> valtype(m)\n\nGet the value of an element.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.idtype-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element}","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.idtype","text":"idtype(m::Element)\nidtype(::Type{T}) where {T<:Element}\n\nThe type of the id of an element.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/AlgebraOverFields/#QuantumLattices.Mathematics.AlgebraOverFields.sequence-Tuple{QuantumLattices.Mathematics.AlgebraOverFields.Element, Any}","page":"Algebra over fields","title":"QuantumLattices.Mathematics.AlgebraOverFields.sequence","text":"sequence(m::Element, table) -> NTuple{rank(m), Int}\n\nGet the sequence of the ids of an element according to a table.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/","page":"Spin package","title":"Spin package","text":"CurrentModule = QuantumLattices.Essentials.SpinPackage","category":"page"},{"location":"man/Essentials/SpinPackage/#Spin-package","page":"Spin package","title":"Spin package","text":"","category":"section"},{"location":"man/Essentials/SpinPackage/#SID-and-Spin","page":"Spin package","title":"SID and Spin","text":"","category":"section"},{"location":"man/Essentials/SpinPackage/#SpinCoupling","page":"Spin package","title":"SpinCoupling","text":"","category":"section"},{"location":"man/Essentials/SpinPackage/#STerm","page":"Spin package","title":"STerm","text":"","category":"section"},{"location":"man/Essentials/SpinPackage/#Manual","page":"Spin package","title":"Manual","text":"","category":"section"},{"location":"man/Essentials/SpinPackage/","page":"Spin package","title":"Spin package","text":"Modules = [SpinPackage]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.soptdefaultlatex","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.soptdefaultlatex","text":"sdefaultlatex\n\nThe default LaTeX format for a spin oid.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/SpinPackage/#Base.Matrix-Union{Tuple{SID{S}}, Tuple{S}, Tuple{SID{S}, Type{var\"#s153\"} where var\"#s153\"<:Number}} where S","page":"Spin package","title":"Base.Matrix","text":"Matrix(sid::SID{S}, dtype::Type{<:Number}=Complex{Float}) where S -> Matrix{dtype}\n\nGet the matrix representation of a sid.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.SCID","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.SCID","text":"SCID{T<:Tuple{Vararg{Char}}, A<:Tuple} <: SimpleID\n\nThe id of the tags and atoms part of a spin coupling.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.SID","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.SID","text":"SID{S} <: IID\n\nThe spin id.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.SID-Union{Tuple{Char}, Tuple{S}} where S","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.SID","text":"SID{S}(tag::Char; orbital::Int=1) where S\n\nCreate a spin id.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.Spin","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.Spin","text":"Spin{S} <: Internal{SID{S}}\n\nThe spin interanl degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.Spin-Union{Tuple{}, Tuple{S}} where S","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.Spin","text":"Spin{S}(; atom::Int=1, norbital::Int=1) where S\n\nConstruct a spin degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.SpinCoupling","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.SpinCoupling","text":"SpinCoupling{V, T<:Tuple, A<:Tuple, O<:Subscripts, I<:Tuple{SCID, SubID}} <: Coupling{V, I}\n\nSpin coupling.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.SpinCoupling-Union{Tuple{N}, Tuple{Number, Tuple{Vararg{Char, N}}}} where N","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.SpinCoupling","text":"SpinCoupling(value::Number,\n    tags::NTuple{N, Char};\n    atoms::Union{NTuple{N, Int}, Nothing}=nothing,\n    orbitals::Union{NTuple{N, Int}, Subscripts, Nothing}=nothing\n    ) where N\n\nSpin coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.SpinTerm","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.SpinTerm","text":"SpinTerm{R}(id::Symbol, value::Any, bondkind::Any;\n    couplings::Union{Function, Coupling, Couplings},\n    amplitude::Union{Function, Nothing}=nothing,\n    modulate::Union{Function, Bool}=false,\n    ) where R\n\nSpin term.\n\nType alias for Term{:SpinTerm, R, id, V, <:Any, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.@dm_str-Tuple{String}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.@dm_str","text":"dm\"x sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\ndm\"y sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\ndm\"z sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\n\nThe DM couplings.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.@gamma_str-Tuple{String}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.@gamma_str","text":"gamma\"x sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\ngamma\"y sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\ngamma\"z sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\n\nThe Gamma couplings.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.@heisenberg_str-Tuple{String}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.@heisenberg_str","text":"heisenberg\"sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\nheisenberg\"xyz sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\nheisenberg\"+-z sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\n\nThe Heisenberg couplings.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.@ising_str-Tuple{String}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.@ising_str","text":"ising\"x sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\nising\"y sl[a₁ a₂] ⊗ ob[o₁ o₂])\" -> Couplings\nising\"z sl[a₁ a₂] ⊗ ob[o₁ o₂]\" -> Couplings\n\nThe Ising couplings.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.@sc_str-Tuple{String}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.@sc_str","text":"sc\"...\" -> SpinCoupling\n\nConstruct a SpinCoupling from a literal string.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.@sˣ_str-Tuple{String}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.@sˣ_str","text":"sˣ\"sl[a]⊗ob[o]\" -> Couplings\nsʸ\"sl[a]⊗ob[o]\" -> Couplings\nsᶻ\"sl[a]⊗ob[o]\" -> Couplings\n\nThe single Sˣ/Sʸ/Sᶻ coupling.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/SpinPackage/#Base.:*-Tuple{SpinCoupling, SpinCoupling}","page":"Spin package","title":"Base.:*","text":"*(sc₁::SpinCoupling, sc₂::SpinCoupling) -> SpinCoupling\n\nGet the multiplication between two spin couplings.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#Base.repr-Tuple{SpinCoupling}","page":"Spin package","title":"Base.repr","text":"repr(sc::SpinCoupling) -> String\n\nGet the repr representation of a spin coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#Base.show-Tuple{IO, SpinCoupling}","page":"Spin package","title":"Base.show","text":"show(io::IO, sc::SpinCoupling)\n\nShow a spin coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.DegreesOfFreedom.script-Tuple{Val{:site}, Index{var\"#s106\", var\"#s105\"} where {var\"#s106\"<:AbstractPID, var\"#s105\"<:SID}}","page":"Spin package","title":"QuantumLattices.Essentials.DegreesOfFreedom.script","text":"script(::Val{:site}, index::Index{<:AbstractPID, <:SID}; kwargs...) -> Int\nscript(::Val{:orbital}, index::Index{<:AbstractPID, <:SID}; kwargs...) -> Int\nscript(::Val{:tag}, index::Index{<:AbstractPID, <:SID}; kwargs...) -> Char\n\nGet the required script of a spin oid.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.DM-Tuple{Char}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.DM","text":"DM(tag::Char; atoms::Union{NTuple{2, Int}, Nothing}=nothing, orbitals::Union{Int, NTuple{2, Int}, Subscripts}=2) -> Couplings\n\nThe DM couplings.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.Gamma-Tuple{Char}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.Gamma","text":"Gamma(tag::Char; atoms::Union{NTuple{2, Int}, Nothing}=nothing, orbitals::Union{Int, NTuple{2, Int}, Subscripts}=2) -> Couplings\n\nThe Gamma couplings.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.Heisenberg","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.Heisenberg","text":"Heisenberg(mode::String=\"+-z\"; atoms::Union{NTuple{2, Int}, Nothing}=nothing, orbitals::Union{Int, NTuple{2, Int}, Subscripts}=2) -> Couplings\n\nThe Heisenberg couplings.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.Ising-Tuple{Char}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.Ising","text":"Ising(tag::Char; atoms::Union{NTuple{2, Int}, Nothing}=nothing, orbitals::Union{Int, NTuple{2, Int}, Subscripts}=2) -> Couplings\n\nThe Ising couplings.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.Sʸ-Tuple{}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.Sʸ","text":"Sʸ(; atom::Union{Int, Nothing}=nothing, orbital::Union{Int, Nothing}=nothing) -> Couplings\n\nThe single Sʸ coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.Sˣ-Tuple{}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.Sˣ","text":"Sˣ(; atom::Union{Int, Nothing}=nothing, orbital::Union{Int, Nothing}=nothing) -> Couplings\n\nThe single Sˣ coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.Sᶻ-Tuple{}","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.Sᶻ","text":"Sᶻ(; atom::Union{Int, Nothing}=nothing, orbital::Union{Int, Nothing}=nothing) -> Couplings\n\nThe single Sᶻ coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Essentials.SpinPackage.usualspinindextotuple","page":"Spin package","title":"QuantumLattices.Essentials.SpinPackage.usualspinindextotuple","text":"usualspinindextotuple\n\nIndicate that the choosed fields are (:scope, :site, :orbital) when converting a spin index to tuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Interfaces.expand-Tuple{SpinCoupling, AbstractBond, Config, Val}","page":"Spin package","title":"QuantumLattices.Interfaces.expand","text":"expand(sc::SpinCoupling, bond::AbstractBond, config::Config, info::Val) -> Union{SCExpand, Tuple{}}\n\nExpand a spin coupling with the given set of points and spin degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/SpinPackage/#QuantumLattices.Interfaces.permute-Tuple{OID{var\"#s108\", V} where {var\"#s108\"<:(Index{var\"#s107\", var\"#s106\"} where {var\"#s107\"<:AbstractPID, var\"#s106\"<:SID}), V<:(StaticArrays.SVector{S, T} where {S, T})}, OID{var\"#s105\", V} where {var\"#s105\"<:(Index{var\"#s104\", var\"#s103\"} where {var\"#s104\"<:AbstractPID, var\"#s103\"<:SID}), V<:(StaticArrays.SVector{S, T} where {S, T})}}","page":"Spin package","title":"QuantumLattices.Interfaces.permute","text":"permute(id₁::OID{<:Index{<:AbstractPID, <:SID}}, id₂::OID{<:Index{<:AbstractPID, <:SID}}) -> Tuple{Vararg{Operator}}\n\nPermute two spin oid and get the result.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = QuantumLattices.Prerequisites","category":"page"},{"location":"man/Prerequisites/Introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"This module contains the prerequisites of the package.","category":"page"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"The constants, types, macros, functions or submodules defined in this module will not be exported by the package. Instead, they serve as the prerequisites. The range of the contents are quite wide, but basically, they fall into two categories:","category":"page"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"Global constants and miscellaneous tiny useful functions;\nBasic data structures as supplements to the Julia.Base and other common packages.","category":"page"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"The first category is contained in the main body of this module, while the other comes in separate submodules.","category":"page"},{"location":"man/Prerequisites/Introduction/#Constants-and-functions","page":"Introduction","title":"Constants and functions","text":"","category":"section"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"All the following constants and functions in this section are defined in the main body and are exported by this module.","category":"page"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"atol\nrtol\nFloat\ndecimaltostr\nordinal\ndelta","category":"page"},{"location":"man/Prerequisites/Introduction/#QuantumLattices.Prerequisites.atol","page":"Introduction","title":"QuantumLattices.Prerequisites.atol","text":"Absolute tolerance for float numbers.\n\n\n\n\n\n","category":"constant"},{"location":"man/Prerequisites/Introduction/#QuantumLattices.Prerequisites.rtol","page":"Introduction","title":"QuantumLattices.Prerequisites.rtol","text":"Relative tolerance for float numbers.\n\n\n\n\n\n","category":"constant"},{"location":"man/Prerequisites/Introduction/#QuantumLattices.Prerequisites.Float","page":"Introduction","title":"QuantumLattices.Prerequisites.Float","text":"Default float type.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/Introduction/#QuantumLattices.Prerequisites.decimaltostr","page":"Introduction","title":"QuantumLattices.Prerequisites.decimaltostr","text":"decimaltostr(number, ::Int=5)\ndecimaltostr(number::Integer, n::Int=5)\ndecimaltostr(number::Rational, n::Int=5)\ndecimaltostr(number::AbstractFloat, n::Int=5)\ndecimaltostr(number::Complex, n::Int=5)\n\nConvert a number to a string with at most n decimal places.\n\n\n\n\n\n","category":"function"},{"location":"man/Prerequisites/Introduction/#QuantumLattices.Prerequisites.ordinal","page":"Introduction","title":"QuantumLattices.Prerequisites.ordinal","text":"ordinal(number::Interger)\n\nConvert a positive number to its corresponding ordinal.\n\n\n\n\n\n","category":"function"},{"location":"man/Prerequisites/Introduction/#QuantumLattices.Prerequisites.delta","page":"Introduction","title":"QuantumLattices.Prerequisites.delta","text":"delta(i, j) -> Int\n\nKronecker delta function.\n\n\n\n\n\n","category":"function"},{"location":"man/Prerequisites/Introduction/#Basic-structures","page":"Introduction","title":"Basic structures","text":"","category":"section"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"Here lists the table of contents of the basic data structures that are supplements to the Julia.Base and other common packages:","category":"page"},{"location":"man/Prerequisites/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"Traits.md\",\n        \"CompositeStructures.md\",\n        \"SimpleTrees.md\",\n        \"NamedVectors.md\",\n        ]\nDepth = 2","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"CurrentModule = QuantumLattices.Prerequisites.SimpleTrees","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"push!(LOAD_PATH, \"../../../../src/\")\nusing QuantumLattices.Prerequisites.SimpleTrees","category":"page"},{"location":"man/Prerequisites/SimpleTrees/#Simple-trees","page":"Simple trees","title":"Simple trees","text":"","category":"section"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"The aim of this module is to represent the standard tree structure in efficiency-non-sensitive cases. Please note that the default implementation of tree methods are far from optimal in efficiency. Therefore, please DO NOT use it if you need an efficient tree for addition, deletion, sort and inquiry. This module of codes apply only when the structure of tree matters but not the efficiency.","category":"page"},{"location":"man/Prerequisites/SimpleTrees/#AbstractSimpleTree","page":"Simple trees","title":"AbstractSimpleTree","text":"","category":"section"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"AbstractSimpleTree{N, D} is the abstract type for all concrete trees. By design, it has two type parameters:","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"N: the type of the tree's node\nD: the type of the tree's data","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"To fully utilize the methods designed for a tree structure, in our protocol, a concrete subtype must implement the following methods:","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"inquiry related methods\nroot(tree::AbstractSimpleTree{N}) where N -> Union{N, Nothing}\nGet a tree's root node (nothing for empty trees)\nhaskey(tree::AbstractSimpleTree{N}, node::N) where N -> Bool\nCheck whether a node is in a tree.\nlength(tree::AbstractSimpleTree) -> Int\nGet the number of a tree's nodes.\nparent(tree::AbstractSimpleTree{N},\n       node::N,\n       superparent::Union{N, Nothing}=nothing\n       ) where N -> Union{N, Nothing}\nGet the parent of a tree's node or return superparent when the input node is the tree's root.\nchildren(tree::AbstractSimpleTree{N}, node::N) where N -> Vector{N}\nGet the children of a tree's node.\nstructure modification related methods\naddnode!(tree::AbstractSimpleTree{N},\n         parent::Union{N, Nothing},\n         node::N\n         ) where N -> typeof(tree)\nUpdate the structure of a tree by adding a node. When the parent is nothing, the input tree must be empty and the input node becomes the tree's root.\ndeletenode!(tree::AbstractSimpleTree{N}, node::N) where N -> typeof(tree)\nUpdate the structure of a tree by deleting a node.\nindex related methods\ngetindex(tree::AbstractSimpleTree{N, D}, node::N) where {N, D} -> D\nGet the data of a tree's node\nsetindex!(tree::AbstractSimpleTree{N, D}, node::N, data::D) where {N, D}\nSet the data of a tree's node.","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"Based on these methods, we implement several generic functions for inquiries and manipulations","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"inquiry for type parameters: keytype, valtype, eltype\nexpansion over nodes/data-records: keys, values, pairs\ninquiry for info of nodes: isleaf, level\ninquiry for nodes: ancestor, descendants, siblings, leaves\nmodification: push!, append!, delete!, empty!","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"And optionally, when a subtype implement the following method,","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"empty(tree::AbstractSimpleTree) -> typeof(tree)","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"which constructs an empty tree of the same type with the input one, two more methods are supported:","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"subtree: Get a subtree starting from a node.\nmove!: Move a subtree to a new position.","category":"page"},{"location":"man/Prerequisites/SimpleTrees/#SimpleTreeCore-and-SimpleTree","page":"Simple trees","title":"SimpleTreeCore and SimpleTree","text":"","category":"section"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"To implement all the prerequisites listed above costs a bit efforts. We provide two lazy ways to get over this:","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"Inheritance AbstractSimpleTree with TREECORE::SimpleTreeCore as one of its attribute\nInclusion an attribute which is an instance of SimpleTree","category":"page"},{"location":"man/Prerequisites/SimpleTrees/#SimpleTreeCore","page":"Simple trees","title":"SimpleTreeCore","text":"","category":"section"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"SimpleTreeCore{N, D}, as the literal meaning indicates, is the core of a tree. It encapsulates all the data structures needed by the default implementation, which contains 4 attributes:","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"root::N: the tree's root node\ncontents::Dict{N, D}: the tree's (node, data) pairs\nparent::Dict{N, N}: records of the parent of each of the tree's nodes\nchildren::Dict{N, Vector{N}}: records of the children of each of the tree's nodes","category":"page"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"As above, the first lazy way is to include this struct with the special name :TREECORE in your concrete subtype one of its attribute.","category":"page"},{"location":"man/Prerequisites/SimpleTrees/#SimpleTree","page":"Simple trees","title":"SimpleTree","text":"","category":"section"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"SimpleTree{N, D} is the minimum struct that implements all the default tree methods. You can include an instance of it as an attribute in your own type to utilize all the tree methods.","category":"page"},{"location":"man/Prerequisites/SimpleTrees/#Manual","page":"Simple trees","title":"Manual","text":"","category":"section"},{"location":"man/Prerequisites/SimpleTrees/","page":"Simple trees","title":"Simple trees","text":"Modules = [SimpleTrees]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.simpletreedepth","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.simpletreedepth","text":"simpletreedepth\n\nIndicate that the iteration over a tree is depth-first.\n\n\n\n\n\n","category":"constant"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.simpletreewidth","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.simpletreewidth","text":"simpletreewidth\n\nIndicate that the iteration over a tree is width-first.\n\n\n\n\n\n","category":"constant"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree","text":"AbstractSimpleTree{Node, Data}\n\nAbstract type for all concrete trees.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.SimpleTree","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.SimpleTree","text":"SimpleTree{N, D}() where {N, D}\n\nThe minimum tree structure that implements all the default tree methods.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeCore","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeCore","text":"SimpleTreeCore()\n\nThe core of a simple tree.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeCore-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeCore","text":"SimpleTreeCore(tree::AbstractSimpleTree) -> SimpleTreeCore\n\nGet the core of a simple tree.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.:==-Union{Tuple{TC}, Tuple{TC, TC}} where TC<:QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeCore","page":"Simple trees","title":"Base.:==","text":"==(tc1::TC, tc2::TC) where TC<:SimpleTreeCore -> Bool\nisequal(tc1::TC, tc2::TC) where TC<:SimpleTreeCore -> Bool\n\nOverloaded equivalent operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree","page":"Simple trees","title":"Base.:==","text":"==(t1::T, t2::T) where {T<:AbstractSimpleTree} -> Bool\n\nOverloaded equivalent operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.append!-Union{Tuple{D}, Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D}, QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D}}} where {N, D}","page":"Simple trees","title":"Base.append!","text":"append!(tree::AbstractSimpleTree{N, D}, subtree::AbstractSimpleTree{N, D}) where {N, D} -> typeof(tree)\nappend!(tree::AbstractSimpleTree{N, D}, node::Union{N, Nothing}, subtree::AbstractSimpleTree{N, D}) where {N, D} -> typeof(tree)\n\nAppend a subtree to a tree.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.delete!-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"Base.delete!","text":"delete!(tree::AbstractSimpleTree{N}, node::N) where N -> typeof(tree)\n\nDelete a node and all its descendants from a tree.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.eltype-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"Base.eltype","text":"eltype(tree::AbstractSimpleTree)\neltype(::Type{T}) where {T<:AbstractSimpleTree}\n\nGet the eltype of a tree.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.empty!-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"Base.empty!","text":"empty!(tree::AbstractSimpleTree) -> typeof(tree)\n\nEmpty a tree.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.empty-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"Base.empty","text":"empty(tree::AbstractSimpleTree)\n\nConstruct an empty tree of the same type with the input one.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.getindex-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"Base.getindex","text":"getindex(tree::AbstractSimpleTree{N}, node::N) where N -> N\n\nGet the data of a tree's node.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.haskey-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"Base.haskey","text":"haskey(tree::AbstractSimpleTree{N}, node::N) where N -> Bool\n\nCheck whether a node is in a tree.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.isequal-Union{Tuple{T}, Tuple{T, T}} where T<:QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree","page":"Simple trees","title":"Base.isequal","text":"isequal(t1::T, t2::T) where {T<:AbstractSimpleTree} -> Bool\n\nOverloaded equivalent operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.keys-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeIteration}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeIteration, Union{Nothing, N}}} where N","page":"Simple trees","title":"Base.keys","text":"keys(tree::AbstractSimpleTree{N}, ::SimpleTreeDepth, node::Union{N, Nothing}=root(tree)) where N\nkeys(tree::AbstractSimpleTree{N}, ::SimpleTreeWidth, node::Union{N, Nothing}=root(tree)) where N\n\nIterate over a tree's nodes starting from a certain node by depth first search or width first search.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.keytype-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"Base.keytype","text":"keytype(tree::AbstractSimpleTree)\nkeytype(::Type{T}) where {T<:AbstractSimpleTree}\n\nGet a tree's node type.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.length-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"Base.length","text":"length(tree::AbstractSimpleTree) -> Int\n\nGet the number of a tree's nodes.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.pairs-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeIteration}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeIteration, Union{Nothing, N}}} where N","page":"Simple trees","title":"Base.pairs","text":"pairs(tree::AbstractSimpleTree{N}, ::SimpleTreeDepth, node::Union{N, Nothing}=root(tree)) where N\npairs(tree::AbstractSimpleTree{N}, ::SimpleTreeWidth, node::Union{N, Nothing}=root(tree)) where N\n\nIterate over a tree's (node, data) pairs starting from a certain node by depth first search or width first search.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.push!-Union{Tuple{D}, Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D}, N, D}} where {N, D}","page":"Simple trees","title":"Base.push!","text":"push!(tree::AbstractSimpleTree{N, D}, node::N, data::D) where {N, D} -> typeof(tree)\npush!(tree::AbstractSimpleTree{N, D}, parent::Union{N, Nothing}, node::N, data::D) where {N, D} -> typeof(tree)\n\nPush a new node to a tree. When parent is nothing, this function set the root node of an empty tree.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.setindex!-Union{Tuple{D}, Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D}, D, N}} where {N, D}","page":"Simple trees","title":"Base.setindex!","text":"setindex!(tree::AbstractSimpleTree{N, D}, data::D, node::N) where {N, D}\n\nSet the data of a tree's node.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.valtype-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"Base.valtype","text":"valtype(tree::AbstractSimpleTree)\nvaltype(::Type{T}) where {T<:AbstractSimpleTree}\n\nGet a tree's data type.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#Base.values-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeIteration}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, QuantumLattices.Prerequisites.SimpleTrees.SimpleTreeIteration, Union{Nothing, N}}} where N","page":"Simple trees","title":"Base.values","text":"values(tree::AbstractSimpleTree{N}, ::SimpleTreeDepth, node::Union{N, Nothing}=root(tree)) where N\nvalues(tree::AbstractSimpleTree{N}, ::SimpleTreeWidth, node::Union{N, Nothing}=root(tree)) where N\n\nIterate over a tree's data starting from a certain node by depth first search or width first search.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.addnode!-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.addnode!","text":"addnode!(tree::AbstractSimpleTree{N}, node::N) where N} -> typeof(tree)\naddnode!(tree::AbstractSimpleTree{N}, ::Nothing, node::N) where N -> typeof(tree)\naddnode!(tree::AbstractSimpleTree{N}, parent::N, node::N) where N -> typeof(tree)\n\nUpdate the structure of a tree by adding a node. When the parent is nothing, the input tree must be empty and the input node becomes the tree's root.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.ancestor-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N, Int64}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.ancestor","text":"ancestor(tree::AbstractSimpleTree{N}, node::N, generation::Int=1) where N -> N\n\nGet the ancestor of a tree's node of the n-th generation.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.children-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.children","text":"children(tree::AbstractSimpleTree) -> Vector{keytype(tree)}\nchildren(tree::AbstractSimpleTree, ::Nothing) -> Vector{keytype(tree)}\nchildren(tree::AbstractSimpleTree{N}, node::N) where N -> Vector{N}\n\nGet the children of a tree's node.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.deletenode!-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.deletenode!","text":"deletenode!(tree::AbstractSimpleTree{N}, node::N) where N -> typeof(tree)\n\nUpdate the structure of a tree by deleting a node.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.descendants-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N, Int64}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.descendants","text":"descendants(tree::AbstractSimpleTree{N}, node::N, generation::Int=1) where N -> Vector{N}\n\nGet the descendants of a tree's node of the nth generation.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.isleaf-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.isleaf","text":"isleaf(tree::AbstractSimpleTree{N}, node::N) where N -> Bool\n\nJudge whether a tree's node is a leaf (a node without children) or not.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.leaves-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.leaves","text":"leaves(tree::AbstractSimpleTree) -> Vector{keytype(tree)}\n\nGet a tree's leaves.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.level-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.level","text":"level(tree::AbstractSimpleTree{N}, node::N) where N -> Int\n\nGet the level of tree's node.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.move!-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N, N}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.move!","text":"move!(tree::AbstractSimpleTree{N}, node::N, parent::N) where N -> typeof(tree)\n\nMove a subtree to a new position.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.parent-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N, Union{Nothing, N}}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.parent","text":"parent(tree::AbstractSimpleTree{N}, node::N, superparent::Union{N, Nothing}=nothing) where N -> Union{N, Nothing}\n\nGet the parent of a tree's node. When node is the tree's root, return superparent.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.root-Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree}","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.root","text":"root(tree::AbstractSimpleTree) -> Union{keytype(tree), Nothing}\n\nGet a tree's root node.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.siblings-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.siblings","text":"siblings(tree::AbstractSimpleTree{N}, node::N) where N -> Vector{N}\n\nGet the siblings (other nodes sharing the same parent) of a tree's node.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/SimpleTrees/#QuantumLattices.Prerequisites.SimpleTrees.subtree-Union{Tuple{N}, Tuple{QuantumLattices.Prerequisites.SimpleTrees.AbstractSimpleTree{N, D} where D, N}} where N","page":"Simple trees","title":"QuantumLattices.Prerequisites.SimpleTrees.subtree","text":"subtree(tree::AbstractSimpleTree{N}, node::N) where N -> typeof(tree)\n\nGet a subtree whose root is node.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"CurrentModule = QuantumLattices\nDocTestSetup = quote\n    push!(LOAD_PATH, \"../../../src/\")\n    using QuantumLattices\nend","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/#Spatial-info-of-a-unitcell","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"The first step toward the complete description of a quantum lattice system is the understanding of the spatial info of a unitcell.","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/#Point","page":"Spatial info of a unitcell","title":"Point","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"The basic data structure encoding the spatial info of a unitcell is Point.","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"Theoretically, the only information that is needed to determine a point in a lattice is its coordinates in the real space. Now that coordinates sometimes are complicated real numbers and are not convenient for lookup, it is desirable to attach to each point with a sensible id. Then you may agree that the most appropriate data structure representing a point should contain two parts, the id part and the coordinate part. But the story does not end up here. This is because we want to compress the whole spatial info of a lattice into its unitcells. For each lattice, there exists a freedom to choose its unitcells. Sometimes we even need enlarged unitcells. Therefore, something must be adopted to keep the info of which unitcell a point belongs to in the lattice. This information is useful even when we only keep the data of points within a single unitcell because at this time we usually have to obtain those bonds across the unitcell boundaries that must contain a point in other unitcells. Now we arrive at the final structure, just as the Point defined in this package, which has three attributes:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"pid::PID: the id of a point\nrcoord::StaticArrays.SVector: the coordinates of the point in the real space\nicoord::StaticArrays.SVector: the coordinates of the unitcell the point belongs to in the real space","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"Here PID contains only one attribute:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"site::Int: the site index of a point","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"Let's see some examples.","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"The :site attribute should be specified during the initialization of a PID:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> PID(1)\nPID(1)","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"At the construction of a Point, :rcoord and :icoord can accept tuples or usual vectors as inputs, such as","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> Point(PID(1), (0.0,), (0.0,))\nPoint(PID(1), [0.0], [0.0])\n\njulia> Point(PID(1), [0.0], [0.0])\nPoint(PID(1), [0.0], [0.0])","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"If the :icoord is omitted, it will be initialized by a zero StaticArrays.SVector:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> Point(PID(1), [0.0])\nPoint(PID(1), [0.0], [0.0])","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/#Lattice","page":"Spatial info of a unitcell","title":"Lattice","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"Lattice is the simplest structure to encode all the spatial info within a unitcell. Apparently, it must contain all the points of a unitcell. Besides, a unitcell can assume either open or periodic boundary for every spatial dimension, thus a Lattice should also contain the translation vectors. Other stuff also appears to be useful, such as the name, the reciprocals dual to the translation vectors, and the bond length of each order of nearest neighbors. Therefore, in this package, Lattice gets seven attributes:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"name::String: the name of the lattice\npids::Vector{PID}: the pids of the lattice\nrcoords::Matrix{Float64}: the rcoords of the lattice\nicoords::Matrix{Float64}: the icoords of the lattice\nvectors::Vector{<:StaticArrays.SVector}: the translation vectors of the lattice\nreciprocals::Vector{<:StaticArrays.SVector}: the reciprocals of the lattice\nneighbors::Dict{Int, Float64}: the order-distance map of the nearest neighbors of the lattice","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"Here, the :pids, :rcoords and :icoords attributes decompose the points in a lattice, which makes it convenient for global operations on the lattice.","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"Points can be used directly to construct a lattice, whereas :vectors and :neighbors can be assigned by keyword arguments:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> Lattice(\"L2P\", [Point(PID(1), [0.0]), Point(PID(2), [1.0])],\n           vectors=[[2.0]],\n           neighbors=Dict(1=>1.0, 2=>2.0)\n           )\nLattice(L2P)\n  with 2 points:\n    Point(PID(1), [0.0], [0.0])\n    Point(PID(2), [1.0], [0.0])\n  with 1 translation vector:\n    [2.0]\n  with 2 orders of nearest neighbors:\n    2 => 2.0\n    1 => 1.0","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"The :neighbors keyword argument can also be a natural number, which sets the highest order of nearest neighbors, and the order-distance map of nearest neighbors can be computed automatically by the construction function:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> Lattice(\"L2P\", [Point(PID(1), [0.0]), Point(PID(2), [1.0])],\n           vectors=[[2.0]],\n           neighbors=2\n           )\nLattice(L2P)\n  with 2 points:\n    Point(PID(1), [0.0], [0.0])\n    Point(PID(2), [1.0], [0.0])\n  with 1 translation vector:\n    [2.0]\n  with 2 orders of nearest neighbors:\n    2 => 2.0\n    1 => 1.0","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"It is noted that the :vectors and :neighbors attributes can also be omitted at the initialization, then :vectors will be set to be empty and :neighbors to be 1 upon the call of the construction function:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> Lattice(\"L2P\", [Point(PID(1), [0.0]), Point(PID(2), [1.0])])\nLattice(L2P)\n  with 2 points:\n    Point(PID(1), [0.0], [0.0])\n    Point(PID(2), [1.0], [0.0])\n  with 1 order of nearest neighbors:\n    1 => 1.0","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"In all cases, the :reciprocals attributes need not be assigned because it can be deduced from the input :vectors.","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/#Bonds","page":"Spatial info of a unitcell","title":"Bonds","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"One of the most important functions of a lattice is to inquiry the bonds it contains.","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"A usual bond contains two points, the start point and the end point. This structure is implemented as Bond, which has three attributes:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"neighbor::Int: the nearest neighbor order of the bond\nspoint::Point: the start point of the bond\nepoint::Point: the end point of the bond","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"The :neighbor attribute provides the a priori info of the nearest neighbor order of a bond, which proves to be quite advantageous in future uses.","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"There are other types of generalized bonds. In fact, a single point can also be viewed as a kind of bond, namely, the zeroth order nearest neighbor bond. We can also have more complex generalized bonds, such as a plaquette (the minimum four-site square) in the square lattice. All these generalized bonds gather under the abstract type, AbstractBond, and the generation from a lattice of such generalized bonds can be managed by the type Bonds. In this package, we only implement two types of concrete generalized bonds, i.e. Point and Bond. Users interested in other types can define them themselves by extending our protocols. In this way, the management of the generation of these user extended bonds can be utilized by Bonds without extra modifications. See Bonds for more details.","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"Now let's see a simple example:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> lattice = Lattice(\"L2P\", [Point(PID(1), [0.0]), Point(PID(2), [1.0])],\n           vectors=[[2.0]],\n           neighbors=2\n           )\nLattice(L2P)\n  with 2 points:\n    Point(PID(1), [0.0], [0.0])\n    Point(PID(2), [1.0], [0.0])\n  with 1 translation vector:\n    [2.0]\n  with 2 orders of nearest neighbors:\n    2 => 2.0\n    1 => 1.0\n\njulia> Bonds(lattice)\n6-element Bonds:\n Point(PID(1), [0.0], [0.0])\n Point(PID(2), [1.0], [0.0])\n Bond(1, Point(PID(1), [0.0], [0.0]), Point(PID(2), [1.0], [0.0]))\n Bond(2, Point(PID(1), [0.0], [0.0]), Point(PID(1), [-2.0], [-2.0]))\n Bond(1, Point(PID(1), [0.0], [0.0]), Point(PID(2), [-1.0], [-2.0]))\n Bond(2, Point(PID(2), [1.0], [0.0]), Point(PID(2), [-1.0], [-2.0]))","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"By default, Bonds(lattice::Lattice) generates all the generalized bonds with orders of nearest neighbors specified by the attribute :neighbors of the input lattice, including the individual points and the bonds across the periodic boundaries. Note that the bonds whose lengths are not present in the :neighbors attribute of the input lattice won't be included in the result, even when their lengths are shorter:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> lattice = Lattice(\"L2P\", [Point(PID(1), [0.0]), Point(PID(2), [1.0])],\n           vectors=[[2.0]],\n           neighbors=Dict(2=>2.0)\n           )\nLattice(L2P)\n  with 2 points:\n    Point(PID(1), [0.0], [0.0])\n    Point(PID(2), [1.0], [0.0])\n  with 1 translation vector:\n    [2.0]\n  with 1 order of nearest neighbors:\n    2 => 2.0\n\njulia> Bonds(lattice)\n4-element Bonds:\n Point(PID(1), [0.0], [0.0])\n Point(PID(2), [1.0], [0.0])\n Bond(2, Point(PID(1), [0.0], [0.0]), Point(PID(1), [-2.0], [-2.0]))\n Bond(2, Point(PID(2), [1.0], [0.0]), Point(PID(2), [-1.0], [-2.0]))","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"In other words, the :neighbors attribute can be viewed as a filter of the generated bonds (but this filter only affects the Bond typed but not the Point typed generalized bonds). When the input lattice has no translation vectors, the generated bonds will only contain the individual points and the intra-unitcell bonds, just as expected:","category":"page"},{"location":"tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/","page":"Spatial info of a unitcell","title":"Spatial info of a unitcell","text":"julia> lattice = Lattice(\"L2P\", [Point(PID(1), [0.0]), Point(PID(2), [1.0])])\nLattice(L2P)\n  with 2 points:\n    Point(PID(1), [0.0], [0.0])\n    Point(PID(2), [1.0], [0.0])\n  with 1 order of nearest neighbors:\n    1 => 1.0\n\njulia> Bonds(lattice)\n3-element Bonds:\n Point(PID(1), [0.0], [0.0])\n Point(PID(2), [1.0], [0.0])\n Bond(1, Point(PID(1), [0.0], [0.0]), Point(PID(2), [1.0], [0.0]))","category":"page"},{"location":"man/Essentials/FockPackage/","page":"Fock package","title":"Fock package","text":"CurrentModule = QuantumLattices.Essentials.FockPackage","category":"page"},{"location":"man/Essentials/FockPackage/#Fock-package","page":"Fock package","title":"Fock package","text":"","category":"section"},{"location":"man/Essentials/FockPackage/#FID-and-Fock","page":"Fock package","title":"FID and Fock","text":"","category":"section"},{"location":"man/Essentials/FockPackage/#FockCoupling","page":"Fock package","title":"FockCoupling","text":"","category":"section"},{"location":"man/Essentials/FockPackage/#Fock-terms","page":"Fock package","title":"Fock terms","text":"","category":"section"},{"location":"man/Essentials/FockPackage/#Manual","page":"Fock package","title":"Manual","text":"","category":"section"},{"location":"man/Essentials/FockPackage/","page":"Fock package","title":"Fock package","text":"Modules = [FockPackage]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.ANNIHILATION","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.ANNIHILATION","text":"ANNIHILATION\n\nIndicate that the nambu index is ANNIHILATION.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.CREATION","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.CREATION","text":"CREATION\n\nIndicate that the nambu index is CREATION.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.MAJORANA","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.MAJORANA","text":"MAJORANA\n\nIndicate that the nambu index is MAJORANA.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.bdefaultlatex","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.bdefaultlatex","text":"bdefaultlatex\n\nThe default LaTeX format for a bosonic oid.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.fdefaultlatex","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.fdefaultlatex","text":"fdefaultlatex\n\nThe default LaTeX format for a fermionic oid.\n\n\n\n\n\n","category":"constant"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.Coulomb","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.Coulomb","text":"Coulomb(id::Symbol, value::Any, bondkind::Int=1;\n    couplings::Union{Function, Coupling, Couplings, Nothing}=nothing,\n    amplitude::Union{Function, Nothing}=nothing,\n    modulate::Union{Function, Bool}=false\n    )\n\nCoulomb term.\n\nType alias for Term{:Coulomb, 4, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.FCID","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.FCID","text":"FCID{A<:Tuple, N<:Tuple} <: SimpleID\n\nThe id of the atoms and nambus part of a Fock coupling.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.FID","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.FID","text":"FID <: IID\n\nThe Fock id.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.FID-Union{Tuple{}, Tuple{ST}} where ST","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.FID","text":"FID{ST}(; orbital::Int=1, spin::Int=1, nambu::Int=ANNIHILATION) where ST\n\nCreate a Fock id.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.Fock","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.Fock","text":"Fock{ST} <: Internal{FID{ST}}\n\nThe Fock interanl degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.Fock-Union{Tuple{}, Tuple{ST}} where ST","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.Fock","text":"Fock{ST}(; atom::Int=1, norbital::Int=1, nspin::Int=2, nnambu::Int=2) where ST\n\nConstruct a Fock degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.FockCoupling","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.FockCoupling","text":"FockCoupling{V, A<:Tuple, N<:Tuple, O<:Subscripts, S<:Subscripts, I<:Tuple{FCID, SubID, SubID}} <: Coupling{V, I}\n\nFock coupling.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.FockCoupling-Union{Tuple{}, Tuple{Number}, Tuple{N}} where N","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.FockCoupling","text":"FockCoupling{N}(value::Number=1;\n    atoms::Union{NTuple{N, Int}, Nothing}=nothing,\n    nambus::Union{NTuple{N, Int}, Nothing}=nothing,\n    orbitals::Union{NTuple{N, Int}, Subscripts, Nothing}=nothing,\n    spins::Union{NTuple{N, Int}, Subscripts, Nothing}=nothing\n    ) where N\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.Hopping","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.Hopping","text":"Hopping(id::Symbol, value::Any, bondkind::Int=1;\n    couplings::Union{Function, Coupling, Couplings, Nothing}=nothing,\n    amplitude::Union{Function, Nothing}=nothing,\n    modulate::Union{Function, Bool}=false,\n    )\n\nHopping term.\n\nType alias for Term{:Hopping, 2, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.Hubbard","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.Hubbard","text":"Hubbard(id::Symbol, value::Any; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=false)\n\nHubbard term.\n\nType alias for Term{:Hubbard, 4, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.InterOrbitalInterSpin","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.InterOrbitalInterSpin","text":"InterOrbitalInterSpin(id::Symbol, value::Any; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=false)\n\nInterorbital-interspin term.\n\nType alias for Term{:InterOrbitalInterSpin, 4, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.InterOrbitalIntraSpin","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.InterOrbitalIntraSpin","text":"InterOrbitalIntraSpin(id::Symbol, value::Any; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=false)\n\nInterorbital-intraspin term.\n\nType alias for Term{:InterOrbitalIntraSpin, 4, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.Onsite","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.Onsite","text":"Onsite(id::Symbol, value::Any;\n    couplings::Union{Function, Coupling, Couplings, Nothing}=nothing,\n    amplitude::Union{Function, Nothing}=nothing,\n    modulate::Union{Function, Bool}=false,\n    )\n\nOnsite term.\n\nType alias for Term{:Onsite, 2, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.PairHopping","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.PairHopping","text":"PairHopping(id::Symbol, value::Any; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=false)\n\nPair-hopping term.\n\nType alias for Term{:PairHopping, 4, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.Pairing","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.Pairing","text":"Pairing(id::Symbol, value::Any, bondkind::Int=0;\n    couplings::Union{Function, Coupling, Couplings, Nothing}=nothing,\n    amplitude::Union{Function, Nothing}=nothing,\n    modulate::Union{Function, Bool}=false,\n    )\n\nPairing term.\n\nType alias for Term{:Pairing, 2, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.SpinFlip","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.SpinFlip","text":"SpinFlip(id::Symbol, value::Any; amplitude::Union{Function, Nothing}=nothing, modulate::Union{Function, Bool}=false)\n\nSpin-flip term.\n\nType alias for Term{:SpinFlip, 4, id, V, Int, <:TermCouplings, <:TermAmplitude, <:TermModulate}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.@fc_str-Tuple{Any}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.@fc_str","text":"fc\"...\" -> FockCoupling\n\nConstruct a FockCoupling from a literal string.\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.@σʸ_str-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.@σʸ_str","text":"σʸ\"sp\" -> Couplings\nσʸ\"ob\" -> Couplings\nσʸ\"sl\" -> Couplings\nσʸ\"ph\" -> Couplings\n\nThe Pauli matrix σʸ, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.@σˣ_str-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.@σˣ_str","text":"σˣ\"sp\" -> Couplings\nσˣ\"ob\" -> Couplings\nσˣ\"sl\" -> Couplings\nσˣ\"ph\" -> Couplings\n\nThe Pauli matrix σˣ, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.@σᶻ_str-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.@σᶻ_str","text":"σᶻ\"sp\" -> Couplings\nσᶻ\"ob\" -> Couplings\nσᶻ\"sl\" -> Couplings\nσᶻ\"ph\" -> Couplings\n\nThe Pauli matrix σᶻ, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.@σ⁰_str-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.@σ⁰_str","text":"σ⁰\"sp\" -> Couplings\nσ⁰\"ob\" -> Couplings\nσ⁰\"sl\" -> Couplings\nσ⁰\"ph\" -> Couplings\n\nThe Pauli matrix σ⁰, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.@σ⁺_str-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.@σ⁺_str","text":"σ⁺\"sp\" -> Couplings\nσ⁺\"ob\" -> Couplings\nσ⁺\"sl\" -> Couplings\nσ⁺\"ph\" -> Couplings\n\nThe Pauli matrix σ⁺, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.@σ⁻_str-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.@σ⁻_str","text":"σ⁻\"sp\" -> Couplings\nσ⁻\"ob\" -> Couplings\nσ⁻\"sl\" -> Couplings\nσ⁻\"ph\" -> Couplings\n\nThe Pauli matrix σ⁻, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"macro"},{"location":"man/Essentials/FockPackage/#Base.:*-Tuple{FockCoupling, FockCoupling}","page":"Fock package","title":"Base.:*","text":"*(fc₁::FockCoupling, fc₂::FockCoupling) -> FockCoupling\n\nGet the multiplication between two Fock couplings.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#Base.:*-Tuple{Operator{var\"#s106\", var\"#s105\"} where {var\"#s106\"<:Number, var\"#s105\"<:(Tuple{Vararg{AbstractCompositeOID{var\"#s104\"} where var\"#s104\"<:(Index{var\"#s103\", FID{:f}} where var\"#s103\"<:AbstractPID), N}} where N)}, Operator{var\"#s102\", var\"#s101\"} where {var\"#s102\"<:Number, var\"#s101\"<:(Tuple{Vararg{AbstractCompositeOID{var\"#s100\"} where var\"#s100\"<:(Index{var\"#s99\", FID{:f}} where var\"#s99\"<:AbstractPID), N}} where N)}}","page":"Fock package","title":"Base.:*","text":"*(f1::Operator{<:Number, <:ID{AbstractCompositeOID{<:Index{<:AbstractPID, FID{:f}}}}}, f2::Operator{<:Number, <:ID{AbstractCompositeOID{<:Index{<:AbstractPID, FID{:f}}}}}) -> Union{Nothing, Operator}\n\nGet the multiplication of two fermionic Fock operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#Base.angle-Tuple{OID{var\"#s108\", V} where {var\"#s108\"<:(Index{var\"#s107\", var\"#s106\"} where {var\"#s107\"<:AbstractPID, var\"#s106\"<:FID}), V<:(StaticArrays.SVector{S, T} where {S, T})}, AbstractVector{var\"#s105\"} where var\"#s105\"<:(AbstractVector{var\"#s104\"} where var\"#s104\"<:Number), AbstractVector{var\"#s103\"} where var\"#s103\"<:Number}","page":"Fock package","title":"Base.angle","text":"angle(id::OID{<:Index{<:AbstractPID, <:FID}}, vectors::AbstractVector{<:AbstractVector{<:Number}}, values::AbstractVector{<:Number}) -> Complex{<:Number}\n\nGet the twist phase corresponding to a Fock oid.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#Base.repr-Tuple{FockCoupling}","page":"Fock package","title":"Base.repr","text":"repr(fc::FockCoupling) -> String\n\nGet the repr representation of a Fock coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#Base.show-Tuple{IO, FockCoupling}","page":"Fock package","title":"Base.show","text":"show(io::IO, fc::FockCoupling)\n\nShow a Fock coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.DegreesOfFreedom.script-Tuple{Val{:site}, Index{var\"#s106\", var\"#s105\"} where {var\"#s106\"<:AbstractPID, var\"#s105\"<:FID}}","page":"Fock package","title":"QuantumLattices.Essentials.DegreesOfFreedom.script","text":"script(::Val{:site}, index::Index{<:AbstractPID, <:FID}; kwargs...) -> Int\nscript(::Val{:orbital}, index::Index{<:AbstractPID, <:FID}; kwargs...) -> Int\nscript(::Val{:spinint}, index::Index{<:AbstractPID, <:FID}; kwargs...) -> Int\nscript(::Val{:spinsym}, index::Index{<:AbstractPID, <:FID}; kwargs...) -> String\nscript(::Val{:nambu}, index::Index{<:AbstractPID, <:FID}; kwargs...) -> String\n\nGet the required script of a Fock index.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.isnormalordered-Tuple{Operator{var\"#s108\", var\"#s107\"} where {var\"#s108\"<:Number, var\"#s107\"<:(Tuple{Vararg{AbstractCompositeOID{var\"#s106\"} where var\"#s106\"<:(Index{var\"#s105\", var\"#s104\"} where {var\"#s105\"<:AbstractPID, var\"#s104\"<:FID}), N}} where N)}}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.isnormalordered","text":"isnormalordered(opt::Operator{<:Number, <:ID{AbstractCompositeOID{<:Index{<:AbstractPID, <:FID}}}}) -> Bool\n\nJudge whether an operator is normal ordered.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.nambufockindextotuple","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.nambufockindextotuple","text":"nambufockindextotuple\n\nIndicate that the choosed fields are (:scope, :nambu, :site, :orbital, :spin) when converting a Fock index to tuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.usualfockindextotuple","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.usualfockindextotuple","text":"usualfockindextotuple\n\nIndicate that the choosed fields are (:scope, :site, :orbital, :spin) when converting a Fock index to tuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.σʸ-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.σʸ","text":"σʸ(mode::String) -> Couplings\n\nThe Pauli matrix σʸ, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.σˣ-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.σˣ","text":"σˣ(mode::String) -> Couplings\n\nThe Pauli matrix σˣ, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.σᶻ-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.σᶻ","text":"σᶻ(mode::String) -> Couplings\n\nThe Pauli matrix σᶻ, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.σ⁰-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.σ⁰","text":"σ⁰(mode::String) -> Couplings\n\nThe Pauli matrix σ⁰, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.σ⁺-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.σ⁺","text":"σ⁺(mode::String) -> Couplings\n\nThe Pauli matrix σ⁺, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Essentials.FockPackage.σ⁻-Tuple{String}","page":"Fock package","title":"QuantumLattices.Essentials.FockPackage.σ⁻","text":"σ⁻(mode::String) -> Couplings\n\nThe Pauli matrix σ⁻, which can act on the space of spins(\"sp\"), orbitals(\"ob\"), sublattices(\"sl\") or particle-holes(\"ph\").\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Interfaces.:⊗-Tuple{FockCoupling, FockCoupling}","page":"Fock package","title":"QuantumLattices.Interfaces.:⊗","text":"⊗(fc₁::FockCoupling, fc₂::FockCoupling) -> FockCoupling\n\nGet the direct product between two Fock couplings.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Interfaces.:⋅-Tuple{FockCoupling, FockCoupling}","page":"Fock package","title":"QuantumLattices.Interfaces.:⋅","text":"⋅(fc₁::FockCoupling, fc₂::FockCoupling) -> FockCoupling\n\nGet the dot product of two rank-2 Fock couplings.\n\nA rank-2 FockCoupling can be considered as a matrix acting on the sublattice, orbital, spin and nambu spaces. Therefore, the dot product here is defined as the multiplication between such matrices.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Interfaces.expand-Tuple{FockCoupling, AbstractBond, Config, Val}","page":"Fock package","title":"QuantumLattices.Interfaces.expand","text":"expand(fc::FockCoupling, bond::AbstractBond, config::Config, info::Val) -> Union{FCExpand, Tuple{}}\n\nExpand a Fock coupling with the given bond and the config of the Fock degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Interfaces.permute-Tuple{OID{var\"#s152\", V} where {var\"#s152\"<:(Index{var\"#s109\", FID{:b}} where var\"#s109\"<:AbstractPID), V<:(StaticArrays.SVector{S, T} where {S, T})}, OID{var\"#s108\", V} where {var\"#s108\"<:(Index{var\"#s107\", FID{:b}} where var\"#s107\"<:AbstractPID), V<:(StaticArrays.SVector{S, T} where {S, T})}}","page":"Fock package","title":"QuantumLattices.Interfaces.permute","text":"permute(id₁::OID{<:Index{<:AbstractPID, FID{:b}}}, id₂::OID{<:Index{<:AbstractPID, FID{:b}}}) -> Tuple{Vararg{Operator}}\n\nPermute two bosonic oid and get the result.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/FockPackage/#QuantumLattices.Interfaces.permute-Tuple{OID{var\"#s152\", V} where {var\"#s152\"<:(Index{var\"#s109\", FID{:f}} where var\"#s109\"<:AbstractPID), V<:(StaticArrays.SVector{S, T} where {S, T})}, OID{var\"#s108\", V} where {var\"#s108\"<:(Index{var\"#s107\", FID{:f}} where var\"#s107\"<:AbstractPID), V<:(StaticArrays.SVector{S, T} where {S, T})}}","page":"Fock package","title":"QuantumLattices.Interfaces.permute","text":"permute(id₁::OID{<:Index{<:AbstractPID, FID{:f}}}, id₂::OID{<:Index{<:AbstractPID, FID{:f}}}) -> Tuple{Vararg{Operator}}\n\nPermute two fermionic oid and get the result.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/","page":"Degrees of freedom","title":"Degrees of freedom","text":"CurrentModule = QuantumLattices.Essentials.DegreesOfFreedom","category":"page"},{"location":"man/Essentials/DegreesOfFreedom/#Degrees-of-freedom","page":"Degrees of freedom","title":"Degrees of freedom","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#IID,-Internal-and-Index","page":"Degrees of freedom","title":"IID, Internal and Index","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#Config","page":"Degrees of freedom","title":"Config","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#OID","page":"Degrees of freedom","title":"OID","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#Operator","page":"Degrees of freedom","title":"Operator","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#Operators","page":"Degrees of freedom","title":"Operators","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#Metric-and-Table","page":"Degrees of freedom","title":"Metric and Table","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#LaTeX","page":"Degrees of freedom","title":"LaTeX","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#Boundary","page":"Degrees of freedom","title":"Boundary","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/#Manual","page":"Degrees of freedom","title":"Manual","text":"","category":"section"},{"location":"man/Essentials/DegreesOfFreedom/","page":"Degrees of freedom","title":"Degrees of freedom","text":"Modules = [DegreesOfFreedom]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.AbstractCompositeOID","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.AbstractCompositeOID","text":"AbstractCompositeOID{I<:Index} <: AbstractOID\n\nThe abstract type of composite operator id.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.AbstractOID","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.AbstractOID","text":"AbstractOID <: SimpleID\n\nAbstract type of operator id.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.AbstractOperator","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.AbstractOperator","text":"AbstractOperator{V<:Number, I<:ID{AbstractOID}} <: Element{V, I}\n\nAbstract type for an operator.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Boundary","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Boundary","text":"Boundary{Names}(values::AbstractVector{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}) where Names\n\nBoundary twist of operators.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Boundary-Tuple{Operator}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Boundary","text":"(bound::Boundary)(operator::Operator) -> Operator\n\nGet the boundary twisted operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Config","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Config","text":"Config{I}(map::Function, pids::AbstractVector{<:AbstractPID}) where {I<:Internal}\n\nConfiguration of the internal degrees of freedom at a lattice.\n\nHere, map maps a AbstractPID to an Internal.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.IID","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.IID","text":"IID <: SimpleID\n\nThe id of an internal degree of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Index","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Index","text":"Index{P<:AbstractPID, I<:IID} <: AbstractOID\n\nThe index of a degree of freedom, which consist of the spatial part and the internal part.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Internal","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Internal","text":"Internal{I<:IID} <: CartesianVectorSpace{I}\n\nThe whole internal degrees of freedom at a single point.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.LaTeX","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.LaTeX","text":"LaTeX{SP, SB}(body) where {SP, SB}\n\nLaTeX string representation.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Metric","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Metric","text":"Metric <: Function\n\nThe rules for measuring a concrete oid so that oids can be compared.\n\nAs a function, every instance should accept only one positional argument, i.e. the concrete oid to be measured.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.OID","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.OID","text":"OID(index::Index, rcoord, icoord)\nOID(index::Index; rcoord, icoord)\n\nOperator id.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.OIDToTuple","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.OIDToTuple","text":"OIDToTuple{Fields} <: Metric\n\nA rule that converts an oid to a tuple by iterating over a set of selected fields in a specific order.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.OIDToTuple-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.OIDToTuple","text":"(oidtotuple::OIDToTuple)(index::Index) -> Tuple\n(oidtotuple::OIDToTuple)(oid::AbstractCompositeOID) -> Tuple\n\nConvert a concrete oid to a tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.OIDToTuple-Union{Tuple{Type{C}}, Tuple{C}} where C<:Config","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.OIDToTuple","text":"OIDToTuple(::Type{C}) where {C<:Config}\n\nConstruct the convertion rule from the information of Config.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.OIDToTuple-Union{Tuple{Type{I}}, Tuple{I}} where I<:Index","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.OIDToTuple","text":"OIDToTuple(::Type{I}) where {I<:Index}\nOIDToTuple(::Type{I}) where {I<:AbstractCompositeOID}\n\nConstruct the convertion rule from the information of subtypes of AbstractOID.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Operator","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Operator","text":"Operator{V<:Number, I<:ID{AbstractOID}} <: AbstractOperator{V, I}\n\nOperator.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Operators","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Operators","text":"Operators(opts::Operator...)\n\nA set of operators.\n\nType alias for Elements{<:ID{AbstractOID}, <:Operator}.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Table","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Table","text":"Table{I, B<:Metric} <: CompositeDict{I, Int}\n\nThe table of oid-sequence pairs.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Table-2","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Table","text":"Table(config::Config, by::Metric=OIDToTuple(typeof(config))) -> Table\n\nGet the oid-sequence table of the whole internal degrees of freedom of a lattice by use of their configurations.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.Table-3","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.Table","text":"Table(oids::AbstractVector{<:AbstractOID}, by::Metric=OIDToTuple(eltype(oids)))\n\nConvert a set of concrete oids to the corresponding table of oid-sequence pairs.\n\nThe input oids are measured by the input by function with the duplicates removed. The resulting unique values are sorted, which determines the sequence of the input oids. Note that two oids have the same sequence if their converted values are equal to each other.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/DegreesOfFreedom/#Base.:==-Tuple{Boundary, Boundary}","page":"Degrees of freedom","title":"Base.:==","text":"==(bound1::Boundary, bound2::Boundary) -> Bool\n\nJudge whether two boundaries conditions are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.adjoint-Tuple{Dict{I, O} where {I<:(Tuple{Vararg{AbstractOID, N}} where N), O<:Operator}}","page":"Degrees of freedom","title":"Base.adjoint","text":"adjoint(opts::Operators) -> Operators\n\nGet the adjoint of a set of operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.adjoint-Tuple{Index}","page":"Degrees of freedom","title":"Base.adjoint","text":"adjoint(index::Index) -> typeof(index)\n\nGet the adjoint of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.adjoint-Tuple{OID}","page":"Degrees of freedom","title":"Base.adjoint","text":"adjoint(oid::OID) -> typeof(oid)\nadjoint(oid::ID{OID, N}) where N -> typeof(oid)\n\nGet the adjoint of an operator id.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.adjoint-Tuple{Operator}","page":"Degrees of freedom","title":"Base.adjoint","text":"adjoint(opt::Operator) -> Operator\n\nGet the adjoint of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.angle-Tuple{Boundary, Operator}","page":"Degrees of freedom","title":"Base.angle","text":"angle(bound::Boundary, operator::Operator) -> Number\n\nGet the boundary twist phase of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.angle-Tuple{Tuple{Vararg{AbstractOID, N}} where N, AbstractVector{var\"#s109\"} where var\"#s109\"<:(AbstractVector{var\"#s108\"} where var\"#s108\"<:Number), AbstractVector{var\"#s107\"} where var\"#s107\"<:Number}","page":"Degrees of freedom","title":"Base.angle","text":"angle(id::ID{AbstractOID}, vectors::AbstractVector{<:AbstractVector{<:Number}}, values::AbstractVector{<:Number}) -> Number\n\nGet the total twist phase of an id.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.filter-Tuple{Function, OIDToTuple}","page":"Degrees of freedom","title":"Base.filter","text":"filter(f::Function, oidtotuple::OIDToTuple) -> OIDToTuple\n\nFilter the selected fields.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.getindex-Tuple{Table, AbstractOID}","page":"Degrees of freedom","title":"Base.getindex","text":"getindex(table::Table, oid::AbstractOID) -> Int\n\nInquiry the sequence of an oid.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.haskey-Tuple{Table, AbstractOID}","page":"Degrees of freedom","title":"Base.haskey","text":"haskey(table::Table, oid::AbstractOID) -> Bool\nhaskey(table::Table, id::ID{AbstractOID}) -> Tuple{Vararg{Bool}}\n\nJudge whether a single oid or a set of oids have been assigned with sequences in table.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.isequal-Tuple{Boundary, Boundary}","page":"Degrees of freedom","title":"Base.isequal","text":"isequal(bound1::Boundary, bound2::Boundary) -> Bool\n\nJudge whether two boundaries conditions are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.keys-Tuple{Boundary}","page":"Degrees of freedom","title":"Base.keys","text":"keys(bound::Boundary) -> Tuple{Vararg{Symbol}}\nkeys(::Type{<:Boundary{Names}}) where Names -> Names\n\nGet the names of the boundary parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.keys-Union{Tuple{OIDToTuple{Fields}}, Tuple{Fields}} where Fields","page":"Degrees of freedom","title":"Base.keys","text":"keys(::OIDToTuple{Fields}) where Fields -> Fields\nkeys(::Type{<:OIDToTuple{Fields}}) where Fields -> Fields\n\nGet the names of the selected fields.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.repr-Tuple{AbstractOID}","page":"Degrees of freedom","title":"Base.repr","text":"repr(oid::AbstractOID) -> String\nrepr(oid::AbstractOID, l::LaTeX) -> String\n\nLaTeX string representation of an oid.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.repr-Tuple{Dict{I, O} where {I<:(Tuple{Vararg{AbstractOID, N}} where N), O<:Operator}}","page":"Degrees of freedom","title":"Base.repr","text":"repr(opts::Operators) -> String\n\nGet the string representation of a set of operators in the LaTeX format.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.repr-Tuple{Operator}","page":"Degrees of freedom","title":"Base.repr","text":"repr(opt::Operator) -> String\n\nGet the string representation of an operator in the LaTeX format.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.show-Tuple{IO, Internal}","page":"Degrees of freedom","title":"Base.show","text":"show(io::IO, i::Internal)\n\nShow an internal.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.show-Tuple{IO, MIME{Symbol(\"text/latex\")}, Dict{I, O} where {I<:(Tuple{Vararg{AbstractOID, N}} where N), O<:Operator}}","page":"Degrees of freedom","title":"Base.show","text":"show(io::IO, ::MIME\"text/latex\", opts::Operators)\n\nShow LaTeX formed operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.show-Tuple{IO, MIME{Symbol(\"text/latex\")}, Operator}","page":"Degrees of freedom","title":"Base.show","text":"show(io::IO, ::MIME\"text/latex\", opt::Operator)\n\nShow an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.show-Tuple{IO, OID}","page":"Degrees of freedom","title":"Base.show","text":"show(io::IO, oid::OID)\n\nShow an operator id.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.show-Tuple{IO, Operator}","page":"Degrees of freedom","title":"Base.show","text":"show(io::IO, opt::Operator)\n\nShow an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.summary-Tuple{IO, Dict{I, O} where {I<:(Tuple{Vararg{AbstractOID, N}} where N), O<:Operator}}","page":"Degrees of freedom","title":"Base.summary","text":"summary(io::IO, opts::Operators)\n\nPrint a brief description of a set of operators to an io.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.union-Tuple{Vararg{Table, N} where N}","page":"Degrees of freedom","title":"Base.union","text":"union(tables::Table...) -> Table\n\nUnite several oid-sequence tables.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#Base.valtype-Union{Tuple{I}, Tuple{M}, Tuple{Type{M}, Type{I}}} where {M<:OIDToTuple, I<:Index}","page":"Degrees of freedom","title":"Base.valtype","text":"valtype(::Type{<:OIDToTuple}, ::Type{<:Index})\nvaltype(::Type{<:OIDToTuple}, ::Type{<:AbstractCompositeOID})\n\nGet the valtype of applying an OIDToTuple rule to a subtype of AbstractOID.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.iidtype-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.iidtype","text":"iidtype(index::Index)\niidtype(::Type{<:Index{<:AbstractPID, I}}) where {I<:IID}\n\nGet the type of the internal part of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.indextype-Tuple{AbstractCompositeOID}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.indextype","text":"indextype(::AbstractCompositeOID)\nindextype(::Type{<:AbstractCompositeOID})\n\nGet the index type of an composite operator id.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.isHermitian-Tuple{Dict{I, O} where {I<:(Tuple{Vararg{AbstractOID, N}} where N), O<:Operator}}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.isHermitian","text":"isHermitian(opts::Operators) -> Bool\n\nJudge whether a set of operators as a whole is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.isHermitian-Tuple{Operator}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.isHermitian","text":"isHermitian(opt::Operator) -> Bool\n\nJudge whether an operator is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.isHermitian-Union{Tuple{Tuple{Vararg{AbstractOID, N}}}, Tuple{N}} where N","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.isHermitian","text":"isHermitian(id::ID{AbstractOID, N}) where N -> Bool\n\nJudge whether an operator id is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.latexformat-Tuple{Type{var\"#s160\"} where var\"#s160\"<:AbstractOID}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.latexformat","text":"latexformat(T::Type{<:AbstractOID}) -> LaTeX\nlatexformat(T::Type{<:AbstractOID}, l::LaTeX) -> LaTeX\n\nGet/Set the LaTeX format for a subtype of Operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.latexname-Tuple{Type{var\"#s160\"} where var\"#s160\"<:AbstractOID}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.latexname","text":"latexname(T::Type{<:AbstractOID}) -> Symbol\n\nGet the name of a type of AbstractOID in the latex format lookups.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.oidtype-Tuple{Type{var\"#s155\"} where var\"#s155\"<:Internal, Type{var\"#s153\"} where var\"#s153\"<:Point, Val}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.oidtype","text":"oidtype(I::Type{<:Internal}, P::Type{<:Point}, ::Val)\n\nGet the compatible oid type from the combination of the internal part and the spatial part.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.plain","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.plain","text":"plain\n\nPlain boundary condition without any twist.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.script-Tuple{Val{:BD}, AbstractOID, LaTeX}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.script","text":"script(::Val{:BD}, oid::AbstractOID, l::LaTeX) -> Any\nscript(::Val{:SP}, oid::AbstractOID, l::LaTeX) -> Tuple\nscript(::Val{:SB}, oid::AbstractOID, l::LaTeX) -> Tuple\n\nGet the body/superscript/subscript of the LaTeX string representation of an oid.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.script-Tuple{Val{:integeralicoord}, OID}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.script","text":"script(::Val{:integeralicoord}, oid::OID; vectors, kwargs...)\n\nGet the integeral script of the icoord of an oid.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.script-Tuple{Val{:rcoord}, OID}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.script","text":"script(::Val{:rcoord}, oid::OID; kwargs...) -> String\nscript(::Val{:icoord}, oid::OID; kwargs...) -> String\n\nGet the :rcoord/:icoord script of an oid.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.script-Union{Tuple{attr}, Tuple{Val{attr}, OID}} where attr","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.script","text":"script(::Val{attr}, oid::OID; kwargs...) where attr\n\nGet the attr script of an oid, which is contained in its index.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.DegreesOfFreedom.twist-Tuple{Operator, AbstractVector{var\"#s153\"} where var\"#s153\"<:(AbstractVector{var\"#s152\"} where var\"#s152\"<:Number), AbstractVector{var\"#s109\"} where var\"#s109\"<:Number}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.DegreesOfFreedom.twist","text":"twist(operator::Operator, vectors::AbstractVector{<:AbstractVector{<:Number}}, values::AbstractVector{<:Number}) -> Operator\n\nTwist an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.Spatials.icoord-Tuple{Operator{var\"#s155\", var\"#s153\"} where {var\"#s155\"<:Number, var\"#s153\"<:(Tuple{Vararg{OID, N}} where N)}}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.Spatials.icoord","text":"icoord(opt::Operator) -> SVector\n\nGet the whole icoord of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.Spatials.pidtype-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.Spatials.pidtype","text":"pidtype(index::Index)\npidtype(::Type{<:Index{P}}) where {P<:AbstractPID}\n\nGet the type of the spatial part of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.Spatials.rcoord-Tuple{Operator{var\"#s155\", var\"#s153\"} where {var\"#s155\"<:Number, var\"#s153\"<:(Tuple{Vararg{OID, N}} where N)}}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.Spatials.rcoord","text":"rcoord(opt::Operator) -> SVector\n\nGet the whole rcoord of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.reset!-Tuple{Config, Any}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.reset!","text":"reset!(config::Config, pids) -> Config\n\nReset the config with new pids.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.reset!-Tuple{Table, AbstractVector{var\"#s153\"} where var\"#s153\"<:AbstractOID}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.reset!","text":"reset!(table::Table, oids::AbstractVector{<:AbstractOID}) -> Table\n\nReset a table by a new set of oids.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.reset!-Tuple{Table, Config}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.reset!","text":"reset!(table::Table, config::Config) -> Table\n\nReset a table by a complete configuration of internal degrees of freedom on a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Essentials.update!-Tuple{Boundary, Vararg{Any, N} where N}","page":"Degrees of freedom","title":"QuantumLattices.Essentials.update!","text":"update!(bound::Boundary, args...; kwargs...) -> Boundary\n\nUpdate the values of the boundary twisted phase.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/DegreesOfFreedom/#QuantumLattices.Mathematics.AlgebraOverFields.sequence-Tuple{Operator, AbstractDict{var\"#s153\", Int64} where var\"#s153\"}","page":"Degrees of freedom","title":"QuantumLattices.Mathematics.AlgebraOverFields.sequence","text":"sequence(opt::Operator, table::AbstractDict) -> NTuple{rank(opt), Int}\n\nGet the sequence of the oids of an operator according to a table.\n\n\n\n\n\n","category":"method"},{"location":"developer/CodeStyle/#Code-style-guide","page":"Code style guide","title":"Code style guide","text":"","category":"section"},{"location":"developer/CodeStyle/","page":"Code style guide","title":"Code style guide","text":"Basically, the code style is compatible with Julia.Base, which follows much of the rules that is also popular in other languages.","category":"page"},{"location":"developer/CodeStyle/#Whitespaces","page":"Code style guide","title":"Whitespaces","text":"","category":"section"},{"location":"developer/CodeStyle/","page":"Code style guide","title":"Code style guide","text":"Always surround these binary operators with a single space on either side: assignment (=), augmented assignment (+=, -= etc.), comparisons (==, <, >, !=, <>, <=, >=, in, not in, is, is not), Booleans (and, or, not)\nNo white spaces immediately inside parentheses, brackets or braces.\nYes: sum(1)\nNo:  sum( 1), sum(1 ), sum( 1 )","category":"page"},{"location":"developer/CodeStyle/#Naming-Conventions","page":"Code style guide","title":"Naming Conventions","text":"","category":"section"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"CurrentModule = QuantumLattices.Prerequisites.NamedVectors","category":"page"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"push!(LOAD_PATH, \"../../../../src/\")\nusing QuantumLattices.Prerequisites.NamedVectors","category":"page"},{"location":"man/Prerequisites/NamedVectors/#Named-vectors","page":"Named vectors","title":"Named vectors","text":"","category":"section"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"A named vector is similar to a named tuple, which associate each of its values with a name. Although the names of a named vector cannot be changed, the values can be modified if needed. In contrast to the predefined NamedTuple in Julia, which employs the names as type parameters, we just implement a named vector as a composite struct equipped with the getindex and setindex! functions, with the fieldnames being its names. This simple implementation makes it possible to define your own concrete named vector with any of your preferred type names, and ensures that all instances of a certain concrete named vector share the same names. Therefore, if you are familiar with Python, you will find that our named vector is more qualified to be the counterpart of the namedtuple in Python than the default Julia implementation. Last but not least important, it is also worth noted that a named vector is not a vector, as is similar to that a named tuple is not a tuple in Julia. This results from our basic expectation that a named vector should be more like a tuple other than a vector so that not all operations valid to vectors are also valid to named vectors.","category":"page"},{"location":"man/Prerequisites/NamedVectors/#NamedVector","page":"Named vectors","title":"NamedVector","text":"","category":"section"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"NamedVector defines the abstract type for all concrete named vectors.","category":"page"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"Main features include:","category":"page"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"Values can be accessed or modified either by the . operator or by the [] operator.\nComparisons, such as ≡, ≢, ==, ≠, >, <, ≥, ≤ are supported. Therefore a vector of named vectors can be sorted by the default sort function.\nHash is supported by hash. Therefore, a named vector can be used as the key of a dict or set.\nIteration over its fieldnames is supported by keys, over its values is supported by values, over its field-value pairs is supported by pairs.\nA reverse iteration is also supported.","category":"page"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"To subtype it, please note:","category":"page"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"A concrete type can be either mutable or immutable as you need, which is different from tuples.\nThe fields of a concrete type can be of the same type or not. For the former, we denote the named vector as \"homogeneous\" while for the latter as \"inhomogeneous\". For homogeneous ones, we define a sub abstract type, HomoNamedVector for further optimization of the default methods. See HomoNamedVector below.\nFor all concrete subtypes, if inner constructors are defined, the one which has the same interface with the default one must be implemented. Otherwise, some functionalities will not work.\nArithmetic operations, such as +, -, *, /, %, ÷, etc. are not supported. However, the function map is implemented, which can help users do the overloadings of these operations.","category":"page"},{"location":"man/Prerequisites/NamedVectors/#HomoNamedVector","page":"Named vectors","title":"HomoNamedVector","text":"","category":"section"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"HomoNamedVector is the subtype of NamedVector that of all its fields share the same type. Compared to NamedVector, one more default method is implemented with HomoNamedVector, i.e. eltype, which returns the type of its fields. This function ensures the type stability of all the methods that involves an iteration of the field values of a named vector. Therefore, homogeneous named vector are usually more efficient than inhomogeneous ones. Use homogeneous ones as much as possible unless the code efficiency does not matter.","category":"page"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"To subtype HomoNamedVector, all the suggestions mentioned in the previous subsection for NamedVector also applies. A recommended template for a subtype is","category":"page"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"[mutable] struct YourNamedVector{T} <: HomoNamedVector{T}\n    filed1::T\n    filed2::T\n    ...\nend","category":"page"},{"location":"man/Prerequisites/NamedVectors/#Manual","page":"Named vectors","title":"Manual","text":"","category":"section"},{"location":"man/Prerequisites/NamedVectors/","page":"Named vectors","title":"Named vectors","text":"Modules = [NamedVectors]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Prerequisites/NamedVectors/#QuantumLattices.Prerequisites.NamedVectors.HomoNamedVector","page":"Named vectors","title":"QuantumLattices.Prerequisites.NamedVectors.HomoNamedVector","text":"HomoNamedVector{T}\n\nAbstract type for all homogeneous named vectors.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/NamedVectors/#QuantumLattices.Prerequisites.NamedVectors.NamedVector","page":"Named vectors","title":"QuantumLattices.Prerequisites.NamedVectors.NamedVector","text":"NamedVector\n\nAbstract type for all named vectors.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/NamedVectors/#Base.:<-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector, QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.:<","text":"<(nv1::NamedVector, nv2::NamedVector) -> Bool\n\nCompare two named vectors and judge whether the first is less than the second.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.:==-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector, QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.:==","text":"==(nv1::NamedVector, nv2::NamedVector) -> Bool\n\nOverloaded equivalent operator. Two named vector are equal to each other if and only if their keys as well as their values are equal to each other.\n\nnote: Note\nIt is not necessary for two named vectors to be of the same concrete type to be equal to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.convert-Tuple{Type{Tuple}, QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.convert","text":"convert(::Type{Tuple}, nv::NamedVector) -> Tuple\nconvert(::Type{NV}, nv::Tuple) where {NV<:NamedVector} -> NV\n\nConvert a named vector to tuple and vice versa.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.eltype-Union{Tuple{Type{var\"#s11\"} where var\"#s11\"<:QuantumLattices.Prerequisites.NamedVectors.HomoNamedVector{T}}, Tuple{T}} where T","page":"Named vectors","title":"Base.eltype","text":"eltype(::Type{<:HomoNamedVector{T}}) where T\neltype(nv::HomoNamedVector)\n\nGet the type parameter of a concrete HomoNamedVector.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.getindex-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector, Int64}","page":"Named vectors","title":"Base.getindex","text":"getindex(nv::NamedVector, index::Int)\n\nGet the value by the [] syntax.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.hash-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector, UInt64}","page":"Named vectors","title":"Base.hash","text":"hash(nv::NamedVector, h::UInt)\n\nHash a concrete NamedVector.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.isequal-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector, QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.isequal","text":"isequal(nv1::NamedVector, nv2::NamedVector) -> Bool\n\nOverloaded equivalent operator. Two named vector are equal to each other if and only if their keys as well as their values are equal to each other.\n\nnote: Note\nIt is not necessary for two named vectors to be of the same concrete type to be equal to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.isless-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector, QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.isless","text":"isless(nv1::NamedVector, nv2::NamedVector) -> Bool\n\nCompare two named vectors and judge whether the first is less than the second.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.iterate","page":"Named vectors","title":"Base.iterate","text":"iterate(nv::NamedVector, state=1)\niterate(rv::Iterators.Reverse{<:NamedVector}, state=length(rv.itr))\n\nIterate or reversely iterate over the values of a concrete NamedVector.\n\n\n\n\n\n","category":"function"},{"location":"man/Prerequisites/NamedVectors/#Base.keys-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.keys","text":"keys(nv::NamedVector) -> NTuple{length(nv), Symbol}\n\nIterate over the names.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.length-Union{Tuple{Type{NV}}, Tuple{NV}} where NV<:QuantumLattices.Prerequisites.NamedVectors.NamedVector","page":"Named vectors","title":"Base.length","text":"length(::Type{NV}) where NV<:NamedVector -> Int\nlength(nv::NamedVector) -> Int\n\nGet the length of a concrete NamedVector.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.map-Union{Tuple{NV}, Tuple{Any, Vararg{NV, N} where N}} where NV<:QuantumLattices.Prerequisites.NamedVectors.NamedVector","page":"Named vectors","title":"Base.map","text":"map(f, nvs::NV...) where NV<:NamedVector -> NV\n\nApply function f elementwise on the input named vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.pairs-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.pairs","text":"pairs(nv::NamedVector) -> Base.Generator\n\nIterate over the name-value pairs.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.replace-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.replace","text":"replace(nv::NamedVector; kwargs...) -> typeof(nv)\n\nReturn a copy of a concrete NamedVector with some of the field values replaced by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.setindex!-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector, Any, Int64}","page":"Named vectors","title":"Base.setindex!","text":"setindex!(nv::NamedVector, value, index::Int)\n\nSet the value by the [] syntax if mutable.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.show-Tuple{IO, QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.show","text":"show(io::IO, nv::NamedVector)\n\nShow a concrete NamedVector.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.values-Tuple{QuantumLattices.Prerequisites.NamedVectors.NamedVector}","page":"Named vectors","title":"Base.values","text":"values(nv::NamedVector) -> NTuple{length(nv)}\n\nIterate over the values.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/NamedVectors/#Base.zero-Union{Tuple{Type{NV}}, Tuple{NV}} where NV<:QuantumLattices.Prerequisites.NamedVectors.NamedVector","page":"Named vectors","title":"Base.zero","text":"zero(::Type{NV}) where NV<:NamedVector -> NV\nzero(nv::NamedVector) -> typeof(nv)\n\nGet a concrete NamedVector with all values being zero.\n\n\n\n\n\n","category":"method"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"CurrentModule = QuantumLattices.Prerequisites.CompositeStructures","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"push!(LOAD_PATH, \"../../../../src/\")\nusing QuantumLattices.Prerequisites.CompositeStructures","category":"page"},{"location":"man/Prerequisites/CompositeStructures/#Composite-structures","page":"Composite structures","title":"Composite structures","text":"","category":"section"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"In principle, Julia is not an object-oriented programming language. For example, only abstract types can be inherited so that subtype cannot inherit fields from their parents. Therefore, Julia prefers composition over inheritance. However, to make a new concrete type behaves much alike another one, tedious repetitions of redefining the generic interfaces are usually not avoidable, especially for the basic types in Julia base. In this module, we implement three such composited types, CompositeTuple, CompositeVector and CompositeDict, for the sake of future usages. Besides, NamedContainer, as a wrapper of Julia NamedTuple, is also provided here so that the construction of a Julia NamedTuple can be more flexible over the standard (name=value, ... ) syntax.","category":"page"},{"location":"man/Prerequisites/CompositeStructures/#CompositeTuple-and-CompositeNTuple","page":"Composite structures","title":"CompositeTuple and CompositeNTuple","text":"","category":"section"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"A composite tuple (ntuple) can be considered as a tuple (ntuple) that is implemented by including an ordinary Tuple(NTuple) as its data attribute.","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"To take full advantages of the Julia base, the following interfaces are defined:","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"inquiry of info: length, eltype, hash\ncomparison between objects: ==, isequal\nobtainment of old elements: getindex\niteration: iterate, keys, values, pairs\nconstruction of new objects: reverse","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"Note that arithmetic operations and logical operations excluding == and isequal are not supported. Besides, a composite tuple is not a tuple since Julia has no abstract tuples.","category":"page"},{"location":"man/Prerequisites/CompositeStructures/#CompositeVector","page":"Composite structures","title":"CompositeVector","text":"","category":"section"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"A composite vector can be considered as a vector that is implemented by including a concrete subtype of AbstractVector as its data attribute, and it itself is a subtype of AbstractVector.","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"To take full advantages of the Julia base, the following interfaces are redefined:","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"inquiry of info: size, length\ncomparison between objects: ==, isequal\nobtainment of old elements: getindex\noperation of old elements: setindex!\naddition of new elements: push!, pushfirst!, insert!, append!, prepend!\nremoval of old elements: splice!, deleteat!, pop!, popfirst!, empty!\nconstruction of new objects: empty, reverse, similar\niteration: iterate, keys, values, pairs","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"Note that arithmetic operations and logical operations excluding == and isequal are not supported.","category":"page"},{"location":"man/Prerequisites/CompositeStructures/#CompositeDict","page":"Composite structures","title":"CompositeDict","text":"","category":"section"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"A composite dict can be considered as a dict that is implemented by including a concrete subtype of AbstractDict as its data attribute and it itself is a subtype of AbstractDict.","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"To take full advantages of the Julia base, the following interfaces are redefined:","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"inquiry of info: isempty, length, haskey, in\ncomparison between objects: ==, isequal\nobtainment of old elements: get, getkey, getindex\noperation and addition of elements: push!, get!, setindex!\nremoval of old elements: pop!, delete!, empty!\nconstruction of new objects: merge, empty\niteration: iterate, keys, values, pairs","category":"page"},{"location":"man/Prerequisites/CompositeStructures/#NamedContainer","page":"Composite structures","title":"NamedContainer","text":"","category":"section"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"NamedContainer is just a wrapper (type alias) of Julia NamedTuple, but not a composite type.","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"Julia NamedTuple is useful to keep type stability of codes when we deal with inhomogeneous immutable dict-like objects, but its default constructor is not so convenient because the names and contents must be assigned pair by pair in a pair of parentheses explicitly. Therefore, we define a type alias of NamedTuple under the name of NamedContainer, so that we can construct a NamedTuple by the usual-formed constructor NamedContainer, e.g.","category":"page"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"NamedContainer{(:a, :b)}((1, 2))","category":"page"},{"location":"man/Prerequisites/CompositeStructures/#Manual","page":"Composite structures","title":"Manual","text":"","category":"section"},{"location":"man/Prerequisites/CompositeStructures/","page":"Composite structures","title":"Composite structures","text":"Modules = [CompositeStructures]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Prerequisites/CompositeStructures/#QuantumLattices.Prerequisites.CompositeStructures.CompositeDict","page":"Composite structures","title":"QuantumLattices.Prerequisites.CompositeStructures.CompositeDict","text":"CompositeDict{K, V}\n\nA composite dict can be considered as a dict that is implemented by including a concrete subtype of AbstractDict as its data attribute.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/CompositeStructures/#QuantumLattices.Prerequisites.CompositeStructures.CompositeNTuple","page":"Composite structures","title":"QuantumLattices.Prerequisites.CompositeStructures.CompositeNTuple","text":"CompositeNTuple{N, T}\n\nA composite ntuple can be considered as a ntuple that is implemented by including an ordinary NTuple as its data attribute.\n\nAlias for CompositeTuple{NTuple{N, T}}.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/CompositeStructures/#QuantumLattices.Prerequisites.CompositeStructures.CompositeTuple","page":"Composite structures","title":"QuantumLattices.Prerequisites.CompositeStructures.CompositeTuple","text":"CompositeTuple{T<:Tuple}\n\nA composite tuple can be considered as a tuple that is implemented by including an ordinary Tuple as its data attribute.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/CompositeStructures/#QuantumLattices.Prerequisites.CompositeStructures.CompositeVector","page":"Composite structures","title":"QuantumLattices.Prerequisites.CompositeStructures.CompositeVector","text":"CompositeVector{T}\n\nA composite vector can be considered as a vector that is implemented by including a concrete subtype of AbstractVector as its data attribute.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/CompositeStructures/#QuantumLattices.Prerequisites.CompositeStructures.NamedContainer","page":"Composite structures","title":"QuantumLattices.Prerequisites.CompositeStructures.NamedContainer","text":"NamedContainer{T, Names} = NamedTuple{Names, <:Tuple{Vararg{T}}}\n\nNamedContainer is just a wrapper of Julia NamedTuple, but not a composite type.\n\n\n\n\n\n","category":"type"},{"location":"man/Prerequisites/CompositeStructures/#QuantumLattices.Prerequisites.CompositeStructures.NamedContainer-Union{Tuple{Tuple}, Tuple{Names}} where Names","page":"Composite structures","title":"QuantumLattices.Prerequisites.CompositeStructures.NamedContainer","text":"NamedContainer{Names}(contents) where Names -> NamedTuple{Names, typeof(contents)}\n\nConstruct a named container.\n\n\n\n\n\n","category":"method"},{"location":"man/Interfaces/","page":"Interfaces","title":"Interfaces","text":"CurrentModule = QuantumLattices.Interfaces","category":"page"},{"location":"man/Interfaces/#interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"man/Interfaces/","page":"Interfaces","title":"Interfaces","text":"This module contains the generic functions that are extended by the package.","category":"page"},{"location":"man/Interfaces/","page":"Interfaces","title":"Interfaces","text":"Due to the multi-dispatch feature of Julia, generic functions can be extended by local methods for different types. However, a local definition of a method also claims a new generic function if the generic function is not imported to the current scope, thus ruins the definitions in other modules. Therefore, it is quite necessary to predefine the common generic functions in a separate module, so that other modules can extend them with their own by a simple import.","category":"page"},{"location":"man/Interfaces/#Manual","page":"Interfaces","title":"Manual","text":"","category":"section"},{"location":"man/Interfaces/","page":"Interfaces","title":"Interfaces","text":"Modules = [Interfaces]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.:⊕","page":"Interfaces","title":"QuantumLattices.Interfaces.:⊕","text":"Direct sum.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.:⊗","page":"Interfaces","title":"QuantumLattices.Interfaces.:⊗","text":"Direct product.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.:⋅","page":"Interfaces","title":"QuantumLattices.Interfaces.:⋅","text":"Dot product.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.add!","page":"Interfaces","title":"QuantumLattices.Interfaces.add!","text":"Inplace addition.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.decompose","page":"Interfaces","title":"QuantumLattices.Interfaces.decompose","text":"Decompose.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.decompose!","page":"Interfaces","title":"QuantumLattices.Interfaces.decompose!","text":"In place decomposition.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.dimension","page":"Interfaces","title":"QuantumLattices.Interfaces.dimension","text":"Dimension.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.div!","page":"Interfaces","title":"QuantumLattices.Interfaces.div!","text":"Inplace division.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.expand","page":"Interfaces","title":"QuantumLattices.Interfaces.expand","text":"Get the expansion.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.expand!","page":"Interfaces","title":"QuantumLattices.Interfaces.expand!","text":"In place expansion.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.id","page":"Interfaces","title":"QuantumLattices.Interfaces.id","text":"ID.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.mul!","page":"Interfaces","title":"QuantumLattices.Interfaces.mul!","text":"Inplace multiplication.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.permute","page":"Interfaces","title":"QuantumLattices.Interfaces.permute","text":"Get the permutation.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.rank","page":"Interfaces","title":"QuantumLattices.Interfaces.rank","text":"Rank.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.sub!","page":"Interfaces","title":"QuantumLattices.Interfaces.sub!","text":"Inplace subtraction.\n\n\n\n\n\n","category":"function"},{"location":"man/Interfaces/#QuantumLattices.Interfaces.value","page":"Interfaces","title":"QuantumLattices.Interfaces.value","text":"Value.\n\n\n\n\n\n","category":"function"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"CurrentModule = QuantumLattices.Mathematics.Combinatorics","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"push!(LOAD_PATH, \"../../../../src/\")\nusing QuantumLattices.Mathematics.Combinatorics","category":"page"},{"location":"man/Mathematics/Combinatorics/#Combinatorics","page":"Combinatorics","title":"Combinatorics","text":"","category":"section"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"This module implements the combinations and permutations of an indexable object, with duplicate elements allowed or not. Compared to another Julia package Combinatorics, the iterators return tuples instead of vectors, which greatly decreases the memory allocation times and improves the code efficiency.","category":"page"},{"location":"man/Mathematics/Combinatorics/#AbstractCombinatorics","page":"Combinatorics","title":"AbstractCombinatorics","text":"","category":"section"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"AbstractCombinatorics{M, C} is the abstract type of all combinatoric algorithms. It has two type parameters:","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"M: the number of elements to be taken\nC: the type of the collection of candidate elements","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"To avoid memory allocation, the iteration of a concrete combinatoric algorithm returns a tuple, whose length is M and eltype is eltype(C).","category":"page"},{"location":"man/Mathematics/Combinatorics/#Combinations-and-DulCombinations","page":"Combinatorics","title":"Combinations and DulCombinations","text":"","category":"section"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"Combinations{M, C} and DulCombinations generate all the combinations of M elements from an indexable collection whose type is C, with the differences being that the former forbids duplicate elements in the combinations while the latter allows.","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"All combinations of 2 integers taken from 1 to 3 without duplicate:","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"Combinations{2}(1:3) |> collect","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"All combinations of 2 integers taken from 1 to 3 with duplicate allowed:","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"DulCombinations{2}(1:3) |> collect","category":"page"},{"location":"man/Mathematics/Combinatorics/#Permutations-and-DulPermutations","page":"Combinatorics","title":"Permutations and DulPermutations","text":"","category":"section"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"Permutations{M, C} and DulPermutations generate all the permutations of M elements from an indexable collection whose type is C, with the differences being that the former forbids duplicate elements in the permutations while the latter allows.","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"All permutations of 2 integers taken from 1 to 3 without duplicate:","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"Permutations{2}(1:3) |> collect","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"All permutations of 2 integers taken from 1 to 3 with duplicate allowed:","category":"page"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"DulPermutations{2}(1:3) |> collect","category":"page"},{"location":"man/Mathematics/Combinatorics/#Manual","page":"Combinatorics","title":"Manual","text":"","category":"section"},{"location":"man/Mathematics/Combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"Modules = [Combinatorics]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Mathematics/Combinatorics/#QuantumLattices.Mathematics.Combinatorics.AbstractCombinatorics","page":"Combinatorics","title":"QuantumLattices.Mathematics.Combinatorics.AbstractCombinatorics","text":"AbstractCombinatorics{M, C}\n\nAbstract combinatoric algorithms.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/Combinatorics/#QuantumLattices.Mathematics.Combinatorics.Combinations","page":"Combinatorics","title":"QuantumLattices.Mathematics.Combinatorics.Combinations","text":"Combinations{M}(contents::C) where {M, C}\n\nCombinations of M elements from contents. Duplicates are not allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/Combinatorics/#QuantumLattices.Mathematics.Combinatorics.DulCombinations","page":"Combinatorics","title":"QuantumLattices.Mathematics.Combinatorics.DulCombinations","text":"DulCombinations{M}(contents::C) where {M, C}\n\nCombinations of M elements from contents. Duplicates are allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/Combinatorics/#QuantumLattices.Mathematics.Combinatorics.DulPermutations","page":"Combinatorics","title":"QuantumLattices.Mathematics.Combinatorics.DulPermutations","text":"DulPermutations{M}(contents::C) where {M, C}\n\nPermutations of M elements from contents. Duplicates are allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/Combinatorics/#QuantumLattices.Mathematics.Combinatorics.Permutations","page":"Combinatorics","title":"QuantumLattices.Mathematics.Combinatorics.Permutations","text":"Permutations{M}(contents::C) where {M, C}\n\nPermutations of M elements from contents. Duplicates are not allowed.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/UnitcellDescription/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"CurrentModule = QuantumLattices","category":"page"},{"location":"tutorials/UnitcellDescription/GeneratorOfOperators/#Generator-of-operators","page":"Generator of operators","title":"Generator of operators","text":"","category":"section"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"CurrentModule = QuantumLattices.Mathematics.VectorSpaces","category":"page"},{"location":"man/Mathematics/VectorSpaces/#Vector-spaces","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"A vector space is a linear space, in which the addition of vectors and multiplication of a vector by a scalar are defined.","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"Vector spaces are frequently encountered in physics, e.g. the Hilbert space in quantum mechanics. In this submodule, we only implement those with finite dimensions. We want to remark that in our implementation, a vector space is a subtype of an abstract vector, therefore, the bases always possess a order, which means, two vector spaces are not considered to be equal to each other even if their corresponding actual mathematical spaces are the same but the orders of the bases are different.","category":"page"},{"location":"man/Mathematics/VectorSpaces/#VectorSpace","page":"Vector spaces","title":"VectorSpace","text":"","category":"section"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"VectorSpace{B} is the abstraction of a vector space, which has only one type parameter:","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"B<:Any: the type of the bases of the vector space","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"Basically, a subtype should implement the following 3 methods:","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"dimension(vs::VectorSpace) -> Int\nGet the dimension of a vector space\nBase.getindex(vs::VectorSpace{B}, i::Int)  where B -> B\nGet the ith basis of a vector space\nBase.searchsortedfirst(vs::VectorSpace{B}, basis::B) where B -> Int\nSearch the index of a basis in a vector space","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"Other features include","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"comparison: == and isequal\niteration: iterate\ninquiry: size, findfirst and in","category":"page"},{"location":"man/Mathematics/VectorSpaces/#EnumerativeVectorSpace","page":"Vector spaces","title":"EnumerativeVectorSpace","text":"","category":"section"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"EnumerativeVectorSpace is the simplest vector space, whose bases are stored in the predefined content :table.","category":"page"},{"location":"man/Mathematics/VectorSpaces/#CartesianVectorSpace","page":"Vector spaces","title":"CartesianVectorSpace","text":"","category":"section"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianVectorSpace defines the abstract class of multiindexable vector spaces, whose bases can be accessed by a Cartesian index.","category":"page"},{"location":"man/Mathematics/VectorSpaces/#NamedVectorSpace","page":"Vector spaces","title":"NamedVectorSpace","text":"","category":"section"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"NamedVectorSpace{M, NS, BS, VS} defines a multiindexable vector space, each of whose indexable dimensions is associated with a name.","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"It has four type parameters:","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"M: mode of the named vector space. It specifies how the indexable dimensions are combined to form the bases of the named vector space, and must take one of the following values:\n:⊕: elements from each indexable dimensions are zipped together to form the bases,\n:⊗: elements from each indexable dimensions are direct producted together to form the bases.","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"For the :⊕ mode, all the indexable dimensions should have the same number of elements, and the number of formed bases is equal to this number; for the :⊗ mode, there are no restriction on the numbers of the indexable dimensions, and the number of the final bases is equal to their product.","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"NS::Tuple{Vararg{Symbol}}: the names of the indexable dimensions\nBS<:Tuple: the eltypes of the indexable dimensions\nVS<:Tuple{Vararg{AbstractVector}}: the contents of the indexable dimensions","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"The concrete types must have the following predefined content:","category":"page"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":":contents::VS: storage of the contents of the indexable dimensions","category":"page"},{"location":"man/Mathematics/VectorSpaces/#Manual","page":"Vector spaces","title":"Manual","text":"","category":"section"},{"location":"man/Mathematics/VectorSpaces/","page":"Vector spaces","title":"Vector spaces","text":"Modules = [VectorSpaces]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Mathematics/VectorSpaces/#QuantumLattices.Mathematics.VectorSpaces.CartesianVectorSpace","page":"Vector spaces","title":"QuantumLattices.Mathematics.VectorSpaces.CartesianVectorSpace","text":"CartesianVectorSpace{B} <: VectorSpace{B}\n\nAbstract Cartesian vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/VectorSpaces/#QuantumLattices.Mathematics.VectorSpaces.EnumerativeVectorSpace","page":"Vector spaces","title":"QuantumLattices.Mathematics.VectorSpaces.EnumerativeVectorSpace","text":"EnumerativeVectorSpace{B} <: VectorSpace{B}\n\nAbstract enumerative vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/VectorSpaces/#QuantumLattices.Mathematics.VectorSpaces.NamedVectorSpace","page":"Vector spaces","title":"QuantumLattices.Mathematics.VectorSpaces.NamedVectorSpace","text":"NamedVectorSpace{M, NS, BS<:Tuple, VS<:Tuple{Vararg{AbstractVector}}} <: CartesianVectorSpace{NamedTuple{NS, BS}}\n\nAbstract named vector space.\n\nThis is a wrapper of Cartesian indexable vector spaces, each of whose indexable dimensions is associated with a name.\n\nIt has four type parameters:\n\nM: mode of the named vector space. It specifies how the indexable dimensions are combined to form the bases of the named vector space, and must take one of the following values:\n:⊕: elements from each indexable dimensions are zipped together to form the bases,\n:⊗: elements from each indexable dimensions are direct producted together to form the bases.\n\nFor the :⊕ mode, all the indexable dimensions should have the same number of elements, and the number of formed bases is equal to this number; for the :⊗ mode, there are no restriction on the numbers of the indexable dimensions, and the number of the final bases is equal to their product.\n\nNS::Tuple{Vararg{Symbol}}: the names of the indexable dimensions\nBS<:Tuple: the eltypes of the indexable dimensions\nVS<:Tuple{Vararg{AbstractVector}}: the contents of the indexable dimensions\n\nThe subtypes must have the following predefined content:\n\n:contents::VS: storage of the contents of the indexable dimensions\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/VectorSpaces/#QuantumLattices.Mathematics.VectorSpaces.VectorSpace","page":"Vector spaces","title":"QuantumLattices.Mathematics.VectorSpaces.VectorSpace","text":"VectorSpace{B} <: AbstractVector{B}\n\nAbstract vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/VectorSpaces/#Base.eltype-Tuple{QuantumLattices.Mathematics.VectorSpaces.NamedVectorSpace, Int64}","page":"Vector spaces","title":"Base.eltype","text":"eltype(nvs::NamedVectorSpace, i::Int)\neltype(::Type{<:NamedVectorSpace{M, NS, BS} where {M, NS}}, i::Int) where BS\n\nGet the eltype of the ith indexable dimensions of a named vector space.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/VectorSpaces/#Base.keys-Tuple{QuantumLattices.Mathematics.VectorSpaces.NamedVectorSpace}","page":"Vector spaces","title":"Base.keys","text":"keys(nvs::NamedVectorSpace) -> Tuple{Vararg{Symbol}}\nkeys(::Type{<:NamedVectorSpace{M, NS} where M}) where NS -> Tuple{Vararg{Symbol}}\n\nGet the names of a named vector space.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/VectorSpaces/#Base.pairs-Tuple{QuantumLattices.Mathematics.VectorSpaces.NamedVectorSpace}","page":"Vector spaces","title":"Base.pairs","text":"pairs(nvs::NamedVectorSpace) -> Base.Iterators.Pairs\n\nGet the name-value pairs of a named vector space.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/VectorSpaces/#Base.values-Tuple{QuantumLattices.Mathematics.VectorSpaces.NamedVectorSpace}","page":"Vector spaces","title":"Base.values","text":"values(nvs::NamedVectorSpace) -> Tuple{Vararg{AbstractVector}}\n\nGet the contents of a named vector space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = QuantumLattices","category":"page"},{"location":"tutorials/UnitcellDescription/Introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"A quantum lattice system can be completely described within its unitcell. Basically, this description should contain three types of information:","category":"page"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"the spatial information, such as the coordinates of the points contained in the unitcell;\nthe internal degrees of freedom, such as the local Hilbert space on each point;\nthe couplings among different degrees of freedom, such as the interaction terms in the Hamiltonian.","category":"page"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"In theory, as long as the above information is told, one could easily write down the operator representation of the Hamiltonian of the system. For example, in the phrase \"the single orbital electronic Hubbard model with only nearest neighbor hopping on a one dimensional lattice with only two sites\", \"one dimensional lattice with only two sites\" is the spatial information, \"single orbital electronic\" defines the local Hilbert spaces, and \"Hubbard model with only nearest neighbor hopping\" describes the terms present in the Hamiltonian. From this phrase, we also know that the Hamiltonian of the system is","category":"page"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"H=tc^_1c_2+tc^_2c_1+tc^_1c_2+tc^_2c_1+Uc^_1c_1c^_1c_1+Uc^_2c_2c^_2c_2","category":"page"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"where t is the hopping amplitude， U is the Hubbard interaction strength and the electronic annihilation/creation operator c^dagger_isigmac_isigma carries a site index i (i=1 2) and a spin index sigma (sigma=uparrow downarrow). Actually, the unitcell description framework follows exactly after the above train of thought. For example, the aforementioned system can be constructed by the following codes:","category":"page"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"using QuantumLattices\nusing SymPy: symbols\n\n# define the unitcell\nlattice = Lattice(\"L2P\", [Point(PID(1), [0.0]), Point(PID(2), [1.0])])\n\n# define the internal degrees of freedom\nconfig = Config{Fock{:f}}(pid->Fock{:f}(norbital=1, nspin=2), lattice.pids)\n\n# define the terms\nt = Hopping(:t, symbols(\"t\", real=true), 1)\nU = Hubbard(:U, symbols(\"U\", real=true))\n\n# get the Hamiltonian\noperators = expand(Generator((t, U), Bonds(lattice), config))","category":"page"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"The last line displays all the generated operators in the Hamiltonian in the latex form. Here, in the subscript of the electronic annihilation/creation operator, an extra orbital index is also displayed. In the following sections listed below, we will explain in brief how these codes work. Firstly, in the section of Spatial info of a unitcell, we will introduce the construction of the unitcell. Secondly, in the section of Internal degrees of freedom, we will explain the description of the internal degrees of freedom of different kinds of quantum systems. Thirdly, in the section of Couplings among different degrees of freedom, we will discuss the ways to specify the terms present in the Hamiltonian. Finally, in the section of Generator of operators, we will show how to combine all to get the operator representation of the Hamiltonian of a quantum lattice system. For more detailed explanations, the manual of Essentials can also be referred.","category":"page"},{"location":"tutorials/UnitcellDescription/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"SpatialInfoOfAUnitcell.md\",\n        \"InternalDegreesOfFreedom.md\",\n        \"CouplingsAmongDifferentDegreesOfFreedom.md\",\n        \"GeneratorOfOperators.md\",\n        ]\nDepth = 2","category":"page"},{"location":"tutorials/UnitcellDescription/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"CurrentModule = QuantumLattices","category":"page"},{"location":"tutorials/UnitcellDescription/CouplingsAmongDifferentDegreesOfFreedom/#Couplings-among-different-degrees-of-freedom","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/CouplingsAmongDifferentDegreesOfFreedom/#Coupling-and-Couplings","page":"Couplings among different degrees of freedom","title":"Coupling and Couplings","text":"","category":"section"},{"location":"tutorials/UnitcellDescription/CouplingsAmongDifferentDegreesOfFreedom/#Term","page":"Couplings among different degrees of freedom","title":"Term","text":"","category":"section"},{"location":"tutorials/EngineAppInterface/Introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/EngineAppInterface/Introduction/","page":"Introduction","title":"Introduction","text":"Although we can get the symbolic representation of the Hamiltonians by our unitcell-description framework, there still remains a long way to implement concrete algorithms such as TBA, ED, etc. Despite the quite different technical details, algorithms shares common functionalities to be furnished with:","category":"page"},{"location":"tutorials/EngineAppInterface/Introduction/","page":"Introduction","title":"Introduction","text":"provide tasks to be conducted with controlling parameters;\nrecord the results of some tasks for later use or analysis;\nupdate some parameters of the QuantumLattices to reconduct tasks;\nkeep logs during code executions for debug;\ncache intermediate data to improve efficiency;\n...","category":"page"},{"location":"tutorials/EngineAppInterface/Introduction/","page":"Introduction","title":"Introduction","text":"We thus provide a set of generic interfaces to resolve these problems, basically in the so called Engine-App mode. Specifically, algorithms are treated as Engine and tasks as App. Engine deals with the cores of algorithms along with file management, parameter updating and data caching, while App decides the concrete tasks to be conducted and provides hyper controlling parameters.","category":"page"},{"location":"man/Essentials/Frameworks/","page":"Frameworks","title":"Frameworks","text":"CurrentModule = QuantumLattices.Essentials.Frameworks","category":"page"},{"location":"man/Essentials/Frameworks/","page":"Frameworks","title":"Frameworks","text":"push!(LOAD_PATH, \"../../../../src/\")\nusing QuantumLattices","category":"page"},{"location":"man/Essentials/Frameworks/#Frameworks","page":"Frameworks","title":"Frameworks","text":"","category":"section"},{"location":"man/Essentials/Frameworks/#App-and-Engine","page":"Frameworks","title":"App and Engine","text":"","category":"section"},{"location":"man/Essentials/Frameworks/#Assignment","page":"Frameworks","title":"Assignment","text":"","category":"section"},{"location":"man/Essentials/Frameworks/#Algorithm","page":"Frameworks","title":"Algorithm","text":"","category":"section"},{"location":"man/Essentials/Frameworks/#Manual","page":"Frameworks","title":"Manual","text":"","category":"section"},{"location":"man/Essentials/Frameworks/","page":"Frameworks","title":"Frameworks","text":"Modules = [Frameworks]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.Algorithm","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.Algorithm","text":"Algorithm(name::String, engine::Engine;\n    din::String=\".\",\n    dout::String=\".\",\n    parameters::Union{Parameters, Nothing}=nothing,\n    map::Function=identity,\n    assignments::Tuple{Vararg{Assignment}}=(),\n    kwargs...\n    )\n\nAn algorithm associated with an engine.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.App","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.App","text":"App\n\nAbstract type for all apps.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.Assignment","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.Assignment","text":"Assignment(id::Symbol, app::App, parameters::Parameters;\n    map::Function=identity,\n    dependences::Tuple{Vararg{Symbol}}=(),\n    data::Any=nothing,\n    savedata::Bool=true,\n    virgin::Bool=true,\n    kwargs...\n    )\n\nAn assignment associated with an app.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.Engine","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.Engine","text":"Engine\n\nAbstract type for all engines.\n\n\n\n\n\n","category":"type"},{"location":"man/Essentials/Frameworks/#Base.:==-Tuple{Assignment, Assignment}","page":"Frameworks","title":"Base.:==","text":"==(assign1::Assignment, assign2::Assignment) -> Bool\n\nJudge whether two assignments are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#Base.get-Tuple{Algorithm, Symbol}","page":"Frameworks","title":"Base.get","text":"get(alg::Algorithm, id::Symbol) -> Assignment\nget(alg::Algorithm, ::Val{id}) where id -> Assignment\n\nFind the assignment registered on a algorithm by its id.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#Base.isequal-Tuple{Assignment, Assignment}","page":"Frameworks","title":"Base.isequal","text":"isequal(assign1::Assignment, assign2::Assignment) -> Bool\n\nJudge whether two assignments are equivalent to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#Base.repr","page":"Frameworks","title":"Base.repr","text":"repr(alg::Algorithm, mask::Tuple{Vararg{Symbol}}=(); ndecimal::Int=10) -> String\n\nGet the repr representation of an algorithm.\n\nOptionally, some parameters of the algorithm can be masked. Besides, the maximum number of decimals of the parameters can also be specified.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Frameworks/#Base.show-Tuple{IO, Algorithm}","page":"Frameworks","title":"Base.show","text":"show(io::IO, alg::Algorithm)\n\nShow an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#Base.summary-Tuple{Algorithm}","page":"Frameworks","title":"Base.summary","text":"summary(alg::Algorithm)\n\nProvide a summary of an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#Base.valtype-Tuple{Assignment}","page":"Frameworks","title":"Base.valtype","text":"valtype(assign::Assignment)\nvaltype(::Type{<:Assignment})\n\nThe type of the data(result) of an assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.dependences","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.dependences","text":"dependences(alg::Algorithm, assign::Assignment, ::Tuple{}=()) -> Tuple{Vararg{Symbol}}\ndependences(alg::Algorithm, assign::Assignment, mask::Tuple{Vararg{Symbol}}) -> Tuple{Vararg{Symbol}}\n\nGet the dependences of an assignment and return their ids.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.prepare!-Tuple{Algorithm, Assignment}","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.prepare!","text":"prepare!(alg::Algorithm, assign::Assignment) -> Nothing\n\nPrepare an assignment registered on a algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.register!-Tuple{Algorithm, Symbol, App}","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.register!","text":"register!(alg::Algorithm, id::Symbol, app::App; kwargs...) -> Algorithm\n\nAdd an assignment on a algorithm by providing the contents of the assignment, and run this assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.run!","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.run!","text":"run!(alg::Algorithm, id::Symbol, timing::Bool=true) -> Algorithm\nrun!(alg::Algorithm, ::Val{id}, timing::Bool=true) where id -> Algorithm\n\nRun an assignment with the given id registered on an algorithm. Optionally, the run process can be timed by setting the timing argument to be true.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.run!-Tuple{Algorithm, Assignment}","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.run!","text":"run!(alg::Algorithm, assign::Assignment) -> Nothing\n\nRun an assignment registered on a algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.Frameworks.rundependences!","page":"Frameworks","title":"QuantumLattices.Essentials.Frameworks.rundependences!","text":"rundependences!(alg::Algorithm, assign::Assignment, mask::Tuple{Vararg{Symbol}}=()) -> Algorithm\n\nRun the dependences of an assignment. Optionally, some dependences can be jumped by specifying the mask argument.\n\n\n\n\n\n","category":"function"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.update!-Tuple{Algorithm}","page":"Frameworks","title":"QuantumLattices.Essentials.update!","text":"update!(alg::Algorithm; kwargs...) -> Algorithm\n\nUpdate the parameters of an algorithm and its associated engine.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.update!-Tuple{App}","page":"Frameworks","title":"QuantumLattices.Essentials.update!","text":"update!(app::App; kwargs...) -> App\n\nUpdate the status of an app.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.update!-Tuple{Assignment}","page":"Frameworks","title":"QuantumLattices.Essentials.update!","text":"update!(assign::Assignment; kwargs...) -> Assignment\n\nUpdate the parameters of an assignment and the status of its associated app.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Essentials.update!-Tuple{Engine}","page":"Frameworks","title":"QuantumLattices.Essentials.update!","text":"update!(engine::Engine; kwargs...) -> Engine\n\nUpdate the status of an engine.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Interfaces.add!-Tuple{Algorithm, Symbol, App}","page":"Frameworks","title":"QuantumLattices.Interfaces.add!","text":"add!(alg::Algorithm, id::Symbol, app::App; kwargs...) -> Algorithm\n\nAdd an assignment on a algorithm by providing the contents of the assignment.\n\nThe difference between add! and register! is that the add! function does not run the newly added assignment but the register! function does.\n\n\n\n\n\n","category":"method"},{"location":"man/Essentials/Frameworks/#QuantumLattices.Interfaces.id-Tuple{Assignment}","page":"Frameworks","title":"QuantumLattices.Interfaces.id","text":"id(assign::Assignment) -> Symbol\nid(::Type{<:Assignment}) -> Symbol\n\nThe id of an assignment.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule=QuantumLattices","category":"page"},{"location":"#QuantumLattices","page":"Home","title":"QuantumLattices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package for the construction of quantum lattice systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to QuantumLattices. Here we provide a general framework to construct the second quantized operator formed Hamiltonian of any quantum lattice system, with the inputs as simple as its description by natural languages. Combined with SymPy, this operator formed Hamiltonian supports complete symbolic computations, making it a convenient prerequisite of quantum many-body algorithms, such as TBA(tight-bind approximation), SCMF(self-consistent mean field theory), ED(exact diagonalization), CPT/VCA(cluster perturbation theory and variational cluster approach ), DMRG(density matrix renormalization group), etc. Generic interfaces are defined to give a unified access to these algorithms although their real implementations come in separate packages. Only minor modifications need be made when users alter from one algorithm to another.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core of the package is the construction of the operator representations of lattice Hamiltonians. This is based on the following mathematical observations that the operators in a lattice Hamiltonian:","category":"page"},{"location":"","page":"Home","title":"Home","text":"act on local Hilbert spaces, and\nform algebras over the complex field.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first observation is the starting point of our unitcell description framework and the second is the mathematical foundation of our symbolic computing system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is noted that our implementation of the symbolic computation only involves","category":"page"},{"location":"","page":"Home","title":"Home","text":"the mathematical operations between a scalar and an operator, and\nthe mathematical operations between two operators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The symbolic operations between two scalars are not implemented because:","category":"page"},{"location":"","page":"Home","title":"Home","text":"in condensed matter physics, for many cases, only the numerical values of operators are important because the analytical expressions can be too complicated to analyze or they may even not exist;\nour construction process of the operators and their mathematical operations are completely compatible with the SymPy package, therefore, a fully symbolic computation can be achieved by a simple combination of both.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another major aim of this package is to provide unified interfaces to access all quantum-many algorithms. Much of the job can be done by the construction of the operator-formed Hamiltonians, which serves as a common input for different algorithms. The remaining stuff concerns mainly with project management, such as result recording, data caching, parameter updating, code logging, dependency managing, etc. Utilities are provided to handle these tasks.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unitcell Description Framework: by telling the information of the quantum lattice system within a unitcell, the construction of the symbolic representation of the Hamiltonian is just as simple as describing the system in a usual research paper.\nComplete symbolic computation: with only this package, symbolic computation between operators is realized whereas the coefficient of any operator remains numeric; by integrating it with SymPy, complete symbolic computation can be achieved and no modifications need be made on the methods in this package.\nGeneric Engine-App Interfaces: by regarding the relation between algorithms and tasks as that between engines and apps, automatic project management is realized, including that of result recording, data caching, parameter updating, code logging, dependency managing, etc., moreover, all algorithms are initialized in quite similar ways with only minor modifications needed.","category":"page"},{"location":"#Supported-Systems","page":"Home","title":"Supported Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Three common kinds of systems in condensed matter physics are perfectly supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"canonical fermionic systems\ncanonical/hard-core bosonic systems\nSU(2) spin systems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, other systems can be supported easily by extending the generic \"protocols\" provided in this package.","category":"page"},{"location":"#Supported-Algorithms","page":"Home","title":"Supported Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Concrete algorithms are implemented in separate packages (still in progress):","category":"page"},{"location":"","page":"Home","title":"Home","text":"TBA: tight-binding approximation for fermionic/bosonic systems;\nSCMF: self-consistent mean field theory for fermionic systems;\nED: exact diagonalization for fermionic/hard-core-bosonic/spin systems;\nCPT/VCA: cluster perturbation theory and variational cluster approach for fermionic systems;\nDMRG: density matrix renormalization group for fermionic/hard-core-bosonic/spin systems;\nLSWT: linear spin wave theory for local spin systems;\nFBFMSW: spin wave theory for flatband ferromagnets.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tutorials: unitcell description","category":"page"},{"location":"#Python-counterpart","page":"Home","title":"Python counterpart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HamiltonianPy: in fact, the authors of this Julia package worked on the python package at first and only turned to Julia later.","category":"page"},{"location":"man/Mathematics/Introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = QuantumLattices.Mathematics","category":"page"},{"location":"man/Mathematics/Introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/Mathematics/Introduction/","page":"Introduction","title":"Introduction","text":"This module contains the mathematical prerequisites of the package.","category":"page"},{"location":"man/Mathematics/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"Combinatorics.md\",\n        \"VectorSpaces.md\",\n        \"AlgebraOverFields.md\",\n        \"QuantumNumbers.md\",\n        ]\nDepth = 2","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"CurrentModule = QuantumLattices.Mathematics.QuantumNumbers","category":"page"},{"location":"man/Mathematics/QuantumNumbers/#Quantum-numbers","page":"Quantum numbers","title":"Quantum numbers","text":"","category":"section"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Quantum numbers can be considered as the conserved labels for the bases of a Hilbert space when a quantum system hosts some symmetries. Here we only implement Abelian quantum numbers because non-Abelian ones are far more complicated yet much less used. In practice, quantum numbers can be integers or half integers, therefore, we use real numbers to denote them in this module for simplicity. Independent quantum numbers, such as the particle number and the spin z-component, can coexist at the same time. We use type AbelianNumber to represent the complete set of independent ones for a single basis of a Hilbert space, and type AbelianNumbers to represent the whole quantum numbers for the total bases.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/#AbelianNumber","page":"Quantum numbers","title":"AbelianNumber","text":"","category":"section"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"The abstract type for the complete set of independent quantum numbers for a single basis.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Main features include:","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"function periods: get the periods of the quantum numbers\narithmetic operations: +, -, *, ^, ⊕, ⊗\nhashable: concrete instances can be used as keys for a dict or a set\niterable: concrete instances are iterable over their values\ncomparable: two concrete instances can be compared","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"In particular, AbelianNumber <: HomoNamedVector{Float}, all features supported by HomoNamedVector are also available for HomoNamedVector. See also HomoNamedVector.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"For convenience, 3 kinds of quantum numbers are predefined in this module, i.e.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"SQN: for spin z-component reserved systems\nPQN: for particle number reserved systems\nSPQN: for both particle number and spin-z component reserved systems","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Users who want to define their own Z_N-like quantum numbers must handle the periodicity in the construction function, otherwise, wrong results will be get when arithmetic operations, such as + or -, are involved. It is recommended to use the macro @abeliannumber to define your own concrete AbelianNumbers.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/#AbelianNumbers","page":"Quantum numbers","title":"AbelianNumbers","text":"","category":"section"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"The whole quantum numbers for the total bases.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"By design, a AbelianNumbers{QN} has one type parameter:","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"QN<:AbelianNumber: the type of the quantum numbers contained in it","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"And 3 attributes:","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"form::Char: Its form, whose value must be one of the followings\n'G': the general form, which has no restriction for its contents\n'U': the unitary form, which requires no duplicates in its contents\n'C': the canonical form, which requires both no duplicates and ascending-order in its contents\nUsually, G-formed and U-formed AbelianNumberses can be transformed to the corresponding C-formed ones by the sort function.\ncontents::Vector{QN}: The quantum numbers contained in it. To achieve high efficiency, it is required to be an homogenous array of a certain kind of concrete AbelianNumber.\nindptr::Vector{Int}: The indptr of the quantum numbers contained in it, which is similar to the colptr attribute of a CSC sparse matrix and records the compression info of its contents.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Main features include:","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"function eltype: get the concrete type of the quantum numbers it contains\nindex access: get the contents directly by the getindex function\narithmetic operations: +, -, *, ^, ⊗, ⊕\niterable: various iteration supports, including functions such as iterate, keys, values and pairs","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"For a complete summation of its features, please refer to the manual.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"For convenience, 3 functions are predefined to generate the AbelianNumbers of common physical systems, i.e.","category":"page"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"SQNS: a single spin\nPQNS: a single-particle state with at most N identical particles\nSPQNS: a single site with internal degrees of freedom that can be ascribed to a spin","category":"page"},{"location":"man/Mathematics/QuantumNumbers/#qnmanual","page":"Quantum numbers","title":"Manual","text":"","category":"section"},{"location":"man/Mathematics/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Modules = [QuantumNumbers]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","text":"Abstract type for all concrete quantum numbers for a single basis.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers{QN<:AbelianNumber} <: EnumerativeVectorSpace{QN}\n\nThe whole quantum numbers of the total bases of a Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers-2","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(qn::AbelianNumber, count::Int=1)\n\nConstruct an AbelianNumbers with one unique quantum number which occurs count times.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers-Tuple{Char, Vector{var\"#s11\"} where var\"#s11\"<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber, Vector{Int64}, Symbol}","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(form::Char, contents::Vector{<:AbelianNumber}, indptr::Vector{Int}, choice::Symbol)\nAbelianNumbers(form::Char, contents::Vector{<:AbelianNumber}, counts::Vector{Int}, ::Val{:counts})\nAbelianNumbers(form::Char, contents::Vector{<:AbelianNumber}, indptr::Vector{Int}, ::Val{:indptr})\n\nConstruct an AbelianNumbers from a vector of concrete quantum numbers and an vector containing their counts or indptr.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var\"#s3\", var\"#s2\"} where {var\"#s3\"<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber, var\"#s2\"<:(UnitRange{var\"#s1\"} where var\"#s1\"<:Integer)}}","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(od::OrderedDict{<:AbelianNumber, <:UnitRange{<:Integer}})\n\nConstruct an AbelianNumbers from an ordered dict containing concrete quantum numbers and their slices.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var\"#s4\", var\"#s3\"} where {var\"#s4\"<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber, var\"#s3\"<:Integer}}","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers","text":"AbelianNumbers(od::OrderedDict{<:AbelianNumber, <:Integer})\n\nConstruct an AbelianNumbers from an ordered dict containing concrete quantum numbers and their counts.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.Momentum","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.Momentum","text":"Momentum <: AbelianNumber\n\nAbstract type for momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.Momentum1D","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.Momentum1D","text":"Momentum1D{N}(k::Real) where N\n\nOne dimensional momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.Momentum2D","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.Momentum2D","text":"Momentum2D{N}(k₁::Real, k₂::Real) where N\nMomentum2D{N₁, N₂}(k₁::Real, k₂::Real) where {N₁, N₂}\n\nTwo dimensional momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.Momentum3D","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.Momentum3D","text":"Momentum3D{N}(k₁::Real, k₂::Real, k₃::Real) where N\nMomentum3D{N₁, N₂, N₃}(k₁::Real, k₂::Real, k₃::Real) where {N₁, N₂, N₃}\n\nThree dimensional momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.PQN","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.PQN","text":"PQN(N::Real)\n\nThe concrete AbelianNumber of a quantum system with particle number N conserved.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.SPQN","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.SPQN","text":"SPQN(N::Real, Sz::Real)\n\nThe concrete AbelianNumber of a quantum system with both particle number N and spin z-component Sz conserved.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.SQN","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.SQN","text":"SQN(Sz::Real)\n\nThe concrete AbelianNumber of a quantum system with spin z-component Sz conserved.\n\n\n\n\n\n","category":"type"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.@abeliannumber-Tuple{Any, Any, Any}","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.@abeliannumber","text":"@abeliannumber typename fields periods\n\nConstruct a concrete AbelianNumber with the type name being typename, fieldnames specified by fields and periods specified by periods.\n\n\n\n\n\n","category":"macro"},{"location":"man/Mathematics/QuantumNumbers/#Base.:*-Tuple{Integer, QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}","page":"Quantum numbers","title":"Base.:*","text":"*(factor::Integer, qns::AbelianNumbers) -> AbelianNumbers\n*(qns::AbelianNumbers, factor::Integer) -> AbelianNumbers\n\nOverloaded * operator for the multiplication between an integer and an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.:*-Tuple{Integer, QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}","page":"Quantum numbers","title":"Base.:*","text":"*(factor::Integer, qn::AbelianNumber) -> typeof(qn)\n*(qn::AbelianNumber, factor::Integer) -> typeof(qn)\n\nOverloaded * operator for the multiplication between an integer and an AbelianNumber.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.:+-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}","page":"Quantum numbers","title":"Base.:+","text":"+(qns::AbelianNumbers) -> AbelianNumbers\n+(qn::QN, qns::AbelianNumbers{QN}) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n+(qns::AbelianNumbers{QN}, qn::QN) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nOverloaded + operator for AbelianNumber/AbelianNumbers.\n\nnote: Note\nThe addition between an AbelianNumbers and an AbelianNumber is just a global shift of the contents of the AbelianNumbers by the AbelianNumber, therefore, the result is an AbelianNumbers.\n+ cannot be used between two AbelianNumbers because the result is ambiguous. Instead, use ⊕ for direct sum and ⊗ for direct product.\nTo ensure type stability, an AbelianNumber and an AbelianNumbers can be added together if and only if the former's type is the same with the latter's eltype.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.:+-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}","page":"Quantum numbers","title":"Base.:+","text":"+(qn::AbelianNumber) -> typeof(qn)\n+(qn::QN, qns::QN...) where {QN<:AbelianNumber} -> QN\n\nOverloaded + operator for AbelianNumber.\n\nnote: Note\nTo ensure type stability, two AbelianNumber can be added together if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.:--Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}","page":"Quantum numbers","title":"Base.:-","text":"-(qns::AbelianNumbers) -> AbelianNumbers\n-(qn::QN, qns::AbelianNumbers{QN}) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n-(qns::AbelianNumbers{QN}, qn::QN) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nOverloaded - operator for AbelianNumber/AbelianNumbers.\n\nnote: Note\nThe subtraction between an AbelianNumbers and an AbelianNumber is just a global shift of the contents of the AbelianNumbers by the AbelianNumber, therefore, the result is an AbelianNumbers.\n- cannot be used between two AbelianNumbers because the result is ambiguous. Instead, use ⊕ with signs for direct sum and ⊗ with signs for direct product.\nTo ensure type stability, an AbelianNumber can be subtracted by an AbelianNumbers or vice versa if and only if the former's type is the same with the latter's eltype.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.:--Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}","page":"Quantum numbers","title":"Base.:-","text":"-(qn::AbelianNumber) -> typeof(qn)\n-(qn1::QN, qn2::QN) where {QN<:AbelianNumber} -> QN\n\nOverloaded - operator for AbelianNumber and AbelianNumbers.\n\nnote: Note\nTo ensure type stability, an AbelianNumber can be subtracted by another AbelianNumber if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.:^-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber, Integer}","page":"Quantum numbers","title":"Base.:^","text":"^(qn::AbelianNumber, factor::Integer) -> typeof(qn)\n\nOverloaded ^ operator for AbelianNumber.\n\nThis operation translates into the direct product of factor copies of qn.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.:^-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers, Integer}","page":"Quantum numbers","title":"Base.:^","text":"^(qns::AbelianNumbers, factor::Integer) -> AbelianNumbers\n\nOverloaded ^ operator for AbelianNumbers.\n\nThis operation translates into the direct product of factor copies of qns.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.filter-Union{Tuple{QN}, Tuple{QN, QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}}} where QN<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"Base.filter","text":"filter(target::QN, qns::AbelianNumbers{QN}) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\nfilter(targets::Tuple{Vararg{QN}}, qns::AbelianNumbers{QN}) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nFind a subset of an AbelianNumbers by picking out the target quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.findall-Union{Tuple{QN}, Tuple{Union{Tuple{Vararg{QN, N} where N}, QN}, QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}, Symbol}} where QN<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"Base.findall","text":"findall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, choice::Symbol) where {QN<:AbelianNumber} -> Vector{Int}\nfindall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, ::Val{:compression}) where {QN<:AbelianNumber} -> Vector{Int})\nfindall(target::Union{QN, Tuple{Vararg{QN}}}, qns::AbelianNumbers{QN}, ::Val{:expansion}) where {QN<:AbelianNumber} -> Vector{Int}\n\nFind all the indices of the target quantum numbers in the contents or the expansion of an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.getindex-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers, UnitRange{Int64}}","page":"Quantum numbers","title":"Base.getindex","text":"getindex(qns::AbelianNumbers, slice::UnitRange{Int}) -> AbelianNumbers\ngetindex(qns::AbelianNumbers, indices::Vector{Int}) -> AbelianNumbers\n\nOverloaded [] operator.\n\nnote: Note\nFor an AbelianNumbers, all the getindex functions act on its contents, i.e. its compressed data, but not on its expansion, i.e. the uncompressed data. This definition is consistent with the size of an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.keys-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}","page":"Quantum numbers","title":"Base.keys","text":"keys(qns::AbelianNumbers) -> Vector{qns|>eltype}\n\nIterate over the concrete AbelianNumbers contained in an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.kron-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber, N} where N}","page":"Quantum numbers","title":"Base.kron","text":"kron(qns::Vararg{AbelianNumber}; signs=positives(qns))-> eltype(qns)\n\nGet the direct product of some AbelianNumbers.\n\nnote: Note\nPhysically, the direct product of a couple of AbelianNumbers are defined through the direct product of the bases of the Hilbert spaces they represent. Apparently, the result is still an AbelianNumber whose dimension is 1. At the same time, each component of the result is obtained by a summation of the corresponding components of the inputs with the correct signs. This is a direct consequence of the Abelian nature of our quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.kron-Union{Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}, N} where N}, Tuple{QN}} where QN<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"Base.kron","text":"kron(qnses::AbelianNumbers{QN}...; signs=positives(qnses)) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nGet the direct product of some AbelianNumberses.\n\nnote: Note\nPhysically, the direct product of a couple of AbelianNumberses are defined by the direct product of the bases of the Hilbert spaces they represent. Therefore, the dimension of the result equals the product of those of the inputs. Meanwhile, each quantum number in the contents of the result is obtained by a summation of the corresponding quanum numbers of the inputs with the correct signs. This is a direct consequence of the Abelian nature of our quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.pairs-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers, Symbol}","page":"Quantum numbers","title":"Base.pairs","text":"pairs(qns::AbelianNumbers, choice::Symbol)\npairs(qns::AbelianNumbers, ::Val{:indptr})\npairs(qns::AbelianNumbers, ::Val{:counts})\n\nIterate over the AbelianNumber=>slice or AbelianNumber=>count pairs.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.show-Tuple{IO, QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}","page":"Quantum numbers","title":"Base.show","text":"show(io::IO, qns::AbelianNumbers)\n\nShow an AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.sort-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}","page":"Quantum numbers","title":"Base.sort","text":"sort(qns::AbelianNumbers) -> Tuple{AbelianNumbers, Vector{Int}}\n\nSort the quantum numbers of an AbelianNumbers, return the sorted AbelianNumbers and the permutation array that sorts the expansion of the original AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.string-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}","page":"Quantum numbers","title":"Base.string","text":"string(qns::AbelianNumbers) -> String\n\nConvert an AbelianNumbers to string.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.union-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber, N} where N}","page":"Quantum numbers","title":"Base.union","text":"union(qns::AbelianNumber...; signs=positives(qns)) -> AbelianNumbers\nunion(qnses::AbelianNumbers{QN}...; signs=positives(qnses)) where {QN<:AbelianNumber} -> AbelianNumbers{QN}\n\nGet the direct sum of some AbelianNumbers or AbelianNumberses.\n\nnote: Note\nPhysically, the direct sum of a couple of AbelianNumbers or AbelianNumberses is defined by the direct sum of the bases of the Hilbert spaces they represent. Therefore, the dimension of the result equals the summation of those of the inputs. As a consequence, even for AbelianNumbers, the result will be an AbelianNumbers because the dimension of the result is greater than 1.\nSigns of AbelianNumbers or AbelianNumberses can be provided when getting their direct sums.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#Base.values-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers, Symbol}","page":"Quantum numbers","title":"Base.values","text":"values(qns::AbelianNumbers, choice::Symbol)\nvalues(qns::AbelianNumbers, ::Val{:indptr})\nvalues(qns::AbelianNumbers, ::Val{:counts})\n\nIterate over the slices/counts of the AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Interfaces.:⊕-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber, N} where N}","page":"Quantum numbers","title":"QuantumLattices.Interfaces.:⊕","text":"⊕(qns::AbelianNumber...) -> AbelianNumbers{qns|>eltype}\n⊕(qnses::AbelianNumbers...) -> qnses|>eltype\n\nGet the direct sum of some AbelianNumbers or AbelianNumberses.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Interfaces.:⊗-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber, N} where N}","page":"Quantum numbers","title":"QuantumLattices.Interfaces.:⊗","text":"⊗(qns::AbelianNumber...) -> eltype(qns)\n\nGet the direct product of some AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Interfaces.:⊗-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers, N} where N}","page":"Quantum numbers","title":"QuantumLattices.Interfaces.:⊗","text":"⊗(qnses::AbelianNumbers...) -> eltype(qnses)\n\nGet the direct product of some AbelianNumberses.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Interfaces.decompose-Union{Tuple{QN}, Tuple{QN, Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}, N} where N}} where QN<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.Interfaces.decompose","text":"decompose(target::QN, qnses::AbelianNumbers{QN}...; signs=positives(qnses), method=:montecarlo, nmax=20) where {QN<:AbelianNumber} -> Vector{NTuple{length(qnses), Int}}\n\nFind a couple of decompositions of target with respect to qnses.\n\nnote: Note\nA tuple of integers (i₁, i₂, ...) is called a decomposition of a given target with respect to the given qnses if and only if they satisfy the \"decomposition rule\":sum_textj textsignstextjtimestextqnsestextjtexti_textj==texttargetThis equation is in fact a set of restricted linear Diophantine equations. Indeed, our quantum numbers are always discrete Abelian ones and all instances of a concrete AbelianNumber forms a module over the ring of integers. Therefore, each quantum number can be represented as a integral multiple of the unit element of the Abelian module, which results in the final reduction of the above equation to a set of linear Diophantine equations. Then finding a decomposition is equivalent to find a solution of the reduced linear Diophantine equations, with the restriction that the quantum numbers constructed from the solution should be in the corresponding qnses. Here we provide two methods to find such decompositions, one is by brute force, and the other is by Monte Carlo simultatioins.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Interfaces.dimension-Tuple{Type{var\"#s11\"} where var\"#s11\"<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}","page":"Quantum numbers","title":"QuantumLattices.Interfaces.dimension","text":"dimension(::Type{<:AbelianNumber}) -> Int\ndimension(::AbelianNumber) -> Int\n\nThe dimension of the Hilbert space an AbelianNumber represents. Apparently, this is always 1.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Interfaces.expand-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers, Symbol}","page":"Quantum numbers","title":"QuantumLattices.Interfaces.expand","text":"expand(qns::AbelianNumbers, choice::Symbol)\nexpand(qns::AbelianNumbers, ::Val{:contents}) -> Vector{eltype(qns)}\nexpand(qns::AbelianNumbers, ::Val{:indices}) -> Vector{Int}\n\nExpand the contents or indices of an AbelianNumbers to the uncompressed form.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Interfaces.permute-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers, Vector{Int64}, Symbol}","page":"Quantum numbers","title":"QuantumLattices.Interfaces.permute","text":"permute(qns::AbelianNumbers, permutation::Vector{Int}, choice::Symbol) -> AbelianNumbers\npermute(qns::AbelianNumbers, permutation::Vector{Int}, ::Val{:compression}) -> AbelianNumbers\npermute(qns::AbelianNumbers, permutation::Vector{Int}, ::Val{:expansion}) -> AbelianNumbers\n\nReorder the quantum numbers contained in an AbelianNumbers with a permutation and return the new one.\n\nFor :compression case, the permutation is for the compressed contents of the original AbelianNumbers while for :expansion case, the permutation is for the expanded contents of the original AbelianNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.PQNS-Tuple{Real}","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.PQNS","text":"PQNS(N::Real) -> AbelianNumbers{PQN}\n\nConstruct the AbelianNumbers of the Hilbert space of a single-particle state with at most N identical particles.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.SPQNS-Tuple{Real}","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.SPQNS","text":"SPQNS(S::Real) -> AbelianNumbers{SPQN}\n\nConstruct the AbelianNumbers of the Hilbert space of a single site with internal degrees of freedom that can be ascribed to a spin S.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.SQNS-Tuple{Real}","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.SQNS","text":"SQNS(S::Real) -> AbelianNumbers{SQN}\n\nConstruct the AbelianNumbers of the Hilbert space of a signle spin S.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.periods","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.periods","text":"periods\n\nThe generic function that used to define the period of each component of a concrete AbelianNumber.\n\n\n\n\n\n","category":"function"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.positives-Union{Tuple{Tuple{Vararg{Any, N}}}, Tuple{N}} where N","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.positives","text":"positives(inputs::NTuple{N, Any}) where N -> NTuple{N, Int}\n\nRetun a tuple of all positive signs.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.regularize!-Union{Tuple{QN}, Tuple{Type{QN}, AbstractVector{var\"#s8\"} where var\"#s8\"<:Real}} where QN<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.regularize!","text":"regularize!(::Type{QN}, array::AbstractVector{<:Real}) where {QN<:AbelianNumber} -> typeof(array)\nregularize!(::Type{QN}, array::AbstractMatrix{<:Real}) where {QN<:AbelianNumber} -> typeof(array)\n\nRegularize the elements of an array in place so that it can represent quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.regularize-Union{Tuple{QN}, Tuple{Type{QN}, AbstractVecOrMat{var\"#s8\"} where var\"#s8\"<:Real}} where QN<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.regularize","text":"regularize(::Type{QN}, array::Union{AbstractVector{<:Real}, AbstractMatrix{<:Real}}) where {QN<:AbelianNumber} -> typeof(array)\n\nRegularize the elements of an array and return a copy that can represent quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.toordereddict-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers, Symbol}","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.toordereddict","text":"toordereddict(qns::AbelianNumbers, choice::Symbol)\ntoordereddict(qns::AbelianNumbers, ::Val{:indptr}) -> OrderedDict{qns|>eltype, UnitRange{Int}}\ntoordereddict(qns::AbelianNumbers, ::Val{:counts}) -> OrderedDict{qns|>eltype, Int}\n\nConvert an AbelianNumbers to an ordered dict.\n\n\n\n\n\n","category":"method"},{"location":"man/Mathematics/QuantumNumbers/#QuantumLattices.Mathematics.QuantumNumbers.ukron-Union{Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}, N} where N}, Tuple{QN}} where QN<:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber","page":"Quantum numbers","title":"QuantumLattices.Mathematics.QuantumNumbers.ukron","text":"ukron(qnses::AbelianNumbers{QN}...; signs=positives(qnses)) where {QN<:AbelianNumber} -> AbelianNumbers{QN}, Dict{QN, Dict{NTuple{length(qnses), QN}, UnitRange{Int}}}\n\nUnitary Kronecker product of several AbelianNumberses. The product result as well as the records of the product will be returned.\n\nnote: Note\nAll input AbelianNumbers must be 'U' formed or 'C' formed.\nSince duplicate quantum number are not allowed in 'U' formed and 'C' formed AbelianNumberses, in general, there exists a merge process of duplicate quantum numbers in the result. Therefore, records are needed to keep track of this process, which will be returned along with the product result. The records are stored in a Dict{QN, Dict{NTuple{NTuple{length(qnses), QN}, UnitRange{Int}}} typed dict, in which, for each unduplicate quantum number qn in the result, there exist a record Dict((qn₁, qn₂, ...)=>start:stop, ...) telling what quantum numbers (qn₁, qn₂, ...) a mereged duplicate qn comes from and what slice start:stop this merged duplicate corresponds in the result.\n\n\n\n\n\n","category":"method"}]
}
