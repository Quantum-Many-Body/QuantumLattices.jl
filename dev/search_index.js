var documenterSearchIndex = {"docs":
[{"location":"advanced topics/ManageProjects/#Manage-projects","page":"Manage projects","title":"Manage projects","text":"","category":"section"},{"location":"man/QuantumSystems/#Quantum-Systems","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"section"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.FockTerm","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.FockTerm","text":"FockTerm\n\nType alias for Union{Onsite, Hopping, Pairing, Hubbard, InterOrbitalInterSpin, InterOrbitalIntraSpin, SpinFlip, PairHopping, Coulomb}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.PhononTerm","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.PhononTerm","text":"PhononTerm\n\nType alias for Union{Kinetic, Hooke, Elastic}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.annihilation","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.annihilation","text":"annihilation\n\nIndicate that the nambu index is annihilation.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.block","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.block","text":"*(f‚ÇÅ::Operator{<:Number, <:OneAtLeast{FockIndex{:f}}}, f‚ÇÇ::Operator{<:Number, <:OneAtLeast{FockIndex{:f}}}) -> Operator\n*(f‚ÇÅ::Operator{<:Number, <:OneAtLeast{Index{<:FockIndex{:f}, Int}}}, f‚ÇÇ::Operator{<:Number, <:OneAtLeast{Index{<:FockIndex{:f}, Int}}}) -> Operator\n*(f‚ÇÅ::Operator{<:Number, <:OneAtLeast{CompositeIndex{<:Index{<:FockIndex{:f}, Int}}}}, f‚ÇÇ::Operator{<:Number, <:OneAtLeast{CompositeIndex{<:Index{<:FockIndex{:f}, Int}}}}) -> Operator\n\nGet the multiplication of two fermionic Fock operators.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.creation","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.creation","text":"creation\n\nIndicate that the nambu index is creation.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexofbosons","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexofbosons","text":"latexofbosons\n\nDefault LaTeX format of a bosonic index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexoffermions","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexoffermions","text":"latexoffermions\n\nDefault LaTeX format of a fermionic index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexofparticles","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexofparticles","text":"latexofparticles\n\nDefault LaTeX format of a wildcard Fock index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexofphonons","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexofphonons","text":"latexofphonons\n\nDefault LaTeX format of a phonon index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.latexofspins","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.latexofspins","text":"latexofspins\n\nDefault LaTeX format of a spin index.\n\n\n\n\n\n","category":"constant"},{"location":"man/QuantumSystems/#QuantumLattices.DegreesOfFreedom.MatrixCoupling-Tuple{Union{typeof(ùïì), typeof(ùïî), typeof(ùïï)}, Union{Colon, Tuple{Ordinal, Ordinal}}, Union{Colon, AbstractMatrix}, Union{Colon, AbstractMatrix}, Union{Colon, AbstractMatrix}}","page":"Quantum Systems","title":"QuantumLattices.DegreesOfFreedom.MatrixCoupling","text":"MatrixCoupling(F::Union{typeof(ùïî), typeof(ùïì), typeof(ùïï)}, sites::Union{NTuple{2, Ordinal}, Colon}, orbital::Union{AbstractMatrix, Colon}, spin::Union{AbstractMatrix, Colon}, nambu::Union{AbstractMatrix, Colon})\nMatrixCoupling(sites::Union{NTuple{2, Ordinal}, Colon}, ::Type{F}, orbital::Union{AbstractMatrix, Colon}, spin::Union{AbstractMatrix, Colon}, nambu::Union{AbstractMatrix, Colon}) where {F<:FockIndex}\n\nConstruct a matrix coupling for Fock systems.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.DegreesOfFreedom.MatrixCoupling-Tuple{typeof(ùï¶), Union{Colon, Tuple{Ordinal, Ordinal}}, AbstractMatrix}","page":"Quantum Systems","title":"QuantumLattices.DegreesOfFreedom.MatrixCoupling","text":"MatrixCoupling(::typeof(ùï¶), sites::Union{NTuple{2, Ordinal}, Colon}, matrix::AbstractMatrix; rows::Union{AbstractVector, Nothing}=nothing, cols::Union{AbstractVector, Nothing}=nothing)\nMatrixCoupling(sites::Union{NTuple{2, Ordinal}, Colon}, ::Type{PhononIndex{:u}}, matrix::AbstractMatrix; rows::Union{AbstractVector, Nothing}=nothing, cols::Union{AbstractVector, Nothing}=nothing)\n\nConstruct a set of Couplings corresponding to the dynamical matrix of phonons.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.DegreesOfFreedom.MatrixCoupling-Union{Tuple{S}, Tuple{Type{S}, Union{Colon, Tuple{Ordinal, Ordinal}}, AbstractMatrix}} where S<:ùïä","page":"Quantum Systems","title":"QuantumLattices.DegreesOfFreedom.MatrixCoupling","text":"MatrixCoupling(::Type{<:ùïä}, sites::Union{NTuple{2, Ordinal}, Colon}, matrix::AbstractMatrix; rows::AbstractVector=SVector('x', 'y', 'z'), cols::AbstractVector=SVector('x', 'y', 'z'))\nMatrixCoupling(sites::Union{NTuple{2, Ordinal}, Colon}, ::Type{<:SpinIndex}, matrix::AbstractMatrix; rows::AbstractVector=SVector('x', 'y', 'z'), cols::AbstractVector=SVector('x', 'y', 'z'))\n\nConstruct a matrix coupling for spin systems.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Coulomb","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Coulomb","text":"Coulomb(id::Symbol, value, bondkind, coupling=Coupling(ùïï(:, :, :, :), ùïï(:, :, :, :))^2; ishermitian::Bool=true, amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nCoulomb term.\n\nType alias for Term{:Coulomb, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.DM","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.DM","text":"DM(\n    id::Symbol,\n    value,\n    bondkind,\n    vectors::Pair{<:AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}}, <:Union{Char, AbstractVector{<:Number}}}...;\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing,\n    ismodulatable::Bool=true\n)\n\nDM term. Since DM term is antisymmetric on every bond, only the positive direction of a bond is needed. The negative direction of a bond can be handled automatically by this function.\n\nHere, vectors specify the unit DM vector on every bond in the form [bond‚ÇÅ, bond‚ÇÇ, ...]=>v, where bond·µ¢ can be\n\na Number specifying the azimuth angle of a bond in the 2-dimensional case, or\na Tuple{Number, Number} specifying the polar and azimuth angle pairs of a bond in the 3-dimensional case, or\nan AbstractVector{<:Number} specifying the direction of a bond;\n\nand v can be\n\na Char of 'x', 'y' or 'z', indicating the unit DM vector on the set of bonds is along the x, y or z direction, or\nan AbstractVector{<:Number}, specifying the direction of the DM vector on the set of bonds.\n\nType alias for Term{:DM, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Elastic","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Elastic","text":"Elastic(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nGeneric elastic energy of phonons.\n\nType alias for Term{:Elastic, id, V, B, C<:TermCoupling, A<:TermAmplitude}\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Fock","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Fock","text":"Fock{T} <: SimpleInternal{FockIndex{T, Int, Rational{Int}, Int}}\n\nFock space of Fock generators at a single point.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.FockIndex","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.FockIndex","text":"FockIndex{T, O<:Union{Int, Symbol, Colon}, S<:Union{Rational{Int}, Symbol, Colon}, N<:Union{Int, Symbol, Colon}} <: SimpleInternalIndex\n\nFock index, i.e., the internal index to specify the generators of a Fock space.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.FockIndex-Tuple{Union{Colon, Int64, Symbol}, Union{Colon, Rational{Int64}, Int64, Symbol}, Union{Colon, Int64, Symbol}}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.FockIndex","text":"FockIndex(orbital::Union{Int, Symbol, Colon}, spin::Union{Rational{Int}, Int, Symbol, Colon}, nambu::Union{Int, Symbol, Colon})\nFockIndex{T}(orbital::Union{Int, Symbol, Colon}, spin::Union{Rational{Int}, Int, Symbol, Colon}, nambu::Union{Int, Symbol, Colon}) where T\nFockIndex{T, O, S, N}(orbital::Union{Int, Symbol, Colon}, spin::Union{Rational{Int}, Symbol, Colon}, nambu::Union{Int, Symbol, Colon}) where {T, O, S, N}\n\nConstruct a Fock index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Heisenberg","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Heisenberg","text":"Heisenberg(id::Symbol, value, bondkind; form::Symbol=Symbol(\"+-z\"), amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nHeisenberg term.\n\nType alias for Term{:Heisenberg, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Hooke","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Hooke","text":"Hooke(id::Symbol, value, bondkind; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nPotential energy of phonons by the Hooke's law.\n\nType alias for Term{:Hooke, id, V, B, C<:TermCoupling, A<:TermAmplitude}\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Hopping","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Hopping","text":"Hopping(id::Symbol, value, bondkind, coupling=Coupling(ùïï(:, :, :, :), ùïï(:, :, :, :)); amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nHopping term.\n\nType alias for Term{:Hopping, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Hubbard","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Hubbard","text":"Hubbard(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nHubbard term.\n\nType alias for Term{:Hubbard, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.InterOrbitalInterSpin","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.InterOrbitalInterSpin","text":"InterOrbitalInterSpin(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nInterorbital-interspin term.\n\nType alias for Term{:InterOrbitalInterSpin, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.InterOrbitalIntraSpin","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.InterOrbitalIntraSpin","text":"InterOrbitalIntraSpin(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nInterorbital-intraspin term.\n\nType alias for Term{:InterOrbitalIntraSpin, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Ising","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Ising","text":"Ising(id::Symbol, value, bondkind, direction::Char; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nIsing term.\n\nType alias for Term{:Ising, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Kinetic","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Kinetic","text":"Kinetic(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nKinetic energy of phonons.\n\nType alias for Term{:Kinetic, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Kitaev","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Kitaev","text":"Kitaev(\n    id::Symbol, value, bondkind;\n    x::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    y::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    z::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing,\n    ismodulatable::Bool=true\n)\n\nKitaev term. Since Kitaev term is symmetric on every bond, only one direction of a bond is needed. The inverse direction of a bond can be handled automatically by this function.\n\nHere, x, y and z assign the x-bonds, y-bonds, and z-bonds, respectively, with each kind of bond can be\n\na Number specifying the azimuth angle of a bond in the 2-dimensional case, or\na Tuple{Number, Number} specifying the polar and azimuth angle pairs of a bond in the 3-dimensional case, or\nan AbstractVector{<:Number} specifying the direction of a bond.\n\nType alias for Term{:Kitaev, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Onsite","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Onsite","text":"Onsite(id::Symbol, value, coupling=Coupling(ùïï(:, :, :, :), ùïï(:, :, :, :)); ishermitian::Bool=true, amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nOnsite term.\n\nType alias for Term{:Onsite, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.PairHopping","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.PairHopping","text":"PairHopping(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nPair-hopping term.\n\nType alias for Term{:PairHopping, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Pairing","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Pairing","text":"Pairing(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nPairing term.\n\nType alias for Term{:Pairing, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Phonon","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Phonon","text":"Phonon{K} <: SimpleInternal{PhononIndex{K, Char}}\n\nPhonon space of lattice vibration generators at a single point.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Phonon-Tuple{Integer}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Phonon","text":"Phonon(ndirection::Integer)\nPhonon{K}(ndirection::Integer) where K\n\nConstruct a phonon space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.PhononIndex","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.PhononIndex","text":"PhononIndex{K, D<:Union{Char, Symbol, Colon}} <: SimpleInternalIndex\n\nPhonon index, i.e., the internal index to specify the generators of the vibration of a lattice point.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.PhononIndex-Union{Tuple{Union{Colon, Char, Symbol}}, Tuple{D}, Tuple{K}} where {K, D}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.PhononIndex","text":"PhononIndex{K}(direction::Union{Char, Symbol, Colon}) where K\nPhononIndex{K, D}(direction::Union{Char, Symbol, Colon}) where {K, D}\n\nConstruct a phonon index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.SingleIonAnisotropy","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.SingleIonAnisotropy","text":"SingleIonAnisotropy(id::Symbol, value, direction::Char; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\nSingleIonAnisotropy(id::Symbol, value, matrix::AbstractMatrix{<:Number}; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nSingle ion anisotropy term.\n\nType alias for Term{:SingleIonAnisotropy, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Spin","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Spin","text":"Spin{S} <: SimpleInternal{SpinIndex{S, Char}}\n\nSpin space of spin generators at a single point.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.SpinFlip","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.SpinFlip","text":"SpinFlip(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nSpin-flip term.\n\nType alias for Term{:SpinFlip, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.SpinIndex","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.SpinIndex","text":"SpinIndex{S, T<:Union{Char, Symbol, Colon}} <: SimpleInternalIndex\n\nSpin index, i.e., the internal index to specify the generators of a spin space.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.SpinIndex-Tuple{Union{Colon, Char, Symbol}}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.SpinIndex","text":"SpinIndex(tag::Union{Char, Symbol, Colon})\nSpinIndex{S}(tag::Union{Char, Symbol, Colon}) where S\nSpinIndex{S, T}(tag::Union{Char, Symbol, Colon}) where {S, T}\n\nConstruct a spin index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.SpinTerm","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.SpinTerm","text":"SpinTerm(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true)\n\nGeneric spin term.\n\nType alias for Term{:SpinTerm, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Zeeman","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Zeeman","text":"Zeeman(\n    id::Symbol, value, direction::Char, g::Number=1;\n    amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true\n)\nZeeman(\n    id::Symbol, value, direction::Union{AbstractVector{<:Number}, Tuple{Number, Number}}, g::Union{Number, AbstractMatrix{<:Number}}=1;\n    unit::Symbol=:degree, amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true\n)\n\nZeeman term.\n\nType alias for Term{:Zeeman, id, V, Int, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Œì","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Œì","text":"Œì(\n    id::Symbol, value, bondkind;\n    x::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    y::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    z::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing,\n    ismodulatable::Bool=true\n)\n\nŒì Term. Since Œì term is symmetric on every bond, only one direction of a bond is needed. The inverse direction of a bond can be handled automatically by this function.\n\nHere, x, y and z assign the x-bonds, y-bonds, and z-bonds, respectively, with each kind of bond can be\n\na Number specifying the azimuth angle of a bond in the 2-dimensional case, or\na Tuple{Number, Number} specifying the polar and azimuth angle pairs of a bond in the 3-dimensional case, or\nan AbstractVector{<:Number} specifying the direction of a bond.\n\nType alias for Term{:Œì, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.Œì‚Ä≤","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.Œì‚Ä≤","text":"Œì‚Ä≤(\n    id::Symbol, value, bondkind;\n    x::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    y::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    z::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing,\n    ismodulatable::Bool=true\n)\n\nŒì‚Ä≤ Term. Since Œì‚Ä≤ term is symmetric on every bond, only one direction of a bond is needed. The inverse direction of a bond can be handled automatically by this function.\n\nHere, x, y and z assign the x-bonds, y-bonds, and z-bonds, respectively, with each bond can be\n\na Number specifying the azimuth angle of a bond in the 2-dimensional case, or\na Tuple{Number, Number} specifying the polar and azimuth angle pairs of a bond in the 3-dimensional case, or\nan AbstractVector{<:Number} specifying the direction of a bond.\n\nType alias for Term{:Œì‚Ä≤, id, V, B, C<:TermCoupling, A<:TermAmplitude}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïä","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïä","text":"ùïä(tag) -> SpinIndex\nùïä(site, tag) -> Index{<:SpinIndex}\nùïä(site, tag, rcoordinate, icoordinate) -> CoordinatedIndex{<:Index{<:SpinIndex}}\n\nùïä{S}(tag) where S -> SpinIndex{S}\nùïä{S}(site, tag) where S -> Index{<:SpinIndex{S}}\nùïä{S}(site, tag, rcoordinate, icoordinate) where S -> CoordinatedIndex{<:Index{<:SpinIndex{S}}}\n\nConvenient construction of SpinIndex, Index{<:SpinIndex}, CoordinatedIndex{<:Index{<:SpinIndex}}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@DM_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@DM_str","text":"DM\"x\" => SparseMatrixCSC([0 0 0; 0 0 1; 0 -1 0])\nDM\"y\" => SparseMatrixCSC([0 0 -1; 0 0 0; 1 0 0])\nDM\"z\" => SparseMatrixCSC([0 1 0; -1 0 0; 0 0 0])\n\nDM coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@Heisenberg_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@Heisenberg_str","text":"Heisenberg\"\" => SparseMatrixCSC([1 0 0; 0 1 0; 0 0 1])\n\nHeisenberg coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@Ising_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@Ising_str","text":"Ising\"x\" => SparseMatrixCSC([1 0 0; 0 0 0; 0 0 0])\nIsing\"y\" => SparseMatrixCSC([0 0 0; 0 1 0; 0 0 0])\nIsing\"z\" => SparseMatrixCSC([0 0 0; 0 0 0; 0 0 1])\n\nIsing coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@L_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@L_str","text":"L\"x\" => SparseMatrixCSC([0 0 0; 0 0 1im; 0 -1im 0])\nL\"y\" => SparseMatrixCSC([0 0 -1im; 0 0 0; 1im 0 0])\nL\"z\" => SparseMatrixCSC([0 1im 0; -1im 0 0; 0 0 0])\n\nThree-dimensional rotation generators.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@Œì_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@Œì_str","text":"Œì\"x\" => SparseMatrixCSC([0 0 0; 0 0 1; 0 1 0])\nŒì\"y\" => SparseMatrixCSC([0 0 1; 0 0 0; 1 0 0])\nŒì\"z\" => SparseMatrixCSC([0 1 0; 1 0 0; 0 0 0])\n\nŒì coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@Œì‚Ä≤_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@Œì‚Ä≤_str","text":"Œì‚Ä≤\"x\" => SparseMatrixCSC([0 1 1; 1 0 0; 1 0 0])\nŒì‚Ä≤\"y\" => SparseMatrixCSC([0 1 0; 1 0 1; 0 1 0])\nŒì‚Ä≤\"z\" => SparseMatrixCSC([0 0 1; 0 0 1; 1 1 0])\n\nŒì‚Ä≤ coupling matrix.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.@œÉ_str-Tuple{String}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.@œÉ_str","text":"œÉ\"0\" => SparseMatrixCSC([1 0; 0 1])\nœÉ\"x\" => SparseMatrixCSC([0 1; 1 0])\nœÉ\"y\" => SparseMatrixCSC([0 -1im; 1im 0])\nœÉ\"z\" => SparseMatrixCSC([1 0; 0 -1])\nœÉ\"+\" => SparseMatrixCSC([0 1; 0 0])\nœÉ\"-\" => SparseMatrixCSC([0 0; 1 0])\nœÉ\"11\" => SparseMatrixCSC([1 0; 0 0])\nœÉ\"22\" => SparseMatrixCSC([0 0; 0 1])\n\nPauli matrix œÉ‚Å∞, œÉÀ£, œÉ ∏, œÉ·∂ª, œÉ‚Å∫, œÉ‚Åª, œÉ¬π¬π, œÉ¬≤¬≤.\n\n\n\n\n\n","category":"macro"},{"location":"man/QuantumSystems/#Base.angle-Tuple{CoordinatedIndex{<:Index{<:FockIndex}}, AbstractVector{<:AbstractVector{<:Number}}, AbstractVector{<:Number}}","page":"Quantum Systems","title":"Base.angle","text":"angle(id::CoordinatedIndex{<:Index{<:FockIndex}}, vectors::AbstractVector{<:AbstractVector{<:Number}}, values::AbstractVector{<:Number}) -> Complex{<:Number}\n\nGet the twist phase.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.DegreesOfFreedom.patternrule-Union{Tuple{N}, Tuple{NTuple{N, Colon}, Val, Type{<:FockIndex}, Val{:nambu}}} where N","page":"Quantum Systems","title":"QuantumLattices.DegreesOfFreedom.patternrule","text":"patternrule(nambus::NTuple{N, Colon}, ::Val{}, ::Type{<:FockIndex}, ::Val{:nambu}) where N -> NTuple{N, Int}\n\nDefault pattern rule for the :nambu attribute of Fock indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.matrix-Union{Tuple{Union{SpinIndex{S, Char}, CompositeIndex{<:Index{SpinIndex{S, Char}}}, Index{SpinIndex{S, Char}}}}, Tuple{S}, Tuple{Union{SpinIndex{S, Char}, CompositeIndex{<:Index{SpinIndex{S, Char}}}, Index{SpinIndex{S, Char}}}, Type{<:Number}}} where S","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(index::Union{SpinIndex{S, Char}, Index{SpinIndex{S, Char}}, CompositeIndex{<:Index{SpinIndex{S, Char}}}}, dtype::Type{<:Number}=ComplexF64) where S -> Matrix{dtype}\n\nGet the matrix representation of an index acting on the local spin space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.script-Tuple{FockIndex, Val{:orbital}}","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.script","text":"script(index::FockIndex, ::Val{:orbital}; kwargs...) -> String\nscript(index::FockIndex, ::Val{:spin}; kwargs...) -> String\nscript(index::FockIndex, ::Val{:spinsym}; kwargs...) -> String\nscript(index::FockIndex, ::Val{:nambu}; kwargs...) -> String\n\nGet the requested script of a Fock index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.script-Union{Tuple{K}, Tuple{PhononIndex{K, Colon}, Val{:direction}}} where K","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.script","text":"script(index::PhononIndex, ::Val{:direction}; kwargs...) -> String\n\nGet the requested script of a phonon index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumOperators.script-Union{Tuple{S}, Tuple{SpinIndex{S, Colon}, Val{:tag}}} where S","page":"Quantum Systems","title":"QuantumLattices.QuantumOperators.script","text":"script(index::SpinIndex, ::Val{:tag}; kwargs...) -> String\n\nGet the requested script of a spin index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.isannihilation-Tuple{FockIndex}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.isannihilation","text":"isannihilation(index::FockIndex) -> Bool\nisannihilation(index::Index) -> Bool\nisannihilation(index::CompositeIndex) -> Bool\n\nJudge whether the nambu index is annihilation.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.iscreation-Tuple{FockIndex}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.iscreation","text":"iscreation(index::FockIndex) -> Bool\niscreation(index::Index) -> Bool\niscreation(index::CompositeIndex) -> Bool\n\nJudge whether the nambu index is creation.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.isnormalordered-Tuple{Operator{<:Number, <:NTuple{N, Union{CompositeIndex{<:Index{<:FockIndex}}, Index{<:FockIndex}, FockIndex}} where N}}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.isnormalordered","text":"isnormalordered(opt::Operator{<:Number, <:ID{Union{CompositeIndex{<:Index{<:FockIndex}}, Index{<:FockIndex}, FockIndex}}}) -> Bool\n\nJudge whether an operator is normal ordered.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.totalspin-Tuple{SpinIndex}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.totalspin","text":"totalspin(::SpinIndex) -> Rational{Int}/Int/Colon\ntotalspin(::Type{<:SpinIndex}) -> Rational{Int}/Int/Colon/Float64\n\ntotalspin(::Index{<:SpinIndex}) -> Rational{Int}/Int/Colon\ntotalspin(::Type{<:Index{<:SpinIndex}}) -> Rational{Int}/Int/Colon/Float64\n\ntotalspin(::CompositeIndex{<:Index{<:SpinIndex}}) -> Rational{Int}/Int/Colon\ntotalspin(::Type{<:CompositeIndex{<:Index{<:SpinIndex}}}) -> Rational{Int}/Int/Colon/Float64\n\nGet the total spin.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.totalspin-Tuple{Spin}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.totalspin","text":"totalspin(::Spin) -> Rational{Int}/Int/Colon\ntotalspin(::Type{<:Spin}) -> Rational{Int}/Int/Colon\n\nGet the total spin.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïä·µÄùïä-Tuple{Union{Colon, Tuple{Ordinal, Ordinal}}, AbstractMatrix}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïä·µÄùïä","text":"ùïä·µÄùïä(sites::Union{NTuple{2, Ordinal}, Colon}, matrix::AbstractMatrix; rows::AbstractVector=SVector('x', 'y', 'z'), cols::AbstractVector=SVector('x', 'y', 'z')) -> MatrixCoupling\n\nConstruct a matrix coupling for spin system.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïí","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïí","text":"ùïí(orbital, spin, nambu) -> FockIndex{:b}\nùïí(site, orbital, spin, nambu) -> Index{<:FockIndex{:b}}\nùïí(site, orbital, spin, nambu, rcoordinate, icoordinate) -> CoordinatedIndex{<:Index{<:FockIndex{:b}}}\n\nConvenient construction of FockIndex{:b}, Index{<:FockIndex{:b}}, CoordinatedIndex{<:Index{<:FockIndex{:b}}}.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïì","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïì","text":"ùïì(orbital, spin, nambu) -> FockIndex{:b}\nùïì(site, orbital, spin, nambu) -> Index{<:FockIndex{:b}}\nùïì(site, orbital, spin, nambu, rcoordinate, icoordinate) -> CoordinatedIndex{<:Index{<:FockIndex{:b}}}\n\nConvenient construction of FockIndex{:b}, Index{<:FockIndex{:b}}, CoordinatedIndex{<:Index{<:FockIndex{:b}}}.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïî","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïî","text":"ùïî(orbital, spin, nambu) -> FockIndex{:f}\nùïî(site, orbital, spin, nambu) -> Index{<:FockIndex{:f}}\nùïî(site, orbital, spin, nambu, rcoordinate, icoordinate) -> CoordinatedIndex{<:Index{<:FockIndex{:f}}}\n\nConvenient construction of FockIndex{:f}, Index{<:FockIndex{:f}}, CoordinatedIndex{<:Index{<:FockIndex{f}}}.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïî‚Å∫ùïî-Tuple{Union{Colon, Tuple{Ordinal, Ordinal}}, Union{Colon, AbstractMatrix}, Union{Colon, AbstractMatrix}, Union{Colon, AbstractMatrix}}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïî‚Å∫ùïî","text":"ùïî‚Å∫ùïî(sites::Union{NTuple{2, Ordinal}, Colon}, orbital::Union{AbstractMatrix, Colon}, spin::Union{AbstractMatrix, Colon}, nambu::Union{AbstractMatrix, Colon}) -> MatrixCoupling\nùïì‚Å∫ùïì(sites::Union{NTuple{2, Ordinal}, Colon}, orbital::Union{AbstractMatrix, Colon}, spin::Union{AbstractMatrix, Colon}, nambu::Union{AbstractMatrix, Colon}) -> MatrixCoupling\nùïï‚Å∫ùïï(sites::Union{NTuple{2, Ordinal}, Colon}, orbital::Union{AbstractMatrix, Colon}, spin::Union{AbstractMatrix, Colon}, nambu::Union{AbstractMatrix, Colon}) -> MatrixCoupling\n\nConstruct a matrix coupling for Fock systems.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïï","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïï","text":"ùïï(orbital, spin, nambu) -> FockIndex{:}\nùïï(site, orbital, spin, nambu) -> Index{<:FockIndex{:}}\nùïï(site, orbital, spin, nambu, rcoordinate, icoordinate) -> CoordinatedIndex{<:Index{<:FockIndex{:}}}\n\nConvenient construction of FockIndex{:}, Index{<:FockIndex{:}}, CoordinatedIndex{<:Index{<:FockIndex{:}}}.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïó","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïó","text":"ùïó(orbital, spin, nambu) -> FockIndex{:f}\nùïó(site, orbital, spin, nambu) -> Index{<:FockIndex{:f}}\nùïó(site, orbital, spin, nambu, rcoordinate, icoordinate) -> CoordinatedIndex{<:Index{<:FockIndex{:f}}}\n\nConvenient construction of FockIndex{:f}, Index{<:FockIndex{:f}}, CoordinatedIndex{<:Index{<:FockIndex{f}}}.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùïó‚Å∫ùïó","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùïó‚Å∫ùïó","text":"ùïó‚Å∫ùïó(sites::Union{NTuple{2, Ordinal}, Colon}, orbital::Union{AbstractMatrix, Colon}, spin::Union{AbstractMatrix, Colon}, nambu::Union{AbstractMatrix, Colon}) -> MatrixCoupling\nùïí‚Å∫ùïí(sites::Union{NTuple{2, Ordinal}, Colon}, orbital::Union{AbstractMatrix, Colon}, spin::Union{AbstractMatrix, Colon}, nambu::Union{AbstractMatrix, Colon}) -> MatrixCoupling\n\nConstruct a matrix coupling for Fock systems.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùï°-Tuple{Any}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùï°","text":"ùï°(direction) -> PhononIndex{:p}\nùï°(site, direction) -> Index{<:PhononIndex{:p}}\nùï°(site, direction, rcoordinate, icoordinate) -> CoordinatedIndex{<:Index{<:PhononIndex{:p}}}\n\nConvenient construction of SpinIndex{:p}, Index{<:SpinIndex{:p}}, CoordinatedIndex{<:Index{<:SpinIndex{:p}}}.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùï¶-Tuple{Any}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùï¶","text":"ùï¶(direction) -> PhononIndex{:u}\nùï¶(site, direction) -> Index{<:PhononIndex{:u}}\nùï¶(site, direction, rcoordinate, icoordinate) -> CoordinatedIndex{<:Index{<:PhononIndex{:u}}}\n\nConvenient construction of SpinIndex{:u}, Index{<:SpinIndex{:u}}, CoordinatedIndex{<:Index{<:SpinIndex{:u}}}.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.QuantumSystems.ùï¶·µÄùï¶-Tuple{Union{Colon, Tuple{Ordinal, Ordinal}}, AbstractMatrix}","page":"Quantum Systems","title":"QuantumLattices.QuantumSystems.ùï¶·µÄùï¶","text":"ùï¶·µÄùï¶(sites::Union{NTuple{2, Ordinal}, Colon}, matrix::AbstractMatrix; rows::Union{AbstractVector, Nothing}=nothing, cols::Union{AbstractVector, Nothing}=nothing) -> MatrixCoupling\n\nConstruct a set of Couplings corresponding to the dynamical matrix of phonons.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.expand-Tuple{Coupling{<:Number, <:Pattern{<:InternalPattern{var\"#s116\", P, N} where {var\"#s116\"<:Tuple{PhononIndex{:u}, PhononIndex{:u}}, P, N}}}, Val{:Hooke}, Bond, Hilbert}","page":"Quantum Systems","title":"QuantumLattices.expand","text":"expand(pnc::Coupling{<:Number, <:Pattern{<:InternalPattern{<:NTuple{2, PhononIndex{:u}}}}}, ::Val{:Hooke}, bond::Bond, hilbert::Hilbert) -> VectorSpace\n\nExpand the default phonon potential coupling on a given bond.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.kind-Tuple{PhononIndex}","page":"Quantum Systems","title":"QuantumLattices.kind","text":"kind(index::PhononIndex) -> Symbol\nkind(::Type{<:PhononIndex{K}}) where K -> Symbol\n\nkind(index::Index{<:PhononIndex}) -> Symbol\nkind(::Type{<:Index{<:PhononIndex{K}}}) where K -> Symbol\n\nkind(index::CoordinatedIndex{<:Index{<:PhononIndex}}) -> Symbol\nkind(::Type{<:CoordinatedIndex{<:Index{<:PhononIndex{K}}}}) where K -> Symbol\n\nGet the kind of a phonon index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.kind-Tuple{Phonon}","page":"Quantum Systems","title":"QuantumLattices.kind","text":"kind(pn::Phonon)\nkind(::Type{<:Phonon{K}}) where K\n\nGet the kind of a phonon space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.permute-Tuple{FockIndex{:f}, FockIndex{:f}}","page":"Quantum Systems","title":"QuantumLattices.permute","text":"permute(id‚ÇÅ::FockIndex, id‚ÇÇ::FockIndex) -> Tuple{Vararg{Operator}}\n\nPermute two Fock indexes and get the result.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.permute-Tuple{PhononIndex, PhononIndex}","page":"Quantum Systems","title":"QuantumLattices.permute","text":"permute(id‚ÇÅ::PhononIndex, id‚ÇÇ::PhononIndex) -> Tuple{Vararg{Operator}}\n\nPermute two phonon indexes and get the result.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumSystems/#QuantumLattices.permute-Tuple{SpinIndex, SpinIndex}","page":"Quantum Systems","title":"QuantumLattices.permute","text":"permute(id‚ÇÅ::SpinIndex, id‚ÇÇ::SpinIndex) -> Tuple{Vararg{Operator}}\n\nPermute two spin indexes and get the result.\n\n\n\n\n\n","category":"method"},{"location":"advanced topics/Transformations/#Transformations","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"man/Frameworks/#Frameworks","page":"Frameworks","title":"Frameworks","text":"","category":"section"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.eager","page":"Frameworks","title":"QuantumLattices.Frameworks.eager","text":"const eager = Eager()\n\nSingleton instance of Eager.\n\n\n\n\n\n","category":"constant"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.lazy","page":"Frameworks","title":"QuantumLattices.Frameworks.lazy","text":"const lazy = Lazy()\n\nSingleton instance of Lazy.\n\n\n\n\n\n","category":"constant"},{"location":"man/Frameworks/#Core.Tuple-Tuple{Data}","page":"Frameworks","title":"Core.Tuple","text":"Tuple(data::Data)\n\nConvert Data to Tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Action","page":"Frameworks","title":"QuantumLattices.Frameworks.Action","text":"Action\n\nAbstract type for all actions.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"(alg::Algorithm)(assign::Assignment, checkoptions::Bool=true; options...) -> Assignment\n(assign::Assignment)(alg::Algorithm, checkoptions::Bool=true; options...) -> Assignment\n\nRun an assignment based on an algorithm.\n\nThe difference between these two methods is that the first uses the parameters of assign as the current parameters while the second uses those of alg.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm-2","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"Algorithm(name::Symbol, frontend::Frontend, parameters::Parameters=Parameters(frontend), map::Function=identity; dir::String=\".\", timer::TimerOutput=TimerOutput())\n\nConstruct an algorithm.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm-3","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"Algorithm{F<:Frontend, P<:Parameters, M<:Function} <: Function\n\nAn algorithm associated with an frontend.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Algorithm-Tuple{Symbol, Action, Tuple{Vararg{Assignment}}}","page":"Frameworks","title":"QuantumLattices.Frameworks.Algorithm","text":"(alg::Algorithm)(name::Symbol, action::Action, dependencies::Tuple{Vararg{Assignment}}; delay::Bool=false, dir::String=alg.dir, options...) -> Assignment\n(alg::Algorithm)(name::Symbol, action::Action, parameters::Parameters, dependencies::Tuple{Vararg{Assignment}}; delay::Bool=false, dir::String=alg.dir, options...) -> Assignment\n(alg::Algorithm)(name::Symbol, action::Action, parameters::Parameters=Parameters(), map::Function=identity, dependencies::Tuple{Vararg{Assignment}}=(); delay::Bool=false, dir::String=alg.dir, options...) -> Assignment\n\nAdd an assignment on a algorithm by providing the contents of the assignment, and run this assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Assignment","page":"Frameworks","title":"QuantumLattices.Frameworks.Assignment","text":"Assignment{A<:Action, P<:Parameters, M<:Function, N, D<:Data} <: Function\n\nAn assignment associated with an action.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.CategorizedGenerator","page":"Frameworks","title":"QuantumLattices.Frameworks.CategorizedGenerator","text":"CategorizedGenerator{V, C, A<:NamedTuple, B<:NamedTuple, P<:Parameters, D<:Boundary, S<:ExpansionStyle} <: Generator{V}\n\nCategorized generator that groups the (representations of) quantum operators in a quantum lattice system into three categories, i.e., the constant, the alterable, and the boundary.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Data","page":"Frameworks","title":"QuantumLattices.Frameworks.Data","text":"Data\n\nAbstract type for the data of an action.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Eager","page":"Frameworks","title":"QuantumLattices.Frameworks.Eager","text":"Eager <: ExpansionStyle\n\nEager expansion style with eager computation so that similar terms are combined in the final result.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.ExpansionStyle","page":"Frameworks","title":"QuantumLattices.Frameworks.ExpansionStyle","text":"ExpansionStyle\n\nExpansion style of a generator of (representations of) quantum operators. It has two singleton subtypes, Eager and Lazy.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Formula","page":"Frameworks","title":"QuantumLattices.Frameworks.Formula","text":"Formula{V, F<:Function, P<:Parameters}\n\nRepresentation of a quantum lattice system with an explicit analytical formula.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Formula-Tuple","page":"Frameworks","title":"QuantumLattices.Frameworks.Formula","text":"(formula::Formula)(args...; kwargs...) -> valtype(formula)\n\nGet the result of a Formula.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Frontend","page":"Frameworks","title":"QuantumLattices.Frameworks.Frontend","text":"Frontend\n\nFrontend of algorithms applied to a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Generator","page":"Frameworks","title":"QuantumLattices.Frameworks.Generator","text":"Generator{V}\n\nGenerator of (representations of) quantum operators in a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Generator-Tuple{Any, NamedTuple, NamedTuple, NamedTuple{Names, T} where {Names, T<:Tuple{Vararg{Number}}}, Boundary, ExpansionStyle}","page":"Frameworks","title":"QuantumLattices.Frameworks.Generator","text":"Generator(constops, alterops::NamedTuple, boundops::NamedTuple, parameters::Parameters, boundary::Boundary, style::ExpansionStyle) -> CategorizedGenerator\n\nConstruct a CategorizedGenerator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Generator-Tuple{CategorizedGenerator{<:Operators}, Vector{<:Bond}, Hilbert, Union{Tuple{Term, Vararg{Term, N}} where N, Term}, Bool}","page":"Frameworks","title":"QuantumLattices.Frameworks.Generator","text":"Generator(operators::CategorizedGenerator{<:Operators}, bonds::Vector{<:Bond}, hilbert::Hilbert, terms::OneOrMore{Term}, half::Bool) -> OperatorGenerator\nGenerator(bonds::Vector{<:Bond}, hilbert::Hilbert, terms::OneOrMore{Term}, boundary::Boundary=plain, style::ExpansionStyle=eager; half::Bool=false) -> OperatorGenerator\n\nConstruct an OperatorGenerator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Lazy","page":"Frameworks","title":"QuantumLattices.Frameworks.Lazy","text":"Lazy <: ExpansionStyle\n\nLazy expansion style with lazy computation so that similar terms are not combined in the final result.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.OperatorGenerator","page":"Frameworks","title":"QuantumLattices.Frameworks.OperatorGenerator","text":"OperatorGenerator(bonds::Vector{<:Bond}, hilbert::Hilbert, terms::OneOrMore{Term}, boundary::Boundary=plain, style::ExpansionStyle=eager; half::Bool=false)\n\nConstruct a generator of quantum operators based on the input bonds, Hilbert space, terms and (twisted) boundary condition.\n\nWhen the boundary condition is plain, the boundary operators will be set to be empty for simplicity and efficiency.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.OperatorGenerator-2","page":"Frameworks","title":"QuantumLattices.Frameworks.OperatorGenerator","text":"OperatorGenerator{V<:Operators, CG<:CategorizedGenerator{V}, B<:Bond, H<:Hilbert, TS<:Tuple{Vararg{Term}}} <: Generator{V}\n\nA generator of operators based on the terms, bonds and Hilbert space of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters{Names}(values::Number...) where Names\n\nA NamedTuple that contains the key-value pairs.\n\n\n\n\n\n","category":"type"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{Algorithm}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(algorithm::Algorithm)\n\nGet the parameters of an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{Assignment}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(assignment::Assignment) -> Parameters\n\nGet the parameters of an assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{Boundary}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(bound::Boundary)\n\nGet the parameters of the twisted boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{CategorizedGenerator}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(cat::CategorizedGenerator)\n\nGet the complete set of parameters of a categorized generator of (representations of) quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{Formula}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(formula::Formula) -> Parameters\n\nGet the parameters of a Formula.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{OperatorGenerator}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(gen::OperatorGenerator) -> Parameters\n\nGet the parameters of an OperatorGenerator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.Parameters-Tuple{OperatorSet}","page":"Frameworks","title":"QuantumLattices.Frameworks.Parameters","text":"Parameters(ops::OperatorSet) -> NamedTuple{(), Tuple{}}\n\nGet the parameters of an OperatorSet, which is defined to be an empty NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.QuantumOperators.LinearTransformation-Tuple{CategorizedGenerator}","page":"Frameworks","title":"QuantumLattices.QuantumOperators.LinearTransformation","text":"(transformation::LinearTransformation)(cat::CategorizedGenerator; kwargs...) -> CategorizedGenerator\n\nApply a linear transformation to a categorized generator of (representations of) quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.QuantumOperators.Transformation-Tuple{OperatorGenerator}","page":"Frameworks","title":"QuantumLattices.QuantumOperators.Transformation","text":"(transformation::Transformation)(gen::OperatorGenerator; kwargs...) -> CategorizedGenerator\n\nGet the transformation applied to a generator of quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.:*-Tuple{CategorizedGenerator, Number}","page":"Frameworks","title":"Base.:*","text":"*(cat::CategorizedGenerator, factor::Number) -> CategorizedGenerator\n*(factor::Number, cat::CategorizedGenerator) -> CategorizedGenerator\n\nMultiply a categorized generator of (representations of) quantum operators with a factor.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.:+-Tuple{CategorizedGenerator, CategorizedGenerator}","page":"Frameworks","title":"Base.:+","text":"+(cat‚ÇÅ::CategorizedGenerator, cat‚ÇÇ::CategorizedGenerator) -> CategorizedGenerator\n\nAddition of two categorized generators of (representations of) quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.Filesystem.basename-Tuple{Union{Algorithm, Assignment}}","page":"Frameworks","title":"Base.Filesystem.basename","text":"basename(obj::Union{Assignment, Algorithm}; prefix::String=\"\", suffix::String=\"\", extension::String=\"qld\") -> String\n\nGet the basename of the data file of an assignment/algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.Filesystem.dirname-Tuple{Union{Algorithm, Assignment}}","page":"Frameworks","title":"Base.Filesystem.dirname","text":"dirname(obj::Union{Assignment, Algorithm}) -> String\n\nGet the dirname of the data file of an assignment/algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.eltype-Tuple{Generator}","page":"Frameworks","title":"Base.eltype","text":"eltype(gen::Generator)\neltype(::Type{T}) where {T<:Generator}\n\nGet the eltype of a Generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.empty-Tuple{CategorizedGenerator}","page":"Frameworks","title":"Base.empty","text":"empty(cat::CategorizedGenerator) -> CategorizedGenerator\nempty!(cat::CategorizedGenerator) -> CategorizedGenerator\n\nGet an empty copy of a categorized generator or empty a categorized generator of (representations of) quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.empty-Tuple{OperatorGenerator}","page":"Frameworks","title":"Base.empty","text":"empty(gen::OperatorGenerator) -> OperatorGenerator\nempty!(gen::OperatorGenerator) -> OperatorGenerator\n\nGet an empty copy of or empty an operator generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.isempty-Tuple{CategorizedGenerator}","page":"Frameworks","title":"Base.isempty","text":"isempty(cat::CategorizedGenerator) -> Bool\n\nJudge whether a categorized generator is empty.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.isempty-Tuple{OperatorGenerator}","page":"Frameworks","title":"Base.isempty","text":"isempty(gen::OperatorGenerator) -> Bool\n\nJudge whether an OperatorGenerator is empty.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.iterate-Tuple{Generator}","page":"Frameworks","title":"Base.iterate","text":"iterate(gen::Generator)\niterate(::Generator, state)\n\nIterate over a Generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.match-Tuple{NamedTuple{Names, T} where {Names, T<:Tuple{Vararg{Number}}}, NamedTuple{Names, T} where {Names, T<:Tuple{Vararg{Number}}}}","page":"Frameworks","title":"Base.match","text":"match(params‚ÇÅ::Parameters, params‚ÇÇ::Parameters; atol=atol, rtol=rtol) -> Bool\n\nJudge whether the second set of parameters matches the first.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.pathof-Tuple{Union{Algorithm, Assignment}}","page":"Frameworks","title":"Base.pathof","text":"pathof(obj::Union{Assignment, Algorithm}; prefix::String=\"\", suffix::String=\"\", extension::String=\"qld\") -> String\n\nGet the path of the data file of an assignment/algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.show-Tuple{IO, Algorithm}","page":"Frameworks","title":"Base.show","text":"show(io::IO, alg::Algorithm)\n\nShow an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.show-Tuple{IO, Assignment}","page":"Frameworks","title":"Base.show","text":"show(io::IO, assign::Assignment)\n\nShow an assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Algorithm}","page":"Frameworks","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", alg::Algorithm)\n\nShow an algorithm.\n\nOptionally, some parameters of the algorithm can be filtered by specifying the :select context in io. Besides, the maximum number of decimals of the parameters can also be specified by the :ndecimal context in io.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Assignment}","page":"Frameworks","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", assign::Assignment)\n\nShow an assignment.\n\nOptionally, some parameters of the algorithm can be filtered by specifying the :select context in io. Besides, the maximum number of decimals of the parameters can also be specified by the :ndecimal context in io.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.summary-Tuple{Algorithm}","page":"Frameworks","title":"Base.summary","text":"summary(alg::Algorithm)\n\nProvide a summary of an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.valtype-Tuple{Assignment}","page":"Frameworks","title":"Base.valtype","text":"valtype(assign::Assignment)\nvaltype(::Type{<:Assignment})\n\nType of the data (result) of an assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.valtype-Tuple{Formula}","page":"Frameworks","title":"Base.valtype","text":"valtype(formula::Formula)\nvaltype(::Type{<:Formula{V}})\n\nGet the valtype of a Formula.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#Base.valtype-Tuple{Generator}","page":"Frameworks","title":"Base.valtype","text":"valtype(gen::Generator)\nvaltype(::Type{<:Generator{V}}) where V\n\nGet the valtype of a Generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.checkoptions-Union{Tuple{Type{A}}, Tuple{A}} where A<:Assignment","page":"Frameworks","title":"QuantumLattices.Frameworks.checkoptions","text":"checkoptions(::Type{A}; options...) where {A<:Assignment}\n\nCheck whether the keyword arguments are legal options of a certain type of Assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.datatype-Union{Tuple{F}, Tuple{A}, Tuple{Type{A}, Type{F}}} where {A<:Action, F<:Frontend}","page":"Frameworks","title":"QuantumLattices.Frameworks.datatype","text":"datatype(::Type{A}, ::Type{F}) where {A<:Action, F<:Frontend}\n\nGet the concrete subtype of Data according to the types of an Action and a Frontend.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.hasoption-Union{Tuple{A}, Tuple{Type{A}, Symbol}} where A<:Assignment","page":"Frameworks","title":"QuantumLattices.Frameworks.hasoption","text":"hasoption(::Type{A}, option::Symbol) where {A<:Assignment} -> Bool\n\nJudge whether a certain type of Assignment has an option.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.options-Tuple{Type{<:Assignment}}","page":"Frameworks","title":"QuantumLattices.Frameworks.options","text":"options(::Type{<:Assignment}) -> NamedTuple\n\nGet the options of a certain type of Assignment.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.optionsinfo-Union{Tuple{Type{A}}, Tuple{A}} where A<:Assignment","page":"Frameworks","title":"QuantumLattices.Frameworks.optionsinfo","text":"optionsinfo(::Type{A}; level::Int=1) where {A<:Assignment} -> String\n\nGet the complete info of the options of a certain type of Assignment, including that of its dependencies.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.qldload-Tuple{String}","page":"Frameworks","title":"QuantumLattices.Frameworks.qldload","text":"qldload(filename::String) -> Dict{String, Any}\nqldload(filename::String, name::String) -> Any\nqldload(filename::String, name‚ÇÅ::String, name‚ÇÇ::String, names::String...) -> Tuple\n\nLoad data from a qld file.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.qldsave-Tuple{Union{Algorithm, Assignment}, Vararg{Union{Algorithm, Assignment}}}","page":"Frameworks","title":"QuantumLattices.Frameworks.qldsave","text":"qldsave(obj::Union{Assignment, Algorithm}, objs::Union{Assignment, Algorithm}...; mode::String=\"a+\", prefix::String=\"\", suffix::String=\"\", ndecimal::Int=10, select::Function=name::Symbol->true, front::String=\"\", rear::String=\"\")\n\nSave an assignment/algorithm to a qld file.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Frameworks.run!","page":"Frameworks","title":"QuantumLattices.Frameworks.run!","text":"run!(alg::Algorithm, assign::Assignment; options...)\n\nRun an assignment based on an algorithm.\n\n\n\n\n\n","category":"function"},{"location":"man/Frameworks/#QuantumLattices.QuantumOperators.scalartype-Union{Tuple{Type{F}}, Tuple{F}} where F<:Formula","page":"Frameworks","title":"QuantumLattices.QuantumOperators.scalartype","text":"scalartype(::Type{F}) where {F<:Formula}\n\nGet the scalar type of a Formula.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.QuantumOperators.scalartype-Union{Tuple{Type{T}}, Tuple{T}} where T<:Generator","page":"Frameworks","title":"QuantumLattices.QuantumOperators.scalartype","text":"scalartype(::Type{T}) where {T<:Generator}\n\nGet the scalar type of a Generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.Spatials.dlmsave","page":"Frameworks","title":"QuantumLattices.Spatials.dlmsave","text":"dlmsave(assignment::Assignment, delim='\t'; prefix::String=\"\", suffix::String=\"\", ndecimal::Int=10, select::Function=name::Symbol->true, front::String=\"\", rear::String=\"\")\n\nSave the data of an assignment to a delimited file.\n\n\n\n\n\n","category":"function"},{"location":"man/Frameworks/#QuantumLattices.expand!-Tuple{Any, Generator}","page":"Frameworks","title":"QuantumLattices.expand!","text":"expand!(result, gen::Generator) -> typeof(result)\n\nExpand the generator to add the (representations of) quantum operators in a quantum lattice system to result.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.expand-Tuple{CategorizedGenerator, Lazy}","page":"Frameworks","title":"QuantumLattices.expand","text":"expand(cat::CategorizedGenerator, ::Lazy)\n\nExpand a categorized generator to get the (representations of) quantum operators in a quantum lattice system.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.expand-Tuple{Generator}","page":"Frameworks","title":"QuantumLattices.expand","text":"expand(gen::Generator)\nexpand(gen::Generator, ::Eager)\nexpand(gen::Generator, ::Lazy)\n\nExpand the generator to get the (representations of) quantum operators in a quantum lattice system.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.expand-Tuple{OperatorGenerator, Symbol}","page":"Frameworks","title":"QuantumLattices.expand","text":"expand(gen::OperatorGenerator, name::Symbol) -> Operators\nexpand(gen::OperatorGenerator, i::Int) -> Operators\nexpand(gen::OperatorGenerator, name::Symbol, i::Int) -> Operators\n\nExpand an operator generator to get:\n\nthe operators of a specific term;\nthe operators on a specific bond;\nthe operators of a specific term on a specific bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.reset!-Tuple{CategorizedGenerator, LinearTransformation, CategorizedGenerator}","page":"Frameworks","title":"QuantumLattices.reset!","text":"reset!(cat::CategorizedGenerator, transformation::LinearTransformation, source::CategorizedGenerator; kwargs...)\n\nReset a categorized generator by its source categorized generator of (representations of) quantum operators and the corresponding linear transformation.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.reset!-Tuple{CategorizedGenerator, LinearTransformation, OperatorGenerator}","page":"Frameworks","title":"QuantumLattices.reset!","text":"reset!(cat::CategorizedGenerator, transformation::LinearTransformation, source::OperatorGenerator; kwargs...)\n\nReset a categorized generator by its source operator generator of (representations of) quantum operators and the corresponding linear transformation.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.reset!-Tuple{OperatorGenerator, AbstractVector{<:Bond}, Hilbert}","page":"Frameworks","title":"QuantumLattices.reset!","text":"reset!(gen::OperatorGenerator, bonds::AbstractVector{<:Bond}, hilbert::Hilbert; vectors::AbstractVector{<:AbstractVector}=gen.operators.boundary.vectors) -> OperatorGenerator\n\nReset an operator generator by a new lattice and the corresponding new hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.str-Tuple{NamedTuple{Names, T} where {Names, T<:Tuple{Vararg{Number}}}}","page":"Frameworks","title":"QuantumLattices.str","text":"str(params::Parameters; ndecimal::Int=10, select::Function=name::Symbol->true, front::String=\"\", rear::String=\"\") -> String\n\nConvert a set of Parameters to a string with each number hosting at most ndecimal decimal places. Here, the select function can select the key-value pairs to be contained by the keys.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.str-Tuple{Union{Algorithm, Assignment}}","page":"Frameworks","title":"QuantumLattices.str","text":"str(obj::Union{Assignment, Algorithm}; prefix::String=\"\", suffix::String=\"\", ndecimal::Int=10, select::Function=name::Symbol->true, front::String=\"\", rear::String=\"\") -> String\n\nGet the string representation of an assignment/algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Action}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(action::Action; parameters...) -> Action\n\nUpdate the parameters of an action.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Algorithm}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(alg::Algorithm; parameters...) -> Algorithm\n\nUpdate the parameters of an algorithm and its associated frontend.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Assignment}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(assign::Assignment; parameters...) -> Assignment\n\nUpdate the parameters of an assignment and the status of its associated action.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{CategorizedGenerator, LinearTransformation, CategorizedGenerator}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(cat::CategorizedGenerator, transformation::LinearTransformation, source::CategorizedGenerator; kwargs...) -> CategorizedGenerator\n\nUpdate the parameters (including the boundary parameters) of a categorized generator based on its source categorized generator of (representations of) quantum operators and the corresponding linear transformation.\n\n!!! Note     The coefficients of boundops are also updated due to the change of the boundary parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{CategorizedGenerator, LinearTransformation, OperatorGenerator}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(cat::CategorizedGenerator, transformation::LinearTransformation, source::OperatorGenerator; kwargs...) -> CategorizedGenerator\n\nUpdate the parameters (including the boundary parameters) of a categorized generator based on its source operator generator of (representations of) quantum operators and the corresponding linear transformation.\n\n!!! Note     The coefficients of boundops are also updated due to the change of the boundary parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{CategorizedGenerator{<:OperatorSum}}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(cat::CategorizedGenerator{<:OperatorSum}; parameters...) -> CategorizedGenerator\n\nUpdate the parameters (including the boundary parameters) of a categorized generator of (representations of) quantum operators.\n\n!!! Note     The coefficients of boundops are also updated due to the change of the boundary parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{Formula}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(formula::Formula; parameters...) -> Formula\n\nUpdate the parameters of a Formula in place and return itself after update.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update!-Tuple{OperatorGenerator}","page":"Frameworks","title":"QuantumLattices.update!","text":"update!(gen::OperatorGenerator; parameters...) -> typeof(gen)\n\nUpdate the coefficients of the terms in a generator.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#QuantumLattices.update-Tuple{NamedTuple}","page":"Frameworks","title":"QuantumLattices.update","text":"update(params::NamedTuple; parameters...) -> Parameters\n\nUpdate a set of Parameters and return the updated one.\n\n\n\n\n\n","category":"method"},{"location":"man/Frameworks/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Assignment}","page":"Frameworks","title":"RecipesBase.apply_recipe","text":"@recipe plot(assignment::Assignment)\n\nDefine the recipe for the visualization of an assignment of an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"advanced topics/HybridSystems/#Hybrid-systems","page":"Hybrid systems","title":"Hybrid systems","text":"","category":"section"},{"location":"man/Toolkit/#Toolkit","page":"Toolkit","title":"Toolkit","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"This module contains the toolkit of the package.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The constants, types, macros, functions defined in this module will not be exported by the package. Instead, they serve as the prerequisites. The range of the contents are quite wide, but basically, they fall into two categories:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Utilities, such as global constants and miscellaneous tiny useful functions;\nBasic data structures as supplements to the Julia.Base and other common packages.","category":"page"},{"location":"man/Toolkit/#Utilities","page":"Toolkit","title":"Utilities","text":"","category":"section"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.atol","page":"Toolkit","title":"QuantumLattices.Toolkit.atol","text":"Absolute tolerance for float numbers.\n\n\n\n\n\n","category":"constant"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.rtol","page":"Toolkit","title":"QuantumLattices.Toolkit.rtol","text":"Relative tolerance for float numbers.\n\n\n\n\n\n","category":"constant"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Float","page":"Toolkit","title":"QuantumLattices.Toolkit.Float","text":"Default float type.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.concatenate","page":"Toolkit","title":"QuantumLattices.Toolkit.concatenate","text":"concatenate(ts::Tuple...) -> Tuple\n\nConcatenate tuples.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.str","page":"Toolkit","title":"QuantumLattices.str","text":"str(number; kwargs...) -> String\nstr(number::Integer; kwargs...) -> String\nstr(number::Rational; kwargs...) -> String\nstr(number::AbstractFloat; ndecimal::Integer=5) -> String\nstr(number::Complex; ndecimal::Integer=5) -> String\n\nConvert a number to a string with at most ndecimal decimal places.\n\n\n\n\n\nstr(value::Symbol; kwargs...) -> String\nstr(value::Colon; kwargs...) -> String\nstr(value::Char; kwargs...) -> String\n\nConvert a single value to string.\n\n\n\n\n\nstr(params::Parameters; ndecimal::Int=10, select::Function=name::Symbol->true, front::String=\"\", rear::String=\"\") -> String\n\nConvert a set of Parameters to a string with each number hosting at most ndecimal decimal places. Here, the select function can select the key-value pairs to be contained by the keys.\n\n\n\n\n\nstr(obj::Union{Assignment, Algorithm}; prefix::String=\"\", suffix::String=\"\", ndecimal::Int=10, select::Function=name::Symbol->true, front::String=\"\", rear::String=\"\") -> String\n\nGet the string representation of an assignment/algorithm.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.subscript","page":"Toolkit","title":"QuantumLattices.Toolkit.subscript","text":"subscript(i::Integer) -> String\n\nConvert an integer to the subscript.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.superscript","page":"Toolkit","title":"QuantumLattices.Toolkit.superscript","text":"superscript(i::Integer) -> String\n\nConvert an integer to the superscript.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.delta","page":"Toolkit","title":"QuantumLattices.Toolkit.delta","text":"delta(i, j) -> Int\n\nKronecker delta function.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.id","page":"Toolkit","title":"QuantumLattices.id","text":"id(od::OrderedDict, i) -> keytype(od)\n\nGet the ith key of an OrderedDict.\n\n\n\n\n\nid(m::OperatorPack) -> idtype(m)\n\nGet the id of an OperatorPack.\n\n\n\n\n\nid(term::Term) -> Symbol\nid(::Type{<:Term) -> Symbol\n\nGet the id of a term.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.value","page":"Toolkit","title":"QuantumLattices.value","text":"value(od::OrderedDict, i) -> valtype(od)\n\nGet the ith value of an OrderedDict.\n\n\n\n\n\nvalue(m::OperatorPack) -> valtype(m)\n\nGet the value of an OperatorPack.\n\n\n\n\n\nvalue(qn::SimpleAbelianQuantumNumber) -> Number\n\nGet the value of a simple Abelian quantum number.\n\n\n\n\n\nvalue(qn::AbelianQuantumNumberProd, i::Integer) -> Number\n\nGet the value of the ith simple Abelian quantum number in a Deligne tensor product.\n\n\n\n\n\nvalue(term::Term) -> valtype(term)\n\nGet the value of a term.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.DirectSummedIndices","page":"Toolkit","title":"QuantumLattices.Toolkit.DirectSummedIndices","text":"DirectSummedIndices{T<:Tuple{Vararg{OrdinalRange{Int, Int}}}} <: AbstractVector{CartesianIndex{3}}\n\nDirect sum of indexes.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Segment","page":"Toolkit","title":"QuantumLattices.Toolkit.Segment","text":"Segment{S} <: AbstractVector{S}\n\nA segment.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Combinatorics","page":"Toolkit","title":"Combinatorics","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The combinations and permutations of an indexable object are implemented, with duplicate elements allowed or not. Compared to another Julia package Combinatorics, the iterators return tuples instead of vectors, which could greatly decrease the memory allocation times and improves the code efficiency.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Combinatorics{M, C} is the abstract type of all combinatorial algorithms. It has two type parameters:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"M: the number of elements to be taken\nC: the type of the collection of candidate elements","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To avoid memory allocation, the iteration of a concrete combinatorial algorithm returns a tuple, whose length is M and eltype is eltype(C).","category":"page"},{"location":"man/Toolkit/#Combinations-and-DuplicateCombinations","page":"Toolkit","title":"Combinations and DuplicateCombinations","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Combinations{M, C} and DuplicateCombinations{M, C} generate all the combinations of M elements from an indexable collection whose type is C, with the differences being that the former forbids duplicate elements in the combinations while the latter allows.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"All combinations of 2 integers taken from 1 to 3 without duplicate:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Combinations{2}(1:3) |> collect","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"All combinations of 2 integers taken from 1 to 3 with duplicate allowed:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"DuplicateCombinations{2}(1:3) |> collect","category":"page"},{"location":"man/Toolkit/#Permutations-and-DuplicatePermutations","page":"Toolkit","title":"Permutations and DuplicatePermutations","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Permutations{M, C} and DuplicatePermutations{M, C} generate all the permutations of M elements from an indexable collection whose type is C, with the differences being that the former forbids duplicate elements in the permutations while the latter allows.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"All permutations of 2 integers taken from 1 to 3 without duplicate:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Permutations{2}(1:3) |> collect","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"All permutations of 2 integers taken from 1 to 3 with duplicate allowed:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"DuplicatePermutations{2}(1:3) |> collect","category":"page"},{"location":"man/Toolkit/#Manual","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Combinatorics","page":"Toolkit","title":"QuantumLattices.Toolkit.Combinatorics","text":"Combinatorics{M, C}\n\nAbstract combinatorial algorithms.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Combinations","page":"Toolkit","title":"QuantumLattices.Toolkit.Combinations","text":"Combinations{M}(contents::C) where {M, C}\n\nCombinations of M elements from contents. Duplicates are not allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.DuplicateCombinations","page":"Toolkit","title":"QuantumLattices.Toolkit.DuplicateCombinations","text":"DuplicateCombinations{M}(contents::C) where {M, C}\n\nCombinations of M elements from contents. Duplicates are allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.Permutations","page":"Toolkit","title":"QuantumLattices.Toolkit.Permutations","text":"Permutations{M}(contents::C) where {M, C}\n\nPermutations of M elements from contents. Duplicates are not allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.DuplicatePermutations","page":"Toolkit","title":"QuantumLattices.Toolkit.DuplicatePermutations","text":"DuplicatePermutations{M}(contents::C) where {M, C}\n\nPermutations of M elements from contents. Duplicates are allowed.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Traits","page":"Toolkit","title":"Traits","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Trait functions and trait types that are useful to the package are defined.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Generally speaking, traits in Julia could fall into two categories according to their usages, the first may be term as \"type helpers\" and the second are usually called \"Holy traits\" named after Tim Holy. Type helpers aim at the inquiry, alteration and computation of the compile-time information of types, while Holy traits can be applied as an alternative to multi-inheritance by use of the Julia multidispatch feature.","category":"page"},{"location":"man/Toolkit/#Type-helpers","page":"Toolkit","title":"Type helpers","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Type helpers are important for the generic programming in Julia, especially in the design of generic interfaces and abstract types.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Let's see a simple situation, i.e. the elemental addition of two vectors of numbers. The numbers can assume different types and the type of the result depends on both of them, for example, the result between two vectors of integers is a vector of integers while that between a vector of integers and a vector of floats is a vector of floats. Of course, one can explicitly define every elemental addition function between any two different types of vectors of numbers, like this:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"# wrong design pattern\n\nfunction elementaladdition(v‚ÇÅ::Vector{Int64}, v‚ÇÇ::Vector{Int64})\n    result = Int[]\n    ...\nend\nfunction elementaladdition(v‚ÇÅ::Vector{Int64}, v‚ÇÇ::Vector{Float64})\n    result = Float64[]\n    ...\nend\n...\n...","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Writing down all such methods is already a heavy repetition. What's worse, you will quickly find that a lot more functions, such as the elemental subtraction, elemental multiplication and elemental division, are waiting for you to implement. This is a total disaster.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The correct strategy is to define the promotion rule of any two types of numbers and use it to define the type of the result:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"# correct design pattern\n\npromotion(::Type{Int64}, ::Type{Int64}) = Int64\npromotion(::Type{Int64}, ::Type{Float64}) = Float64\n...\n...\n\nfunction elementaladdition(v‚ÇÅ::Vector{T‚ÇÅ}, v‚ÇÇ::Vector{T‚ÇÇ}) where {T‚ÇÅ<:Number, T‚ÇÇ<:Number}\n    result = promotion(T‚ÇÅ, T‚ÇÇ)[]\n    ...\nend\nfunction elementalsubtraction(v‚ÇÅ::Vector{T‚ÇÅ}, v‚ÇÇ::Vector{T‚ÇÇ}) where {T‚ÇÅ<:Number, T‚ÇÇ<:Number}\n    result = promotion(T‚ÇÅ, T‚ÇÇ)[]\n    ...\nend\n...\n...","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The promotion rule applies equally to all the arithmetic operations on numbers. Therefore, tedious code repetition could be avoided with it. In fact, similar promotion rules have already been defined in Julia base, and the default implementations of arithmetic operations in Julia are indeed based on them (see Base.promote_rule and Base.promote_type). When new user-defined numeric types are introduced, the only things you need to do is to add new promotion rules and implement a few basic arithmetic functions for these new types. Then quite a lot of generic codes could apply to them without any modification.","category":"page"},{"location":"man/Toolkit/#Type-helpers-with-type-parameters","page":"Toolkit","title":"Type helpers with type parameters","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The input and output types of a promotion rule are known at compile time, thus, the promotion rule is a trait function aiming at the computation of compile-time information of types. Trait functions dealing with the inquiries of compile-time information of types are also widely used in Julia, such as the eltype function of Vector:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> eltype(Vector{String})\nString","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For a user-defined parametric type, it is also useful to provide an inquiry function to access to the type parameters:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> struct Hi{T<:Number}\n           content::T\n       end\n       contenttype(::Type{Hi{T}}) where T<:Number = T\n       contenttype(Hi{Int64})\nInt64","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"However, the above defined function contenttype could not apply to a UnionAll type, such as Hi{<:Real}:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> contenttype(Hi{<:Real})\nERROR: MethodError: no method matching contenttype(::Type{Hi{<:Real}})\n[...]","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"In fact in Julia base, all such inquiry functions, e.g., the eltype function, work poor for the UnionAll types:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> eltype(Vector{<:Real})\nAny","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"In concept, eltype(Vector{<:Real} should return Real instead of Any as every element in Vector{<:Real} is indeed a real number. Similarly, we expect that contenttype(Hi{<:Real}) should also give us Real. Unfortunately, functions defined in the similar form like this could never achieve such goals. Julia base doesn't provide generic functions to access or change the information of the parameters of a type. In this module, we try to fill this gap with a set of generic trait functions.","category":"page"},{"location":"man/Toolkit/#Access-or-change-the-type-parameters-by-their-position-orders","page":"Toolkit","title":"Access or change the type parameters by their position orders","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The most direct information of the parameters of a type is their position orders. We provide parametertype to access to them by such information:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametertype(Hi{<:Real}, 1)\nReal\n\njulia> parametertype(Vector{<:Real}, 1)\nReal\n\njulia> parametertype(Vector{<:Real}, 2)\n1","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"You can use parametercount to inquire the total number of the parameters of a type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametercount(Hi)\n1\n\njulia> parametercount(Vector)\n2","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"It is noted that Vector has 2 type parameters because it is just a type alias for Array{T, 1} where T.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To change the parameters of a type, reparameter can be used:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> reparameter(Hi{Int64}, 1, Real)\nHi{<:Real}\n\njulia> reparameter(Vector{Int64}, 1, Real)\nVector{<:Real} (alias for Array{<:Real, 1})\n\njulia> reparameter(Vector{<:Real}, 2, 3)\nArray{<:Real, 3}\n\njulia> reparameter(Hi{Int64}, 1, Real, false)\nHi{Real}\n\njulia> reparameter(Hi{Int64}, 1, Real, true)\nHi{<:Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"We want to remark that by providing the fourth positional argument with the true value, a UnionAll type could be generated. When the fourth positional argument is omitted, it is actually determined by another trait function, i.e., isparameterbound. This function judges whether an input type should be considered as the upper bound of the new parameter of a type. By default, it is defined to be","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"isparameterbound(::Type{}, ::Val{}, ::Type{D}) where D = !isconcretetype(D)\nisparameterbound(::Type{}, ::Val{}, ::Any) = false","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"This function can be overloaded to change the behavior for a certain type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> isparameterbound(::Type{<:Vector}, ::Val{1}, ::Type{D}) where D = false;\n\njulia> reparameter(Vector, 1, Real)\nVector{Real} (alias for Array{Real, 1})","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The second positional argument of isparameterbound must be of type Val because in principle you should be able to assign different behaviors for different parameters of a type separately. If it is of type Integer, a single overloading would change the behaviors for all.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Besides, you can inquire all the parameters of a type by parametertypes:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametertypes(Hi{<:Real})\nTuple{Real}\n\njulia> parametertypes(Vector{Int64})\nTuple{Int64, 1}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The obtained type parameters are stored as those of a Tuple.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"At the same time, you can change all the parameters of a type by fulltype:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> fulltype(Hi{Int64}, Tuple{Real})\nHi{<:Real}\n\njulia> fulltype(Hi{Int64}, Tuple{Real}, (false,))\nHi{Real}\n\njulia> fulltype(Vector{Int64}, Tuple{Real, 2})\nMatrix{Real} (alias for Array{Real, 2})\n\njulia> fulltype(Vector{Int64}, Tuple{Real, 2}, (true, false))\nMatrix{<:Real} (alias for Array{<:Real, 2})","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Like reparameter, the last positional argument of fulltype could determine whether the corresponding types specified by the type parameters of the input Tuple should be considered as the upper bounds of the new parameters of a type. When this argument is omitted, it is determined by another trait function isparameterbounds, which successively calls the isparameterbound function to determine the behaviors for all the parameters of a type as the literal indicates.","category":"page"},{"location":"man/Toolkit/#Associate-type-parameters-with-names","page":"Toolkit","title":"Associate type parameters with names","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Sometimes, it is more convenient to associate names with the parameters of a type, and then access or change them by their names. This can be done by overloading the parameternames trait function for a certain type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parameternames(::Type{<:Hi}) = (:content,)\nparameternames (generic function with 3 methods)","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Now, you can inquire the name of a type parameter by parametername with the given position order or vice versa by parameterorder:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametername(Hi, 1)\n:content\n\njulia> parameterorder(Hi, :content)\n1","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"You can also inquire whether a type has a parameter with the given name by hasparameter:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> hasparameter(Hi, :content)\ntrue\n\njulia> hasparameter(Hi, :others)\nfalse","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"And parametertype and reparameter can be applied by the name of a type parameter instead of its position order:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parametertype(Hi{<:Real}, :content)\nReal\n\njulia> reparameter(Hi{Int}, :content, Real)\nHi{<:Real}\n\njulia> reparameter(Hi{Int}, :content, Real, false)\nHi{Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To change the reparameter behavior when its last positional argument is omitted, you should overload the isparameterbound function accordingly, e.g.:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> isparameterbound(::Type{<:Hi}, ::Val{:content}, ::Type{D}) where D = false;\n\njulia> reparameter(Hi{Int}, :content, Real)\nHi{Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"note: Note\nAccessing or altering a parameter of a type by its name is independent from that by its position order. Thus, even the following methodisparameterbound(::Type{<:Hi}, ::Val{1}, D)has been overloaded, it doesn't affect the result of the function call likereparameter(Hi{Int}, :content, Real)Rather, it only affect the result of the function call likereparameter(Hi{Int}, 1, Real)To change the default behavior of the former function call, you must overload the following method manually as wellisparameterbound(::Type{<:Hi}, ::Val{:content}, D)","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A new trait function parameterpair is provided to inquire the name-type pair of a parameter of a type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parameterpair(Hi{<:Real}, 1)\nPair{:content, Real}\n\njulia> parameterpair(Hi{<:Real}, :content)\nPair{:content, Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"And a new trait function parameterpairs can be used to inquire all the name-type pairs of the parameters of a type:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> parameterpairs(Hi{<:Real})\n@NamedTuple{content::Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The parameters of a type can be altered all at once by giving the name-type pairs to fulltype:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}}, (false,))\nHi{Real}\n\njulia> fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}}, (true,))\nHi{<:Real}\n\njulia> fulltype(Hi{Int}, NamedTuple{(:content,), Tuple{Real}})\nHi{Real}","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Here, the last positional argument can be omitted whose default value would be determined by the isparameterbounds function which successively calls the isparameterbound function on each of the named parameter. Note that similar to the situation of the reparameter function in this subsubsection, the isparameterbound function called here is also the version that takes the parameter name as the input rather than that of the position order.","category":"page"},{"location":"man/Toolkit/#Type-helpers-with-predefined-contents","page":"Toolkit","title":"Type helpers with predefined contents","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Julia abstract types don't have any field or attribute. They are only tags on the type tree. However, we may expect sometimes an abstract type to possess some kind of predefined content so that the design of some methods could be highly simplified. For example, we may need an abstract type that describes a composite vector. Apparently, it should have a field that is the vector contained in it. Of course, we can appoint a fixed field name with it and force every concrete subtype must contain such a field. In such a design pattern, the name of this field in every concrete subtype must be kept unchanged, which may be annoying when it conflicts with that of another field. What's worse, a predefined content of an abstract type is not always limited to a certain field. Maybe we need more than one fields to construct such a content. The just mentioned design pattern cannot deal with such situations.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Here, we provide a set of trait functions to help the design of abstract types with predefined contents. We take the case of composite vector for illustration, and the generalization to other situations is straightforward. First, the trait function contentnames should be overloaded to define the names of the predefined contents:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> abstract type CompositeVector{T} end\n       contentnames(::Type{<:CompositeVector}) = (:content,);","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Then you can inquire the total number of predefined contents by contentcount, inquire the name of a predefined content with its position order by contentname, and judge whether a type has a predefined content with a given name by hascontent:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> contentcount(CompositeVector)\n1\n\njulia> contentname(CompositeVector, 1)\n:content\n\njulia> hascontent(CompositeVector, :content)\ntrue\n\njulia> hascontent(CompositeVector, :value)\nfalse","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The key is the interface getcontent, which defines how to get the value of the predefined content. For the simple case when the predefined content just corresponds to a field, and also the field name of the predefined content coincides with the content name, the overloading of getcontent can be omitted, e.g.:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> struct AnotherCompositeVector{T} <: CompositeVector{T}\n           content::Vector{T}\n       end;\n\njulia> v = AnotherCompositeVector([1, 2, 3])\n       getcontent(v, :content)\n3-element Vector{Int64}:\n 1\n 2\n 3","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For the cases when a predefined contents does not share the same name with a certain field, or even it is not limited to only one certain field, you must implement your own getcontent manually. Let's see two typical examples:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"julia> struct DifferentFieldName{T} <: CompositeVector{T}\n           data::Vector{T}\n       end\n       getcontent(v::DifferentFieldName, ::Val{:content}) = v.data;\n\njulia> struct BeyondSingleField{T} <: CompositeVector{T}\n           firsthalf::Vector{T}\n           secondhalf::Vector{T}\n       end\n       getcontent(v::BeyondSingleField, ::Val{:content}) = [v.firsthalf; v.secondhalf];\n\njulia> v = DifferentFieldName([1, 2, 3])\n       getcontent(v, :content)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> v = BeyondSingleField([1, 2, 3], [4, 5, 6])\n       getcontent(v, :content)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Note that for the method overloading of getcontent, the second argument is of type Val{:content}. This is convenient because in principle an abstract type could have more than only one predefined content, thus, the behaviors of the getcontent function could be defined separately for different predefined contents in this way. In fact, the function call getcontent(m, contentname) is just an alias for getcontent(m, contentname|>Val).","category":"page"},{"location":"man/Toolkit/#Holy-traits","page":"Toolkit","title":"Holy traits","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"As an emergent feature of Julia, basically speaking, a Holy trait is a Julia type that could direct the generic function of a user-defined type to a certain implementation based on the Julia multi-dispatch mechanism. For different user-defined types, they could be assigned with different Holy traits, leading to different implementations of the same generic interface. Since the information of Holy traits are known at compile time, such design pattern doesn't affect the runtime efficiency as long as type stability is ensured.","category":"page"},{"location":"man/Toolkit/#Alternative-of-multi-inheritance","page":"Toolkit","title":"Alternative of multi-inheritance","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Maybe the most common application of Holy traits is to serve as the alternative of multi-inheritance. Let's see a simple scenario. You have defined an abstract type. It is natural to demand that for every concrete subtype of it, a pair of instances could be compared and judge whether they are equivalent to each other by the value. Unfortunately, for a new user-defined type, the default == function in Julia actually judges whether they are the same object, but not equal to each other by the value. Therefore, you need to define your own == function for this abstract type. However, you may need define a lot of abstract types when you are developing a Julia package. It is annoying if such simple functions must be written for each of them. In other languages like Python, this could be solved with the help of multi-inheritance. But Julia does not support multi-inheritance. The common way is to use Holy traits. For example, the above issue could be solved like this:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"struct Equivalence end\nconst equivalence = Equivalence()\nfunction Base.:(==)(::Equivalence, o‚ÇÅ, o‚ÇÇ)\n    n‚ÇÅ, n‚ÇÇ = fieldcount(typeof(o‚ÇÅ)), fieldcount(typeof(o‚ÇÇ))\n    n‚ÇÅ‚â†n‚ÇÇ && return false\n    for i = 1:n‚ÇÅ\n        getfield(o‚ÇÅ, i)‚â†getfield(o‚ÇÇ, i) && return false\n    end\n    return true\nend\n\nabstract type TypeWithEquivalence end\nBase.:(==)(o‚ÇÅ::TypeWithEquivalence, o‚ÇÇ::TypeWithEquivalence) = ==(equivalence, o‚ÇÅ, o‚ÇÇ);\n\nstruct ConcreteTypeWithEquivalence{F‚ÇÅ, F‚ÇÇ} <: TypeWithEquivalence\n    f‚ÇÅ::F‚ÇÅ\n    f‚ÇÇ::F‚ÇÇ\nend;\n\na‚ÇÅ = ConcreteTypeWithEquivalence((\"a\", \"b\", \"c\"), [1, 2, 3])\na‚ÇÇ = ConcreteTypeWithEquivalence((\"a\", \"b\", \"c\"), [1.0, 2.0, 3.0])\na‚ÇÅ == a‚ÇÇ","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Here, the type Equivalence is the Holy trait that helps the abstract type TypeWithEquivalence to implement the == function, which applies equally to any other types.","category":"page"},{"location":"man/Toolkit/#Type-stability-and-the-generated-function-trick","page":"Toolkit","title":"Type stability and the generated function trick","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"However, the story does not end up here. If you are concerned about the code efficiency, you may find that the above implementation is not type stable:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"using BenchmarkTools\n@benchmark $a‚ÇÅ == $a‚ÇÇ","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"The memory allocation occurs when the == function tries to compare the values of getfield(o‚ÇÅ, i) and getfield(o‚ÇÇ, i) because in principle the types of these values depend on the runtime value of the variable i. To ensure type stability, the generated function trick can be utilized:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"struct EfficientEquivalence end\nconst efficientequivalence = EfficientEquivalence()\n@generated function Base.:(==)(::EfficientEquivalence, o‚ÇÅ, o‚ÇÇ)\n    n‚ÇÅ, n‚ÇÇ = fieldcount(o‚ÇÅ), fieldcount(o‚ÇÇ)\n    n‚ÇÅ‚â†n‚ÇÇ && return false\n    expr = :(getfield(o‚ÇÅ, 1) == getfield(o‚ÇÇ, 1))\n    for i = 2:n‚ÇÅ\n        expr = Expr(:&&, expr, :(getfield(o‚ÇÅ, $i) == getfield(o‚ÇÇ, $i)))\n    end\n    return expr\nend\n\nabstract type TypeWithEfficientEquivalence end\nfunction Base.:(==)(o‚ÇÅ::TypeWithEfficientEquivalence, o‚ÇÇ::TypeWithEfficientEquivalence)\n    return ==(efficientequivalence, o‚ÇÅ, o‚ÇÇ)\nend\n\nstruct ConcreteTypeWithEfficientEquivalence{F‚ÇÅ, F‚ÇÇ} <: TypeWithEfficientEquivalence\n    f‚ÇÅ::F‚ÇÅ\n    f‚ÇÇ::F‚ÇÇ\nend\n\na‚ÇÅ = ConcreteTypeWithEfficientEquivalence((\"a\", \"b\", \"c\"), [1, 2, 3])\na‚ÇÇ = ConcreteTypeWithEfficientEquivalence((\"a\", \"b\", \"c\"), [1.0, 2.0, 3.0])\na‚ÇÅ == a‚ÇÇ","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"@benchmark $a‚ÇÅ == $a‚ÇÇ","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"At runtime of the generated == function, it compares the values of getfield(o‚ÇÅ, 1) and getfield(o‚ÇÇ, 1), getfield(o‚ÇÅ, 2) and getfield(o‚ÇÇ, 2), etc., whose types are known at compile time. Therefore, type stability could be ensured.","category":"page"},{"location":"man/Toolkit/#EfficientOperations","page":"Toolkit","title":"EfficientOperations","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"EfficientOperations is a Holy trait defined in this module that packs several common operations, such as ==/isequal, </isless, isapprox and replace, to help other (abstract) types to implement such functions by passing efficientoperations as the first argument, just as illustrated above. See the manual for more detailed information.","category":"page"},{"location":"man/Toolkit/#Manual-2","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For traits with types themselves:","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.SubTypeTree","page":"Toolkit","title":"QuantumLattices.Toolkit.SubTypeTree","text":"SubTypeTree(root::Type)\n\nConstruct the complete depth-first subtype tree of a root Type.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.commontype","page":"Toolkit","title":"QuantumLattices.Toolkit.commontype","text":"commontype(f::Function, types, ::Type{T}=Any) where T\n\nFind the common return type of a function.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.fulltype","page":"Toolkit","title":"QuantumLattices.Toolkit.fulltype","text":"fulltype(::Type{T}, ::Type{PS}, ubs::Tuple{Vararg{Bool}}=isparameterbounds(T, PS)) where {T, PS<:Tuple}\nfulltype(::Type{T}, ::Type{PS}, ubs::Tuple{Vararg{Bool}}=isparameterbounds(T, PS)) where {T, PS<:NamedTuple}\n\nGet the full type of type T with the type parameters replaced by those of PS.\n\nHere, ubs determines whether the new type parameter should be considered as the upper bound accordingly.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.rawtype","page":"Toolkit","title":"QuantumLattices.Toolkit.rawtype","text":"rawtype(::Type{T}) where T -> DataType/UnionAll\n\nGet the \"raw part\" of a type. That is, the type without all its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#Core.DataType","page":"Toolkit","title":"Core.DataType","text":"DataType <: Type{T}\n\nDataType represents explicitly declared types that have names, explicitly declared supertypes, and, optionally, parameters.  Every concrete value in the system is an instance of some DataType.\n\nExamples\n\njulia> typeof(Real)\nDataType\n\njulia> typeof(Int)\nDataType\n\njulia> struct Point\n           x::Int\n           y\n       end\n\njulia> typeof(Point)\nDataType\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Base.supertype","page":"Toolkit","title":"Base.supertype","text":"supertype(T::DataType)\n\nReturn the supertype of DataType T.\n\nExamples\n\njulia> supertype(Int32)\nSigned\n\n\n\n\n\nsupertype(T, termination::Symbol) -> DataType\n\nGet the supertype of T till termination.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For traits with type parameters:","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.hasparameter","page":"Toolkit","title":"QuantumLattices.Toolkit.hasparameter","text":"hasparameter(::Type{T}, name::Symbol) where T -> Bool\n\nFor type T, judge whether it has a type parameter specified by name.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.isparameterbound","page":"Toolkit","title":"QuantumLattices.Toolkit.isparameterbound","text":"isparameterbound(::Type{T}, i::Integer, D) where T -> Bool\nisparameterbound(::Type{T}, name::Symbol, D) where T -> Bool\n\nFor a type T, judge whether a type D should be considered as the upper bound of one of its type parameters.\n\nnote: Note\nThe default implementations of this function isisparameterbound(::Type{}, ::Val{}, ::Type{D}) where D = !isconcretetype(D)\nisparameterbound(::Type{}, ::Val{}, ::Any) = false\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.isparameterbounds","page":"Toolkit","title":"QuantumLattices.Toolkit.isparameterbounds","text":"isparameterbounds(::Type{T}, ::Type{PS}) where {T, PS<:Tuple} -> Tuple{Vararg{Bool}}\nisparameterbounds(::Type{T}, ::Type{PS}) where {T, PS<:NamedTuple} -> Tuple{Vararg{Bool}}\n\nFor a type T, judge whether the types specified by PS should be considered as the upper bounds of its corresponding type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parametercount","page":"Toolkit","title":"QuantumLattices.Toolkit.parametercount","text":"parametercount(::Type{T}) where T -> Int\n\nFor a type T, get the number of its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parametername","page":"Toolkit","title":"QuantumLattices.Toolkit.parametername","text":"parametername(::Type{T}, i::Integer) where T -> Symbol\n\nFor a type T, get the name of its ith type parameter.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parameternames","page":"Toolkit","title":"QuantumLattices.Toolkit.parameternames","text":"parameternames(::Type{T}) where T -> Tuple{Vararg{Symbol}}\n\nFor a type T, get the names of all its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parameterorder","page":"Toolkit","title":"QuantumLattices.Toolkit.parameterorder","text":"parameterorder(::Type{T}, name::Symbol) where T -> Int\n\nFor a type T, get the order of one of its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parameterpair","page":"Toolkit","title":"QuantumLattices.Toolkit.parameterpair","text":"parameterpair(::Type{T}, name::Symbol) where T\nparameterpair(::Type{T}, i::Integer) where T\n\nFor type T, get the name-type pair of one of its type parameters.\n\nThe result is stored in the type parameters of a Pair.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parameterpairs","page":"Toolkit","title":"QuantumLattices.Toolkit.parameterpairs","text":"parameterpairs(::Type{T}) where T\n\nFor a type T, get the name-type pairs of all its type parameters.\n\nThe return types are stored in the type parameters of a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parametertype","page":"Toolkit","title":"QuantumLattices.Toolkit.parametertype","text":"parametertype(::Type{T}, name::Symbol) where T\nparametertype(::Type{T}, i::Integer) where T\n\nFor a type T, get the type of one of its type parameters.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.parametertypes","page":"Toolkit","title":"QuantumLattices.Toolkit.parametertypes","text":"parametertypes(::Type{T}) where T\n\nFor a type T, get the types of all its type parameters.\n\nThe returned types are stored in the type parameters of a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.promoteparameters","page":"Toolkit","title":"QuantumLattices.Toolkit.promoteparameters","text":"promoteparameters(::Type{T‚ÇÅ}, ::Type{T‚ÇÇ}) where {T‚ÇÅ<:NamedTuple, T‚ÇÇ<:NamedTuple}\n\nPromote the types specified by two named tuples with the same names accordingly.\n\nThe result is stored in the type parameters of a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.reparameter","page":"Toolkit","title":"QuantumLattices.Toolkit.reparameter","text":"reparameter(::Type{T}, i::Integer, P, ub::Bool=isparameterbound(T, i, P)) where T\nreparameter(::Type{T}, name::Symbol, P, ub::Bool=isparameterbound(T, name, P)) where T\n\nFor a type T, replace the type of its ith type parameter with P. Here, ub determines whether P should be considered as the upper bound. \n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For traits with type contents:","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contentcount","page":"Toolkit","title":"QuantumLattices.Toolkit.contentcount","text":"contentcount(::Type{T}) where T -> Int\n\nFor a type T, get the number of its predefined contents.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contentname","page":"Toolkit","title":"QuantumLattices.Toolkit.contentname","text":"contentname(::Type{T}, i::Integer) where T -> Symbol\n\nFor a type T, get the name of its ith predefined content.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contentnames","page":"Toolkit","title":"QuantumLattices.Toolkit.contentnames","text":"contentnames(::Type{T}) where T -> Tuple{Vararg{Symbol}}\n\nFor a type T, define the names of its predefined contents.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contentorder","page":"Toolkit","title":"QuantumLattices.Toolkit.contentorder","text":"contentorder(::Type{T}, name::Symbol) where T -> Int\n\nFor a type T, get the position order of a predefined content by the name.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contenttype","page":"Toolkit","title":"QuantumLattices.Toolkit.contenttype","text":"contenttype(::Type{T}, name::Symbol) where T\ncontenttype(::Type{T}, ::Val{name}) where {T, name}\n\nFor a type T, get the type of a predefined content by the name.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.contenttypes","page":"Toolkit","title":"QuantumLattices.Toolkit.contenttypes","text":"contenttypes(::Type{T}) where T\n\nFor a type T, get the types of its predefined contents.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.getcontent","page":"Toolkit","title":"QuantumLattices.Toolkit.getcontent","text":"getcontent(m, i::Integer)\ngetcontent(m, name::Symbol)\ngetcontent(m, ::Val{name}) where name\n\nGet the value of the predefined content of m. \n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.hascontent","page":"Toolkit","title":"QuantumLattices.Toolkit.hascontent","text":"hascontent(::Type{T}, name::Symbol) where T -> Bool\n\nFor a type T, judge whether it has a predefined content specified by name.\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.dissolve","page":"Toolkit","title":"QuantumLattices.Toolkit.dissolve","text":"dissolve(m, f::Function=identity, args...; kwargs...) -> Tuple\n\nConvert m to a tuple by the function f applied elementally to its contents with the extra positional arguments (args) and keyword arguments (kwargs). \n\nTo each content of m, the underlying interface of the dissolve function when f is applied is as follows:\n\ndissolve(m, Val(name), f, args...; kwargs...)\n\nHere, name is the name of the corresponding content of m.\n\nBasically, the rule of how f operates on each field of m can be overridden by redefining the above dissolve function.\n\nnote: Note\nThe default dissolve function ignores the operation of function f and just return the content value of m.\n\n\n\n\n\ndissolve(m, ::Val{name}, f::Function, args...; kwargs...) where name\n\nDissolve the content specified by name of m by the function f applied with the extra positional arguments (args) and keyword arguments (kwargs).\n\n\n\n\n\n","category":"function"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"For traits with type operations:","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.efficientoperations","page":"Toolkit","title":"QuantumLattices.Toolkit.efficientoperations","text":"efficientoperations\n\nIndicate that the efficient operations, i.e. \"==\"/\"isequal\", \"<\"/\"isless\" or \"replace\", will be used.\n\n\n\n\n\n","category":"constant"},{"location":"man/Toolkit/#Composite-structures","page":"Toolkit","title":"Composite structures","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"In principle, Julia is not an object-oriented programming language. For example, only abstract types can be inherited so that subtype cannot inherit fields from their parents. Therefore, Julia prefers composition over inheritance. However, to make a new concrete type behaves much alike another one, tedious repetitions of redefining the generic interfaces are usually not avoidable, especially for the basic types in Julia base. In this module, we implement to such composited types, CompositeVector and CompositeDict, for the sake of future usages.","category":"page"},{"location":"man/Toolkit/#CompositeVector","page":"Toolkit","title":"CompositeVector","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A composite vector can be considered as a vector that is implemented by including a concrete subtype of AbstractVector as its data attribute, and it itself is a subtype of AbstractVector.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To take full advantages of the Julia base, the following interfaces are redefined:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"inquiry of info: size, length\ncomparison between objects: ==, isequal\nobtainment of old elements: getindex\noperation of old elements: setindex!\naddition of new elements: push!, pushfirst!, insert!, append!, prepend!\nremoval of old elements: splice!, deleteat!, pop!, popfirst!, empty!\nconstruction of new objects: empty, reverse, similar\niteration: iterate, keys, values, pairs","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Note that arithmetic operations and logical operations excluding == and isequal are not supported.","category":"page"},{"location":"man/Toolkit/#CompositeDict","page":"Toolkit","title":"CompositeDict","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A composite dict can be considered as a dict that is implemented by including a concrete subtype of AbstractDict as its data attribute and it itself is a subtype of AbstractDict.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"To take full advantages of the Julia base, the following interfaces are redefined:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"inquiry of info: isempty, length, haskey, in\ncomparison between objects: ==, isequal\nobtainment of old elements: get, getkey, getindex\noperation and addition of elements: push!, get!, setindex!\nremoval of old elements: pop!, delete!, empty!\nconstruction of new objects: merge, empty\niteration: iterate, keys, values, pairs","category":"page"},{"location":"man/Toolkit/#Manual-3","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.CompositeDict","page":"Toolkit","title":"QuantumLattices.Toolkit.CompositeDict","text":"CompositeDict{K, V}\n\nA composite dict can be considered as a dict that is implemented by including a concrete subtype of AbstractDict as its data attribute.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.CompositeVector","page":"Toolkit","title":"QuantumLattices.Toolkit.CompositeVector","text":"CompositeVector{T}\n\nA composite vector can be considered as a vector that is implemented by including a concrete subtype of AbstractVector as its data attribute.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#Vector-spaces","page":"Toolkit","title":"Vector spaces","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"A vector space is a linear space, in which the addition of vectors and multiplication of a vector by a scalar are defined.","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Vector spaces are frequently encountered in physics, e.g. the Hilbert space in quantum mechanics. In this submodule, we only implement those with finite dimensions. We want to remark that in our implementation, a vector space is a subtype of an abstract vector, therefore, the bases always possess a order, which means, two vector spaces are not considered to be equal to each other even if their corresponding actual mathematical spaces are the same but the orders of the bases are different.","category":"page"},{"location":"man/Toolkit/#VectorSpace","page":"Toolkit","title":"VectorSpace","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"VectorSpace{B} is the abstraction of a vector space, which has only one type parameter:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"B<:Any: the type of the bases of the vector space","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Basically, a subtype should implement the following 2 methods:","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Base.length(vs::VectorSpace) -> Int\nGet the dimension of a vector space\nBase.getindex(vs::VectorSpace{B}, i::Int)  where B -> B\nGet the ith basis of a vector space","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Other features include","category":"page"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"comparison: == and isequal\niteration: iterate\ninquiry: size and in\nsearch: searchsortedfirst","category":"page"},{"location":"man/Toolkit/#Manual-4","page":"Toolkit","title":"Manual","text":"","category":"section"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Predefined types of vector spaces:","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpace","text":"VectorSpace{B} <: AbstractVector{B}\n\nAbstract vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.DirectProductedVectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.DirectProductedVectorSpace","text":"DirectProductedVectorSpace{Order, B, T<:Tuple} <: VectorSpace{B}\n\nA simple direct producted vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.DirectSummedVectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.DirectSummedVectorSpace","text":"DirectSummedVectorSpace{B, T<:Tuple} <: VectorSpace{B}\n\nA simple direct summed vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.ZippedVectorSpace","page":"Toolkit","title":"QuantumLattices.Toolkit.ZippedVectorSpace","text":"ZippedVectorSpace{B, T<:Tuple} <: VectorSpace{B}\n\nA simple zipped vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/","page":"Toolkit","title":"Toolkit","text":"Predefined types of vector space style:","category":"page"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceStyle","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceStyle","text":"VectorSpaceStyle\n\nStyle of a concrete type of vector space.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceGeneral","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceGeneral","text":"VectorSpaceGeneral <: VectorSpaceStyle\n\nDefault vector space style.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceEnumerative","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceEnumerative","text":"VectorSpaceEnumerative <: VectorSpaceStyle\n\nEnumerative vector space style, which indicates that the vector space has a predefined content named contents that contains all its bases.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceDirectProducted","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceDirectProducted","text":"VectorSpaceDirectProducted{Order} <: VectorSpaceStyle\n\nVector space style which indicates that a vector space is the direct product of its sub-components.\n\nThe type parameter Order must be either :forward or :backward:\n\n:forward: the direct product iterates over the first sub-component first like a Julia array;\n:backward: the direct product iterates over the last sub-component first like a C/C++ array.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceDirectSummed","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceDirectSummed","text":"VectorSpaceDirectSummed <: VectorSpaceStyle\n\nVector space style which indicates that a vector space is the direct sum of its sub-components.\n\n\n\n\n\n","category":"type"},{"location":"man/Toolkit/#QuantumLattices.Toolkit.VectorSpaceZipped","page":"Toolkit","title":"QuantumLattices.Toolkit.VectorSpaceZipped","text":"VectorSpaceZipped <: VectorSpaceStyle\n\nVector space style which indicates that a vector space is the zip of its sub-components.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#Quantum-numbers","page":"Quantum numbers","title":"Quantum numbers","text":"","category":"section"},{"location":"man/QuantumNumbers/","page":"Quantum numbers","title":"Quantum numbers","text":"Quantum numbers can be considered as the conserved labels for the bases of a Hilbert space when a quantum system hosts some symmetries. Here we only implement Abelian quantum numbers because non-Abelian ones are far more complicated yet much less used.","category":"page"},{"location":"man/QuantumNumbers/#AbelianQuantumNumber","page":"Quantum numbers","title":"AbelianQuantumNumber","text":"","category":"section"},{"location":"man/QuantumNumbers/#RepresentationSpace","page":"Quantum numbers","title":"RepresentationSpace","text":"","category":"section"},{"location":"man/QuantumNumbers/#qnmanual","page":"Quantum numbers","title":"Manual","text":"","category":"section"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.Abelian","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.Abelian","text":"const Abelian = AbelianQuantumNumber\n\nType alias for AbelianQuantumNumber.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianGradedSpace","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianGradedSpace","text":"AbelianGradedSpace(quantumnumbers::AbstractVector{<:AbelianQuantumNumber}, dimensions::AbstractVector{<:Integer}, dual::Bool=false; ordercheck::Bool=false, duplicatecheck::Bool=false, degeneracycheck::Bool=false)\n\nConstruct an Abelian graded space.\n\nHere:\n\nquantumnumbers specifies the Abelian quantum numbers labeling the irreducible representations of the corresponding Abelian group which must be sorted in the ascending order. Such an ordering should be manually guaranteed by the user. When and only when the keyword argument ordercheck is true, the constructor will check whether this condition is satisfied and raise an error if it doesn't. Besides, quantumnumbers must not contain duplicate Abelian quantum numbers, manually guaranteed by the user as well. This condition can be checked when and only when both ordercheck==true and duplicatecheck==true. An error will be raised if this check fails.\ndimensions specifies the degenerate dimensions of the corresponding Abelian quantum numbers. Apparently, each degenerate dimension must be positive, which should also be manually guaranteed by the user. When and only when the keyword argument degeneracycheck is true, the constructor will check whether this condition is satisfied and raise an error if it doesn't.\ndual specifies whether the graded space is the dual representation of the corresponding Abelian group, which roughly speaking, can be viewed as the direction of the arrow of the Abelian quantum numbers labeling the irreducible representations. We assume dual==true corresponds to the in-arrow and dual==false corresponds to the out-arrow.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianGradedSpace-2","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianGradedSpace","text":"AbelianGradedSpace{QN<:AbelianQuantumNumber} <: RepresentationSpace{QN}\n\nA quantum representation space of an Abelian group that has been decomposed into the direct sum of its irreducible representations.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianGradedSpace-Tuple{Any}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianGradedSpace","text":"AbelianGradedSpace(pairs; dual::Bool=false)\nAbelianGradedSpace(pairs::Pair...; dual::Bool=false)\nAbelianGradedSpace{QN}(pairs; dual::Bool=false) where {QN<:AbelianQuantumNumber}\nAbelianGradedSpace{QN}(pairs::Pair...; dual::Bool=false) where {QN<:AbelianQuantumNumber}\n\nConstruct an Abelian graded space.\n\nIn this function, the Abelian quantum numbers will be sorted automatically, therefore, their orders need not be worried. Duplicate and dimension checks of the quantum numbers are also carried out and errors will be raised if either such checks fails.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianGradedSpaceProd","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianGradedSpaceProd","text":"AbelianGradedSpaceProd{N, QN<:AbelianQuantumNumber} <: CompositeAbelianGradedSpace{N, QN}\n\nDirect product of Abelian graded spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianGradedSpaceSum","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianGradedSpaceSum","text":"AbelianGradedSpaceSum{N, QN<:AbelianQuantumNumber} <: CompositeAbelianGradedSpace{N, QN}\n\nDirect sum of Abelian graded spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianQuantumNumber","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianQuantumNumber","text":"AbelianQuantumNumber\n\nAbstract type of Abelian quantum numbers.\n\nAn Abelian quantum number is the label of a irreducible representation of an Abelian group acted on a quantum representation space. \n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianQuantumNumberProd","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianQuantumNumberProd","text":"AbelianQuantumNumberProd{T<:Tuple{Vararg{SimpleAbelianQuantumNumber}}} <: AbelianQuantumNumber\n\nDeligne tensor product of simple Abelian quantum numbers.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianQuantumNumberProd-Tuple{Vararg{SimpleAbelianQuantumNumber}}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianQuantumNumberProd","text":"AbelianQuantumNumberProd(contents::SimpleAbelianQuantumNumber...)\nAbelianQuantumNumberProd(contents::Tuple{Vararg{SimpleAbelianQuantumNumber}})\n\nConstruct a Deligne tensor product of simple Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.AbelianQuantumNumberProd-Union{NTuple{N, Number}, Tuple{T}, Tuple{N}} where {N, T<:NTuple{N, SimpleAbelianQuantumNumber}}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.AbelianQuantumNumberProd","text":"AbelianQuantumNumberProd{T}(vs::Vararg{Number, N}) where {N, T<:NTuple{N, SimpleAbelianQuantumNumber}}\nAbelianQuantumNumberProd{T}(vs::NTuple{N, Number}) where {N, T<:NTuple{N, SimpleAbelianQuantumNumber}}\n\nConstruct a Deligne tensor product of simple Abelian quantum numbers by their values.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.CompositeAbelianGradedSpace","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.CompositeAbelianGradedSpace","text":"CompositeAbelianGradedSpace{N, QN<:AbelianQuantumNumber} <: RepresentationSpace{QN}\n\nAbstract type of composite Abelian graded spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.Graded","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.Graded","text":"const Graded = AbelianGradedSpace\n\nType alias for AbelianGradedSpace.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.Momenta","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.Momenta","text":"Momenta{P<:ùïÇ} <: RepresentationSpace{P}\n\nComplete allowed set of momenta.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.RepresentationSpace","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.RepresentationSpace","text":"RepresentationSpace{QN<:AbelianQuantumNumber} <: VectorSpace{QN}\n\nAbstract type of quantum representation spaces of Abelian groups.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.SimpleAbelianQuantumNumber","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.SimpleAbelianQuantumNumber","text":"SimpleAbelianQuantumNumber <: AbelianQuantumNumber\n\nAbstract type of simple Abelian quantum numbers. That is, it contains only one label.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.‚Ñï","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.‚Ñï","text":"‚Ñï <: <: ùïå‚ÇÅ\n\nConcrete Abelian quantum number of the particle number.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.‚Ñ§","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.‚Ñ§","text":"‚Ñ§{N} <: SimpleAbelianQuantumNumber\n\n‚Ñ§‚Çô quantum numbers.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.‚Ñ§‚ÇÅ","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.‚Ñ§‚ÇÅ","text":"const ‚Ñ§‚ÇÅ = ‚Ñ§{1}\nconst ‚Ñ§‚ÇÇ = ‚Ñ§{2}\nconst ‚Ñ§‚ÇÉ = ‚Ñ§{3}\nconst ‚Ñ§‚ÇÑ = ‚Ñ§{4}\n\nAlias for ‚Ñ§‚ÇÅ/‚Ñ§‚ÇÇ/‚Ñ§‚ÇÉ/‚Ñ§‚ÇÑ quantum numbers.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.ùïÇ","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.ùïÇ","text":"const ùïÇ = AbelianQuantumNumberProd{<:Tuple{Vararg{‚Ñ§}}}\nconst ùïÇ¬π{N} = AbelianQuantumNumberProd{Tuple{‚Ñ§{N}}}\nconst ùïÇ¬≤{N‚ÇÅ, N‚ÇÇ} = AbelianQuantumNumberProd{Tuple{‚Ñ§{N‚ÇÅ}, ‚Ñ§{N‚ÇÇ}}}\nconst ùïÇ¬≥{N‚ÇÅ, N‚ÇÇ, N‚ÇÉ} = AbelianQuantumNumberProd{Tuple{‚Ñ§{N‚ÇÅ}, ‚Ñ§{N‚ÇÇ}, ‚Ñ§{N‚ÇÉ}}}\n\nType alias for the Abelian quantum numbers of 1d, 2d and 3d momentum.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.ùïÇ¬π-Union{Tuple{Integer}, Tuple{N}} where N","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.ùïÇ¬π","text":"ùïÇ¬π{N}(k::Integer) where N\nùïÇ¬≤{N}(k‚ÇÅ::Integer, k‚ÇÇ::Integer) where N\nùïÇ¬≤{N‚ÇÅ, N‚ÇÇ}(k‚ÇÅ::Integer, k‚ÇÇ::Integer) where {N‚ÇÅ, N‚ÇÇ}\nùïÇ¬≥{N}(k‚ÇÅ::Integer, k‚ÇÇ::Integer, k‚ÇÉ::Integer) where N\nùïÇ¬≥{N‚ÇÅ, N‚ÇÇ, N‚ÇÉ}(k‚ÇÅ::Integer, k‚ÇÇ::Integer, k‚ÇÉ::Integer) where {N‚ÇÅ, N‚ÇÇ, N‚ÇÉ}\n\nConstruct 1d, 2d and 3d momentum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.ùïä·∂ª","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.ùïä·∂ª","text":"ùïä·∂ª <: ùïå‚ÇÅ\n\nConcrete Abelian quantum number of the z-component of a spin.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.ùïå‚ÇÅ","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.ùïå‚ÇÅ","text":"ùïå‚ÇÅ <: SimpleAbelianQuantumNumber\n\nAbstract type of ùïå‚ÇÅ quantum numbers.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumNumbers/#Base.:+-Tuple{AbelianQuantumNumber}","page":"Quantum numbers","title":"Base.:+","text":"+(qn::AbelianQuantumNumber) -> typeof(qn)\n\nOverloaded + operator for AbelianQuantumNumber.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:+-Union{Tuple{QN}, Tuple{QN, QN, Vararg{QN}}} where QN<:AbelianQuantumNumberProd","page":"Quantum numbers","title":"Base.:+","text":"+(qn‚ÇÅ::QN, qn‚ÇÇ::QN, qns::QN...) where {QN<:AbelianQuantumNumberProd} -> QN\n\nOverloaded + operator for AbelianQuantumNumberProd.\n\nnote: Note\nTo ensure type stability, two AbelianQuantumNumberProd can be added together if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:+-Union{Tuple{QN}, Tuple{QN, QN, Vararg{QN}}} where QN<:SimpleAbelianQuantumNumber","page":"Quantum numbers","title":"Base.:+","text":"+(qn‚ÇÅ::QN, qn‚ÇÇ::QN, qns::QN...) where {QN<:SimpleAbelianQuantumNumber} -> QN\n\nOverloaded + operator for SimpleAbelianQuantumNumber.\n\nnote: Note\nTo ensure type stability, two SimpleAbelianQuantumNumber can be added together if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:--Tuple{AbelianQuantumNumberProd}","page":"Quantum numbers","title":"Base.:-","text":"-(qn::AbelianQuantumNumberProd) -> typeof(qn)\n-(qn‚ÇÅ::QN, qn‚ÇÇ::QN) where {QN<:AbelianQuantumNumberProd} -> QN\n\nOverloaded - operator for AbelianQuantumNumberProd.\n\nnote: Note\nTo ensure type stability, a AbelianQuantumNumberProd can be subtracted by another AbelianQuantumNumberProd if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.:--Tuple{SimpleAbelianQuantumNumber}","page":"Quantum numbers","title":"Base.:-","text":"-(qn::SimpleAbelianQuantumNumber) -> typeof(qn)\n-(qn‚ÇÅ::QN, qn‚ÇÇ::QN) where {QN<:SimpleAbelianQuantumNumber} -> QN\n\nOverloaded - operator for SimpleAbelianQuantumNumber.\n\nnote: Note\nTo ensure type stability, a SimpleAbelianQuantumNumber can be subtracted by another SimpleAbelianQuantumNumber if and only if they are of the same type.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.adjoint-Tuple{AbelianGradedSpace}","page":"Quantum numbers","title":"Base.adjoint","text":"adjoint(gs::AbelianGradedSpace) -> typeof(gs)\n\nGet the dual of an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.cumsum-Tuple{RepresentationSpace, Union{Integer, CartesianIndex}}","page":"Quantum numbers","title":"Base.cumsum","text":"cumsum(rs::RepresentationSpace, i::Union{Integer, CartesianIndex}) -> Int\n\nGet the accumulative degenerate dimension up to the ith Abelian quantum number contained in a representation space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.cumsum-Union{Tuple{QN}, Tuple{AbelianGradedSpace{QN}, QN}} where QN<:AbelianQuantumNumber","page":"Quantum numbers","title":"Base.cumsum","text":"cumsum(gs::AbelianGradedSpace{QN}, qn::QN) where {QN<:AbelianQuantumNumber} -> Int\n\nGet the accumulative dimension of an Abelian graded space up to a certain Abelian quantum number contained in an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.getindex-Tuple{AbelianGradedSpace, AbstractVector{<:Integer}}","page":"Quantum numbers","title":"Base.getindex","text":"getindex(gs::AbelianGradedSpace, indexes::AbstractVector{<:Integer}) -> typeof(gs)\ngetindex(gs::AbelianGradedSpace{QN}, quantumnumbers::AbstractVector{QN}) where {QN<:AbelianQuantumNumber} -> AbelianGradedSpace{QN}\n\nGet a subset of an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.getindex-Tuple{AbelianQuantumNumberProd, Integer}","page":"Quantum numbers","title":"Base.getindex","text":"getindex(qn::AbelianQuantumNumberProd, i::Integer) -> SimpleAbelianQuantumNumber\n\nGet the ith simple Abelian quantum number in a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.getindex-Union{Tuple{T}, Tuple{Type{AbelianQuantumNumber}, Type{T}}} where T<:AbelianQuantumNumber","page":"Quantum numbers","title":"Base.getindex","text":"getindex(::Type{Abelian}, ::Type{T}) where {T<:AbelianQuantumNumber} -> Type{T}\n\nOverloaded [] for Abelian, i.e., the support of syntax Abelian[T] where T<:AbelianQuantumNumber, which is helpful for the construction of tensor producted Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.in-Union{Tuple{QN}, Tuple{QN, AbelianGradedSpace{QN}}} where QN<:AbelianQuantumNumber","page":"Quantum numbers","title":"Base.in","text":"in(qn::QN, gs::AbelianGradedSpace{QN}) where {QN<:AbelianQuantumNumber} -> Bool\n\nCheck whether an Abelian quantum number is contained in an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.inv","page":"Quantum numbers","title":"Base.inv","text":"inv(qn::AbelianQuantumNumber, bool::Bool=true) -> typeof(qn)\n\nGet the inverse of an Abelian quantum number qn if bool is true. Otherwise, return qn itself.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumNumbers/#Base.length-Tuple{AbelianGradedSpace}","page":"Quantum numbers","title":"Base.length","text":"length(gs::AbelianGradedSpace) -> Int\n\nGet the number of inequivalent irreducible representations (i.e., the Abelian quantum numbers) of an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.length-Tuple{AbelianQuantumNumberProd}","page":"Quantum numbers","title":"Base.length","text":"length(qn::AbelianQuantumNumberProd) -> Int\n\nGet the length of a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.merge-Tuple{AbelianGradedSpaceProd}","page":"Quantum numbers","title":"Base.merge","text":"merge(rs::AbelianGradedSpaceProd) -> Tuple{AbelianGradedSpace{eltype(rs)}, Dict{eltype(rs), Vector{NTuple{rank(rs), eltype(rs)}}}}\n\nGet the decomposition of the direct product of several Abelian graded spaces and its corresponding fusion processes.\n\nFor a set of Abelian graded spaces (gs‚ÇÅ, gs‚ÇÇ, ...), their direct product space can contain several equivalent irreducible representations because for different sets of Abelian quantum numbers (qn‚ÇÅ, qn‚ÇÇ, ...) where qn·µ¢‚ààgs·µ¢, the fusion, i.e., ‚äó(qn‚ÇÅ, qn‚ÇÇ, ...) may give the same result qn. This function returns the decomposition of the direct product of (gs‚ÇÅ, gs‚ÇÇ, ...) as well as all the fusion processes of each quantum number contained in the decomposition.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.pairs-Tuple{RepresentationSpace, typeof(dimension)}","page":"Quantum numbers","title":"Base.pairs","text":"pairs(rs::RepresentationSpace, ::typeof(dimension)) -> RepresentationSpacePairs\npairs(rs::RepresentationSpace, ::typeof(range)) -> RepresentationSpacePairs\n\nReturn an iterator that iterates over the pairs of the Abelian quantum numbers and their corresponding (slices of the) degenerate dimensions contained in a representation space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.range-Tuple{AbelianGradedSpace, CartesianIndex}","page":"Quantum numbers","title":"Base.range","text":"range(gs::AbelianGradedSpace, qn::CartesianIndex) -> UnitRange{Int}\nrange(gs::AbelianGradedSpace{QN}, qn::QN) where {QN<:AbelianQuantumNumber} -> UnitRange{Int}\n\nGet the slice of the degenerate dimension of an Abelian quantum number contained in an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.range-Tuple{AbelianGradedSpaceProd, CartesianIndex}","page":"Quantum numbers","title":"Base.range","text":"range(rs::AbelianGradedSpaceProd, i::CartesianIndex) -> AbstractVector{Int}\n\nGet the slice of the degenerate dimension of the ith Abelian quantum number in the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.range-Tuple{AbelianGradedSpaceSum, CartesianIndex}","page":"Quantum numbers","title":"Base.range","text":"range(rs::AbelianGradedSpaceSum, i::CartesianIndex) -> UnitRange{Int}\n\nGet the slice of the degenerate dimension of the ith Abelian quantum number in the direct sum of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.range-Tuple{RepresentationSpace, Integer}","page":"Quantum numbers","title":"Base.range","text":"range(rs::RepresentationSpace, i::Integer)\n\nGet the slice of the degenerate dimension of the ith Abelian quantum number contained in a representation space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.range-Union{Tuple{QN}, Tuple{N}, Tuple{AbelianGradedSpaceProd{N, QN}, NTuple{N, QN}}} where {N, QN<:AbelianQuantumNumber}","page":"Quantum numbers","title":"Base.range","text":"range(rs::AbelianGradedSpaceProd{N, QN}, qns::NTuple{N, QN}) where {N, QN<:AbelianQuantumNumber} -> AbstractVector{Int}\n\nGet the slice of the degenerate dimension of the Abelian quantum number fused by qns in the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.split-Union{Tuple{QN}, Tuple{N}, Tuple{QN, AbelianGradedSpaceProd{N, QN}}} where {N, QN<:AbelianQuantumNumber}","page":"Quantum numbers","title":"Base.split","text":"split(target::QN, rs::AbelianGradedSpaceProd{N, QN}; nmax::Real=20) where {N, QN<:AbelianQuantumNumber} -> Set{NTuple{N, QN}}\n\nFind a set of splittings of the target Abelian quantum number with respect to the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.values-Tuple{AbelianQuantumNumberProd}","page":"Quantum numbers","title":"Base.values","text":"values(qn::AbelianQuantumNumberProd) -> NTuple{rank(qn), Number}\n\nGet the values of the simple Abelian quantum numbers in a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.values-Tuple{SimpleAbelianQuantumNumber}","page":"Quantum numbers","title":"Base.values","text":"values(qn::SimpleAbelianQuantumNumber) -> Tuple{Number}\n\nGet the value of a simple Abelian quantum number and return it as the sole element of a tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#Base.zero-Tuple{AbelianQuantumNumber}","page":"Quantum numbers","title":"Base.zero","text":"zero(qn::AbelianQuantumNumber) -> typeof(qn)\nzero(::Type{QN}) where {QN<:AbelianQuantumNumber} -> QN\n\nGet the zero Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#LinearAlgebra.rank-Tuple{AbelianQuantumNumberProd}","page":"Quantum numbers","title":"LinearAlgebra.rank","text":"rank(qn::AbelianQuantumNumberProd) -> Int\nrank(::Type{<:AbelianQuantumNumberProd}) -> Int\n\nGet the rank of a Deligne tensor product of simple Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#LinearAlgebra.rank-Tuple{QuantumLattices.QuantumNumbers.CompositeAbelianGradedSpace}","page":"Quantum numbers","title":"LinearAlgebra.rank","text":"rank(rs::CompositeAbelianGradedSpace) -> Int\nrank(::Type{<:CompositeAbelianGradedSpace{N}}) where N -> Int\n\nGet the number of Abelian graded spaces in the direct sum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.:‚äï-Tuple{AbelianGradedSpace, Vararg{AbelianGradedSpace}}","page":"Quantum numbers","title":"QuantumLattices.:‚äï","text":"‚äï(gs::AbelianGradedSpace, gses::AbelianGradedSpace...) -> AbelianGradedSpaceSum\n‚äï(gs::AbelianGradedSpace, rs::AbelianGradedSpaceSum) -> AbelianGradedSpaceSum\n‚äï(rs::AbelianGradedSpaceSum, gs::AbelianGradedSpace) -> AbelianGradedSpaceSum\n‚äï(rs‚ÇÅ::AbelianGradedSpaceSum, rs‚ÇÇ::AbelianGradedSpaceSum) -> AbelianGradedSpaceSum\n\nGet the direct sum of some Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.:‚äó-Tuple{AbelianGradedSpace, Vararg{AbelianGradedSpace}}","page":"Quantum numbers","title":"QuantumLattices.:‚äó","text":"‚äó(gs::AbelianGradedSpace, gses::AbelianGradedSpace...) -> AbelianGradedSpaceProd\n‚äó(gs::AbelianGradedSpace, rs::AbelianGradedSpaceProd) -> AbelianGradedSpaceProd\n‚äó(rs::AbelianGradedSpaceProd, gs::AbelianGradedSpace) -> AbelianGradedSpaceProd\n‚äó(rs‚ÇÅ::AbelianGradedSpaceProd, rs‚ÇÇ::AbelianGradedSpaceProd) -> AbelianGradedSpaceProd\n\nGet the direct product of some Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.:‚äó-Tuple{AbelianQuantumNumber, Vararg{AbelianQuantumNumber}}","page":"Quantum numbers","title":"QuantumLattices.:‚äó","text":"‚äó(qn::AbelianQuantumNumber, qns::AbelianQuantumNumber...) -> eltype(qns)\n\nGet the direct product of some AbelianQuantumNumbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.:‚ä†-Tuple{SimpleAbelianQuantumNumber, Vararg{SimpleAbelianQuantumNumber}}","page":"Quantum numbers","title":"QuantumLattices.:‚ä†","text":"‚ä†(qn::SimpleAbelianQuantumNumber, qns::SimpleAbelianQuantumNumber...) -> AbelianQuantumNumberProd\n‚ä†(qn‚ÇÅ::SimpleAbelianQuantumNumber, qn‚ÇÇ::AbelianQuantumNumberProd) -> AbelianQuantumNumberProd\n‚ä†(qn‚ÇÅ::AbelianQuantumNumberProd, qn‚ÇÇ::SimpleAbelianQuantumNumber) -> AbelianQuantumNumberProd\n‚ä†(qn‚ÇÅ::AbelianQuantumNumberProd, qn‚ÇÇ::AbelianQuantumNumberProd) -> AbelianQuantumNumberProd\n\nDeligne tensor product of Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.:‚ä†-Tuple{Type{<:SimpleAbelianQuantumNumber}, Vararg{Type{<:SimpleAbelianQuantumNumber}}}","page":"Quantum numbers","title":"QuantumLattices.:‚ä†","text":"‚ä†(QN::Type{<:SimpleAbelianQuantumNumber}, QNS::Type{<:SimpleAbelianQuantumNumber}...) -> Type{AbelianQuantumNumberProd{Tuple{QN, QNS...}}}\n‚ä†(::Type{QN}, ::Type{AbelianQuantumNumberProd{T}}) where {QN<:SimpleAbelianQuantumNumber, T<:Tuple{Vararg{SimpleAbelianQuantumNumber}}} -> Type{AbelianQuantumNumberProd{Tuple{QN, fieldtypes(T)...}}}\n‚ä†(::Type{AbelianQuantumNumberProd{T}}, ::Type{QN}) where {T<:Tuple{Vararg{SimpleAbelianQuantumNumber}}, QN<:SimpleAbelianQuantumNumber} -> Type{AbelianQuantumNumberProd{Tuple{fieldtypes(T)...}, QN}}\n‚ä†(::Type{AbelianQuantumNumberProd{T‚ÇÅ}}, ::Type{AbelianQuantumNumberProd{T‚ÇÇ}}) where {T‚ÇÅ<:Tuple{Vararg{SimpleAbelianQuantumNumber}}, T‚ÇÇ<:Tuple{Vararg{SimpleAbelianQuantumNumber}}} -> Type{AbelianQuantumNumberProd{Tuple{fieldtypes(T‚ÇÅ)..., fieldtypes(T‚ÇÇ)...}}}\n\nDeligne tensor product of Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.findindex-Tuple{Integer, AbelianGradedSpace, Integer}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.findindex","text":"findindex(position::Integer, gs::AbelianGradedSpace, guess::Integer) -> Int\n\nFind the index of an Abelian quantum number in an Abelian graded space beginning at guess whose position in the complete dimension range is position.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.period-Tuple{AbelianQuantumNumberProd, Integer}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.period","text":"period(qn::AbelianQuantumNumberProd, i::Integer) -> Number\nperiod(::Type{AbelianQuantumNumberProd{T}}, i::Integer) where {T<:Tuple{Vararg{SimpleAbelianQuantumNumber}}} -> Number\n\nGet the period of the ith simple Abelian number contained in a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.period-Tuple{SimpleAbelianQuantumNumber}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.period","text":"period(qn::SimpleAbelianQuantumNumber) -> Number\nperiod(::Type{QN}) where {QN<:SimpleAbelianQuantumNumber} -> Number\n\nGet the period of a simple Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.periods-Tuple{AbelianQuantumNumber}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.periods","text":"periods(qn::AbelianQuantumNumber) -> Tuple{Vararg{Number}}\nperiods(::Type{QN}) where {QN<:AbelianQuantumNumber} -> Tuple{Vararg{Number}}\n\nGet the periods of Abelian quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.regularize!-Tuple{Vector{<:AbelianQuantumNumber}, Vector{Int64}}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.regularize!","text":"regularize!(quantumnumbers::Vector{<:AbelianQuantumNumber}, dimensions::Vector{Int}; check::Bool=false) -> Tuple{typeof(quantumnumbers), typeof(dimensions), Vector{Int}}\n\nIn place regularization of the input Abelian quantum numbers and their corresponding degenerate dimensions.\n\nAfter the regularization, the Abelian quantum numbers will be sorted in the ascending order and duplicates will be merged together. The degenerate dimensions will be processed accordingly. When check is true, this function also check whether all input degenerate dimensions are positive. The regularized Abelian quantum numbers and degenerate dimensions, as well as the permutation vector that sorts the input Abelian quantum numbers, will be returned. \n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.QuantumNumbers.regularize-Tuple{AbstractVector{<:AbelianQuantumNumber}, AbstractVector{<:Integer}}","page":"Quantum numbers","title":"QuantumLattices.QuantumNumbers.regularize","text":"regularize(quantumnumbers::AbstractVector{<:AbelianQuantumNumber}, dimension::AbstractVector{<:Integer}; check::Bool=false) -> Tuple{Vector{eltype(quantumnumbers)}, Vector{Int}, Vector{Int}}\n\nRegularize of the input Abelian quantum numbers and their corresponding degenerate dimensions.\n\nSee regularize!.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.decompose-Tuple{QuantumLattices.QuantumNumbers.CompositeAbelianGradedSpace}","page":"Quantum numbers","title":"QuantumLattices.decompose","text":"decompose(rs::CompositeAbelianGradedSpace; expand::Bool=true) -> Tuple{AbelianGradedSpace{eltype(rs)}, Vector{Int}}\n\nDecompose a composite of several Abelian graded spaces to the canonical one.\n\nWhen expand is false, the corresponding permutation vector that sorts the Abelian quantum numbers will be returned as well. When expand is true, the expanded dimension indexes of the permutation vector that sorts the Abelian quantum numbers will be returned as well.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Tuple{AbelianGradedSpace, CartesianIndex}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(gs::AbelianGradedSpace, qn::CartesianIndex) -> Int\ndimension(gs::AbelianGradedSpace{QN}, qn::QN) where {QN<:AbelianQuantumNumber} -> Int\n\nGet the degenerate dimension of an Abelian quantum number contained in an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Tuple{AbelianGradedSpaceProd, CartesianIndex}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceProd, i::CartesianIndex) -> Int\n\nGet the degenerate dimension of the ith Abelian quantum number in the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Tuple{AbelianGradedSpaceProd}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceProd) -> Int\n\nGet the total dimension of the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Tuple{AbelianGradedSpaceSum, CartesianIndex}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceSum, i::CartesianIndex) -> Int\n\nGet the degenerate dimension of the ith Abelian quantum number in the direct sum of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Tuple{AbelianGradedSpaceSum}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceSum) -> Int\n\nGet the total dimension of the direct sum of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Tuple{AbelianGradedSpace}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(gs::AbelianGradedSpace) -> Int\n\nGet the total dimension of an Abelian graded space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Tuple{RepresentationSpace, Integer}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::RepresentationSpace, i::Integer) -> Int\n\nGet the degenerate dimension of the ith Abelian quantum number contained in a representation space.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.dimension-Union{Tuple{QN}, Tuple{N}, Tuple{AbelianGradedSpaceProd{N, QN}, NTuple{N, QN}}} where {N, QN<:AbelianQuantumNumber}","page":"Quantum numbers","title":"QuantumLattices.dimension","text":"dimension(rs::AbelianGradedSpaceProd{N, QN}, qns::NTuple{N, QN}) where {N, QN<:AbelianQuantumNumber} -> Int\n\nGet the degenerate dimension of the Abelian quantum number fused by qns in the direct product of several Abelian graded spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.value-Tuple{AbelianQuantumNumberProd, Integer}","page":"Quantum numbers","title":"QuantumLattices.value","text":"value(qn::AbelianQuantumNumberProd, i::Integer) -> Number\n\nGet the value of the ith simple Abelian quantum number in a Deligne tensor product.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumNumbers/#QuantumLattices.value-Tuple{SimpleAbelianQuantumNumber}","page":"Quantum numbers","title":"QuantumLattices.value","text":"value(qn::SimpleAbelianQuantumNumber) -> Number\n\nGet the value of a simple Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#CouplingsAmongDifferentDegreesOfFreedom","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Now we arrive at the final step toward the complete description of a quantum lattice system, i.e., the terms that represent the couplings among different degrees of freedom.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Ingredients-of-terms-in-Hamiltonians","page":"Couplings among different degrees of freedom","title":"Ingredients of terms in Hamiltonians","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"In this package, the type Term is the representation of a term in lattice Hamiltonians.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As is well-known, different quantum lattice models have different terms. For example, the Hubbard model consists of an usual hopping term tsum_ijc^_ic_j + hc and a Hubbard term Usum_i c^_i c_i c^_ic_i while the transverse-field Ising model contains an Ising term Jsum_ijS^z_iS^z_j as well as a transverse-field term hsum_iS^x_i. Despite the rich diversity of the terms in quantum lattice models, they host common ingredients:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Overall coefficient: every term has an overall coefficient, e.g., the hopping amplitude t for the usual hopping term, the Hubbard interaction strength U for the Hubbard term, etc.\nKind of bonds to be summed over: as the natural result of lattice symmetry, every term contains a summation over some kind of generic bonds, e.g., the usual hopping term sums over the nearest-neighbor bonds ij, the Hubbard term sums over all individual points (namely the 1-point bonds), etc.\nCoupling pattern: in the body of the summation over bonds, every term contains a coupling pattern that can be represented by a certain combination of operators, e.g., the coupling pattern of the usual hopping term can be represented by c^_ic_j, of the Hubbard term can be represented by c^_i c_i c^_ic_i, etc.\nHermiticity: to guarantee the Hamiltonian to be Hermitian, the Hermitian conjugate (h.c.) of non-Hermitian terms must be added, e.g., the Hermitian conjugate of the usual hopping term must be added in the expression of the lattice Hamiltonian while that of the Hubbard term need not.\nBond-dependent amplitude (optional): the amplitude of a term can be dependent on the generic bonds, e.g., the staggered local chemical potential Œîsum_i(-1)^ic^_ic_i depends on the site index of a point, the p+ip pairing potential Œîsum_ije^iœï_ijc^_ic^_j + hc depends on the azimuth angle œï_ij of the bond ij, etc.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Such common ingredients determine the underlying organization of Term. In fact, all of them manifest themselves in the basic construction function of Term shown as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Term{termkind}(\n    id::Symbol, value, bondkind, coupling, ishermitian::Bool;\n    amplitude::Union{Function, Nothing}=nothing\n) where termkind","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"where termkind must be a Symbol, value is the overall coefficient which should be a real number, coupling specifies the coupling pattern of the term which can accept an instance of Coupling, or an iterator of Couplings, or a function that returns a Coupling or an iterator of Couplings, and the keyword argument amplitude specifies the bond dependency of the amplitude if it is not nothing. Here, the new type Coupling is the building block of the coupling pattern, which will be discussed in detail in the following section. It is also noted that an extra id is also assigned with each term which can be used for fast lookup for later convenience.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Coupling-patterns","page":"Couplings among different degrees of freedom","title":"Coupling patterns","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Before the further discussion of Term, we at first turn to the coupling patterns, which lie at the center of the constructions of Terms.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Coupling:-building-block-of-coupling-patterns","page":"Couplings among different degrees of freedom","title":"Coupling: building block of coupling patterns","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Coupling uses a set of Indexes together with a coefficient to represent the coupling pattern, as the following construction function implies:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Coupling([value, ]indexes::Index...)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here, when value is omitted, it will be set to 1.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Let's see a typical example, which represents the coupling pattern of the usual hopping term tsum_ijc^_ic_j + hc:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(Index(1À¢·µó, FockIndex(:, :, 2)), Index(2‚Åø·µà, FockIndex(:, :, 1)))\n‚àë[ùïï(1À¢·µó, :, :, 2) ùïï(2‚Åø·µà, :, :, 1)]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"There are several differences of the Indexes here compared to those introduced in the previous page of Internal degrees of freedom:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The site attributes are not the site indexes of the points in a lattice, instead, they are the ordinals of the points contained in a bond. In fact, in the expression of c^_ic_j, i is always the first site of a bond while j is always the second, thus, the site attributes here are 1À¢·µó and 2‚Åø·µà for the first Index and the second Index, respectively. Here, 1À¢·µó and 2‚Åø·µà are instances of Ordinal, and an arbitrary ordinal can be obtained by an integer followed by the corresponding special constants, e.g., 1À¢·µó, 2‚Åø·µà, 3 ≥·µà, 4·µó ∞, 5·µó ∞, etc.\nThe internal attributes are initialized by special FockIndex instances, which do not have the type parameter :f or :b to specify the statistics, and whose orbital and spin attributes are initialized by the : operator rather than integers. Without the statistics of :f or :b, FockIndex could suit for both fermionic and bosonic quantum lattice systems, as the coupling pattern of an usual hopping term is the same for both kinds of systems. Here, ùïï (\\bbd<tab>) is the function that is convenient to construct and display instances of FockIndex suitable for both fermionic and bosonic statistics. When the : operator is used in the initialization for either the orbital or the spin attribute, the default rule applies in the coupling pattern, that orbitals or spins are summed diagonally, i.e., c^_ic_jsum_Œ±œÉc^_iŒ±œÉc_jŒ±œÉ. This rule is in fact a tradition in the literature of condensed matter physics. This implicit summation in the construction of a Coupling is made explicit in its string representation by the ‚àë symbol, as can be seen in the above example.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Similarly, the total spin of SpinIndex can be omitted during the construction of the coupling patterns of spin terms, meaning that it suits any allowable value of total spins, e.g., the coupling pattern of the spin-flip term of any total spin Jsum_ijS^+_iS^-_j + hc is as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(1//2, Index(1À¢·µó, SpinIndex('+')), Index(2‚Åø·µà, SpinIndex('-')))\n1//2 ùïä(1À¢·µó, '+') ùïä(2‚Åø·µà, '-')","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Note that in this coupling pattern, there is no summation symbol ‚àë in the string representation because all indexes are definite. Therefore, the summation symbol ‚àë in the string representation of a coupling pattern only reflects the summation over local internal degrees of freedom, but not the summation over bonds.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The diagonal summation rule also applies to the direction attribute of PhononIndex if initialized by the : operator, e.g., the the coupling pattern of the phonon kinetic term frac12Msum_i p^2_i can be constructed as:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(ùï°(1À¢·µó, :), ùï°(1À¢·µó, :))\n‚àë[ùï°(1À¢·µó, :) ùï°(1À¢·µó, :)]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Of course, more specific coupling patterns can be initialized with more specific internal indexes, e.g., the coupling pattern of the orbital-1 spin-down hopping term of fermions tsum_ijc^_i 1 c_j 1  + hc is","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(ùïî(1À¢·µó, 1, -1//2, 2), ùïî(2‚Åø·µà, 1, -1//2, 1))\nùïî(1À¢·µó, 1, -1//2, 2) ùïî(2‚Åø·µà, 1, -1//2, 1)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"When all Indexes are of the same type, a Coupling can be initialized in different simpler ways:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# Coupling pattern for Fock systems\nCoupling(\n    [value, ]\n    sites::Union{Colon, NTuple{N, Ordinal}},\n    ::Type{<:FockIndex},\n    orbitals::Union{NTuple{N, Int}, Colon},\n    spins::Union{NTuple{N, Union{Rational{Int}, Int}}, Colon},\n    nambus::Union{NTuple{N, Int}, Colon}\n) where N\nCoupling(\n    [value, ]\n    ::Union{typeof(ùïî), typeof(ùïì), typeof(ùïï)},\n    sites::Union{Colon, NTuple{N, Ordinal}},\n    orbitals::Union{NTuple{N, Int}, Colon},\n    spins::Union{NTuple{N, Union{Rational{Int}, Int}}, Colon},\n    nambus::Union{NTuple{N, Int}, Colon}\n) where N\n\n# Coupling pattern for spin systems\nCoupling(\n    [value, ]\n    sites::Union{Colon, NTuple{N, Ordinal}},\n    ::Type{<:SpinIndex},\n    tags::NTuple{N, Char}\n) where N\nCoupling(\n    [value, ]\n    ::Type{<:ùïä},\n    sites::Union{Colon, NTuple{N, Ordinal}},\n    tags::NTuple{N, Char}\n) where N\n\n# Coupling pattern for phonon systems\nCoupling(\n    [value, ]\n    sites::Union{Colon, NTuple{N, Ordinal}},\n    ::Type{<:Union{PhononIndex{:u}, PhononIndex{:p}}},\n    directions::Union{Colon, NTuple{N, Char}}\n) where N\nCoupling(\n    [value, ]\n    ::Union{typeof(ùï¶), typeof(ùï°)},\n    sites::Union{Colon, NTuple{N, Ordinal}},\n    directions::Union{Colon, NTuple{N, Char}}\n) where N","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here, as is usual, when value is omitted, the coefficient of the Coupling will be set to be 1.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"See examples:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling((1À¢·µó, 1À¢·µó, 2‚Åø·µà, 2‚Åø·µà), FockIndex, :, :, (2, 2, 1, 1))\n‚àë[ùïï(1À¢·µó, :, :, 2) ùïï(1À¢·µó, :, :, 2) ùïï(2‚Åø·µà, :, :, 1) ùïï(2‚Åø·µà, :, :, 1)]\n\njulia> Coupling(ùïï, (1À¢·µó, 1À¢·µó, 2‚Åø·µà, 2‚Åø·µà), :, :, (2, 2, 1, 1))\n‚àë[ùïï(1À¢·µó, :, :, 2) ùïï(1À¢·µó, :, :, 2) ùïï(2‚Åø·µà, :, :, 1) ùïï(2‚Åø·µà, :, :, 1)]\n\njulia> Coupling((1À¢·µó, 2‚Åø·µà), SpinIndex, ('z', 'z'))\nùïä(1À¢·µó, 'z') ùïä(2‚Åø·µà, 'z')\n\njulia> Coupling(ùïä, (1À¢·µó, 2‚Åø·µà), ('z', 'z'))\nùïä(1À¢·µó, 'z') ùïä(2‚Åø·µà, 'z')\n\njulia> Coupling((1À¢·µó, 1À¢·µó), PhononIndex{:p}, :)\n‚àë[ùï°(1À¢·µó, :) ùï°(1À¢·µó, :)]\n\njulia> Coupling(ùï°, (1À¢·µó, 1À¢·µó), :)\n‚àë[ùï°(1À¢·µó, :) ùï°(1À¢·µó, :)]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"A Coupling can be multiplied with a number:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> coupling = Coupling(1//2, ùïä(1À¢·µó, '+'), ùïä(2‚Åø·µà, '-'));\n\njulia> coupling * 3\n3//2 ùïä(1À¢·µó, '+') ùïä(2‚Åø·µà, '-')\n\njulia> 3 * coupling\n3//2 ùïä(1À¢·µó, '+') ùïä(2‚Åø·µà, '-')","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Two Couplings can be multiplied together:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> cp‚ÇÅ = Coupling(ùïï, (1À¢·µó, 1À¢·µó), (:, :), (1//2, 1//2), (2, 1));\n\njulia> cp‚ÇÇ = Coupling(ùïï, (1À¢·µó, 1À¢·µó), (:, :), (-1//2, -1//2), (2, 1));\n\njulia> cp‚ÇÅ * cp‚ÇÇ\n‚àë[ùïï(1À¢·µó, :, 1//2, 2) ùïï(1À¢·µó, :, 1//2, 1)] ‚äó ‚àë[ùïï(1À¢·µó, :, -1//2, 2) ùïï(1À¢·µó, :, -1//2, 1)]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"It is noted that due to the implicit summation of the orbital index in the coupling pattern, the above product is not equal to the coupling pattern of the Hubbard term Usum_i c^_i c_i c^_ic_i:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> cp‚ÇÅ = Coupling(ùïï, (1À¢·µó, 1À¢·µó), :, (1//2, 1//2), (2, 1));\n\njulia> cp‚ÇÇ = Coupling(ùïï, (1À¢·µó, 1À¢·µó), :, (-1//2, -1//2), (2, 1));\n\njulia> cp = Coupling(ùïï, (1À¢·µó, 1À¢·µó, 1À¢·µó, 1À¢·µó), :, (1//2, 1//2, -1//2, -1//2), (2, 1, 2, 1)) # Hubbard coupling pattern\n‚àë[ùïï(1À¢·µó, :, 1//2, 2) ùïï(1À¢·µó, :, 1//2, 1) ùïï(1À¢·µó, :, -1//2, 2) ùïï(1À¢·µó, :, -1//2, 1)]\n\njulia> cp == cp‚ÇÅ * cp‚ÇÇ\nfalse","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Default-rules-in-coupling-patterns","page":"Couplings among different degrees of freedom","title":"Default rules in coupling patterns","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As has been shown in the previous subsection, some attributes of the internal attribute of Index can be initialized by the : operator during the construction of a coupling pattern. For the orbital and spin attributes of FockIndex, and for the direction attribute of PhononIndex, the default rule is that such indexes will be summed diagonally in the coupling pattern. In fact, the site attribute of Index and the nambu attribute of FockIndex also support the : initialization, but with different default rules.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Let's return to the example of the coupling pattern of the usual hopping term, i.e., c^dagger_ic_j. Apparently, the site attributes are always (1À¢·µó, 2‚Åø·µà) and the nambu attributes are always (2, 1) as long as the coupling pattern belongs to an usual hopping term. In fact, for most common terms in condensed matter, such attributes in the coupling pattern usually depends only on their kinds other than the concrete instances. Therefore, we could define them outside the construction functions of Coupling or Term by separate functions, and just leave them to the default rules.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"All predefined default rules can be found in the section of Specialized terms. If you need a term that is beyond such default rules, or you just think that such rules are too complicated to remember, it is recommended to explicitly writing them out in the coupling pattern.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Coupling-patterns-with-constraints","page":"Couplings among different degrees of freedom","title":"Coupling patterns with constraints","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The default rules cannot handle complicated summation conditions on the local internal degrees of freedom in the coupling pattern. For example, for the interorbital-interspin Hubbard term in a multi-orbital Hubbard model, which can be written as Usum_isum_Œ±Œ≤textandœÉœÉ c^_iŒ±œÉ c_iŒ±œÉ c^_iŒ≤œÉ c_iŒ≤œÉ, it is impossible to specify its coupling pattern by a single Coupling in the usual way as introduced in previous subsections. Although the coupling pattern of a Term can also be an iterator of Couplings, it would be quite complicated to write down all the expressions by the manual expansion of the summation over Œ±, Œ≤, œÉ and œÉ. In fact, we have provided a simple way to specify a coupling pattern like this with the help of the macro @pattern:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"@pattern(index‚ÇÅ, index‚ÇÇ, ...[; constraint=...])","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For example, the coupling pattern of the above interorbital-interspin Hubbard term can be constructed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(@pattern(\n           ùïï(:, Œ±, œÉ, 2), ùïï(:, Œ±, œÉ, 1), ùïï(:, Œ≤, œÉ‚Ä≤, 2), ùïï(:, Œ≤, œÉ‚Ä≤, 1);\n           constraint=Œ±<Œ≤ && œÉ‚â†œÉ‚Ä≤\n           )\n       )\n‚àë[ùïï(:, Œ±, œÉ, 2) ùïï(:, Œ±, œÉ, 1) ùïï(:, Œ≤, œÉ‚Ä≤, 2) ùïï(:, Œ≤, œÉ‚Ä≤, 1)](Œ± < Œ≤ && œÉ ‚â† œÉ‚Ä≤)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The keyword argument constraint can be omitted if there are no constraints in the summation, e.g., for a special kind of phonon potential Vsum_ijfrac12sum_ŒºŒΩu_i^Œº u_j^ŒΩ, the coupling pattern can be written as","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(1//2, @pattern ùï¶(:, Œº) ùï¶(:, ŒΩ))\n1//2 ‚àë[ùï¶(:, Œº) ùï¶(:, ŒΩ)]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The Indexes in the @pattern macro can be of different types, e.g., for a fabricated term just for illustration Œªsum_ijfrac12sum_Œ±Œ≤œÉ c^dagger_iŒ±œÉ c_iŒ≤œÉ u^x_i, where itinerant electrons are coupled to lattice vibrations, the coupling pattern is","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> Coupling(1//2, @pattern ùïï(1À¢·µó, Œ±, œÉ, 2) ùïï(1À¢·µó, Œ≤, œÉ, 1) ùï¶(1À¢·µó, x))\n1//2 ‚àë[ùïï(1À¢·µó, Œ±, œÉ, 2) ùïï(1À¢·µó, Œ≤, œÉ, 1) ùï¶(1À¢·µó, x)]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"In principle, the couplings of hybrid quantum lattice systems that couple different categories of internal degrees of freedom can be initialized in these ways. For more discussions on hybrid systems, please refer to the page of Hybrid systems.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"One more remark. The constraints can only act on the internal attribute but not on the site attribute of Index. Remind that the site attribute of Index in the coupling pattern is the ordinal of a point in a bond but not the site index of a point in a lattice. Constraint on it makes no sense.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Coupling-patterns-with-matrices-acting-on-sub-internal-spaces","page":"Couplings among different degrees of freedom","title":"Coupling patterns with matrices acting on sub internal spaces","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"At times, the coupling pattern of a term is not compact enough to be represented by a single Coupling. Then as has been pointed out, they can be represented by an iterator of Couplings. A particular common case in condensed matter physics is that it can be represented by a matrix acting on specific sub internal spaces, e.g., a spin-dependent hopping tsum_ijc^dagger_i œÉ·∂ª c_j + hc where œÉ·∂ª acts on the local spin space. A new type, the MatrixCoupling, as a vector of Coupling, which can be constructed by the following functions:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# Fock systems\nMatrixCoupling(\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    ::Type{<:FockIndex},\n    orbital::Union{AbstractMatrix, Colon},\n    spin::Union{AbstractMatrix, Colon},\n    nambu::Union{AbstractMatrix, Colon}\n)\nMatrixCoupling(\n    ::Union{typeof(ùïî), typeof(ùïì), typeof(ùïï)},\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    orbital::Union{AbstractMatrix, Colon},\n    spin::Union{AbstractMatrix, Colon},\n    nambu::Union{AbstractMatrix, Colon}\n)\nùïî‚Å∫ùïî(\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    orbital::Union{AbstractMatrix, Colon},\n    spin::Union{AbstractMatrix, Colon},\n    nambu::Union{AbstractMatrix, Colon}\n)\nùïì‚Å∫ùïì(\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    orbital::Union{AbstractMatrix, Colon},\n    spin::Union{AbstractMatrix, Colon},\n    nambu::Union{AbstractMatrix, Colon}\n)\nùïï‚Å∫ùïï(\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    orbital::Union{AbstractMatrix, Colon},\n    spin::Union{AbstractMatrix, Colon},\n    nambu::Union{AbstractMatrix, Colon}\n)\n\n# Spin systems\nMatrixCoupling(\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    ::Type{<:SpinIndex},\n    matrix::AbstractMatrix\n)\nMatrixCoupling(\n    ::Type{<:ùïä},\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    matrix::AbstractMatrix\n)\nùïä·µÄùïä(\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    matrix::AbstractMatrix\n)\n\n# Phonon systems\nMatrixCoupling(\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    ::Type{<:PhononIndex{:u}},\n    matrix::AbstractMatrix\n)\nMatrixCoupling(\n    ::typeof(ùï¶),\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    matrix::AbstractMatrix\n)\nùï¶·µÄùï¶(\n    sites::Union{NTuple{2, Ordinal}, Colon},\n    matrix::AbstractMatrix\n)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"is designed to represent the coupling patterns in such cases. Here, in construction functions for spin systems the matrix acts on the local (S^x S^y S^z)^T vector space, and in the construction functions for phonon systems the matrix acts on the local (u^x u^y u^z)^T vector space depending on the dimension of the lattice vibrations.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The following codes construct the coupling pattern of the above spin-dependent hopping example:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> mc = MatrixCoupling(ùïï, :, :, œÉ\"z\", :);\n\njulia> length(mc)\n2\n\njulia> mc[1]\n‚àë[ùïï(:, :, 1//2, :) ùïï(:, :, 1//2, :)]\n\njulia> mc[2]\n- ‚àë[ùïï(:, :, -1//2, :) ùïï(:, :, -1//2, :)]\n\njulia> mc == ùïï‚Å∫ùïï(:, :, œÉ\"z\", :)\ntrue","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here, @œÉ_str is a string literal that returns the generalized Pauli matrices:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"œÉ\"0\" => SparseMatrixCSC([1 0; 0 1])\nœÉ\"x\" => SparseMatrixCSC([0 1; 1 0])\nœÉ\"y\" => SparseMatrixCSC([0 -1im; 1im 0])\nœÉ\"z\" => SparseMatrixCSC([1 0; 0 -1])\nœÉ\"+\" => SparseMatrixCSC([0 1; 0 0])\nœÉ\"-\" => SparseMatrixCSC([0 0; 1 0])\nœÉ\"11\" => SparseMatrixCSC([1 0; 0 0])\nœÉ\"22\" => SparseMatrixCSC([0 0; 0 1])","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The coupling pattern of the Heisenberg term Jsum_ijS^x_iS^x_j+S^y_iS^y_j+S^z_iS^z_j can be constructed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> mc = MatrixCoupling(ùïä, :, Heisenberg\"\");\n\njulia> length(mc)\n3\n\njulia> mc[1]\nùïä(:, 'x') ùïä(:, 'x')\n\njulia> mc[2]\nùïä(:, 'y') ùïä(:, 'y')\n\njulia> mc[3]\nùïä(:, 'z') ùïä(:, 'z')\n\njulia> mc == ùïä·µÄùïä(:, Heisenberg\"\")\ntrue","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"where @Heisenberg_str is a string literal that helps to specify common spin terms.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here lists all the predefined string literals that are helpful to local spin systems:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# Heisenberg term\nHeisenberg\"\" => SparseMatrixCSC([1 0 0; 0 1 0; 0 0 1])\n\n# Ising terms\nIsing\"x\" => SparseMatrixCSC([1 0 0; 0 0 0; 0 0 0])\nIsing\"y\" => SparseMatrixCSC([0 0 0; 0 1 0; 0 0 0])\nIsing\"z\" => SparseMatrixCSC([0 0 0; 0 0 0; 0 0 1])\n\n# Œì terms\nŒì\"x\" => SparseMatrixCSC([0 0 0; 0 0 1; 0 1 0])\nŒì\"y\" => SparseMatrixCSC([0 0 1; 0 0 0; 1 0 0])\nŒì\"z\" => SparseMatrixCSC([0 1 0; 1 0 0; 0 0 0])\n\n# Œì‚Ä≤ terms\nŒì‚Ä≤\"x\" => SparseMatrixCSC([0 1 1; 1 0 0; 1 0 0])\nŒì‚Ä≤\"y\" => SparseMatrixCSC([0 1 0; 1 0 1; 0 1 0])\nŒì‚Ä≤\"z\" => SparseMatrixCSC([0 0 1; 0 0 1; 1 1 0])\n\n# Dzyaloshinskii‚ÄìMoriya terms\nDM\"x\" => SparseMatrixCSC([0 0 0; 0 0 1; 0 -1 0])\nDM\"y\" => SparseMatrixCSC([0 0 -1; 0 0 0; 1 0 0])\nDM\"z\" => SparseMatrixCSC([0 1 0; -1 0 0; 0 0 0])","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"MatrixCouplings can be producted or summed.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For one example, for the nearest-neighbor spin exchange interactions of itinerant fermions Jsum_ijc^_ivecœÉ_ic_i  c^_jvecœÉ_jc_j where vecœÉ_i=(œÉ^x_i œÉ^y_i œÉ^z_i)^T acts on the local spin space at site i, the coupling pattern can be constructed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> mc‚ÇÅ = ùïï‚Å∫ùïï(:, :, œÉ\"+\", :);\n\njulia> mc‚ÇÇ = ùïï‚Å∫ùïï(:, :, œÉ\"-\", :);\n\njulia> mc‚ÇÉ = ùïï‚Å∫ùïï(:, :, œÉ\"z\", :);\n\njulia> coupling = 1//2*mc‚ÇÅ*mc‚ÇÇ + 1//2*mc‚ÇÇ*mc‚ÇÅ + mc‚ÇÉ*mc‚ÇÉ;\n\njulia> collect(coupling)\n6-element Vector{Coupling}:\n 1//2 ‚àë[ùïï(:, :, 1//2, :) ùïï(:, :, -1//2, :)] ‚äó ‚àë[ùïï(:, :, -1//2, :) ùïï(:, :, 1//2, :)]\n 1//2 ‚àë[ùïï(:, :, -1//2, :) ùïï(:, :, 1//2, :)] ‚äó ‚àë[ùïï(:, :, 1//2, :) ùïï(:, :, -1//2, :)]\n ‚àë[ùïï(:, :, 1//2, :) ùïï(:, :, 1//2, :)] ‚äó ‚àë[ùïï(:, :, 1//2, :) ùïï(:, :, 1//2, :)]\n - ‚àë[ùïï(:, :, -1//2, :) ùïï(:, :, -1//2, :)] ‚äó ‚àë[ùïï(:, :, 1//2, :) ùïï(:, :, 1//2, :)]\n - ‚àë[ùïï(:, :, 1//2, :) ùïï(:, :, 1//2, :)] ‚äó ‚àë[ùïï(:, :, -1//2, :) ùïï(:, :, -1//2, :)]\n ‚àë[ùïï(:, :, -1//2, :) ùïï(:, :, -1//2, :)] ‚äó ‚àë[ùïï(:, :, -1//2, :) ùïï(:, :, -1//2, :)]","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For another example, for the onsite spin-orbital coupling of the (d_yz d_xz d_xy)^T t_2g orbitals lambdasum_i c^dagger_i vecL_icdotvecœÉ_i c_i where vecL_i=(L^x_i L^y_i L^z_i)^T acts on the local orbital space and vecœÉ_i=(œÉ^x_i œÉ^y_i œÉ^z_i)^T acts on the local spin space, the coupling pattern can be constructed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> mc‚ÇÅ = ùïï‚Å∫ùïï(:, L\"x\", œÉ\"x\", :);\n\njulia> mc‚ÇÇ = ùïï‚Å∫ùïï(:, L\"y\", œÉ\"y\", :);\n\njulia> mc‚ÇÉ = ùïï‚Å∫ùïï(:, L\"z\", œÉ\"z\", :);\n\njulia> coupling = mc‚ÇÅ + mc‚ÇÇ + mc‚ÇÉ;\n\njulia> collect(coupling)\n12-element Vector{Coupling}:\n -1im ùïï(:, 3, -1//2, :) ùïï(:, 2, 1//2, :)\n 1im ùïï(:, 2, -1//2, :) ùïï(:, 3, 1//2, :)\n -1im ùïï(:, 3, 1//2, :) ùïï(:, 2, -1//2, :)\n 1im ùïï(:, 2, 1//2, :) ùïï(:, 3, -1//2, :)\n - ùïï(:, 3, -1//2, :) ùïï(:, 1, 1//2, :)\n ùïï(:, 1, -1//2, :) ùïï(:, 3, 1//2, :)\n ùïï(:, 3, 1//2, :) ùïï(:, 1, -1//2, :)\n - ùïï(:, 1, 1//2, :) ùïï(:, 3, -1//2, :)\n -1im ùïï(:, 2, 1//2, :) ùïï(:, 1, 1//2, :)\n 1im ùïï(:, 1, 1//2, :) ùïï(:, 2, 1//2, :)\n 1im ùïï(:, 2, -1//2, :) ùïï(:, 1, -1//2, :)\n -1im ùïï(:, 1, -1//2, :) ùïï(:, 2, -1//2, :)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Bond-dependent-coupling-patterns","page":"Couplings among different degrees of freedom","title":"Bond-dependent coupling patterns","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Sometimes, the coupling pattern of a term could be dependent on the bonds. For example, for the Kitaev term on the honeycomb lattice Ksum_ij_Œ≥ S_i^Œ≥S_j^Œ≥ where the nearest-neighbor spin exchange interaction depends on the direction of the nearest-neighbor bonds, as illustrated by the following picture, (Image: Kitaev honeycomb model) the coupling pattern can be represented by the following function:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"function kitaev(bond::Bond)\n    œï = azimuth(rcoordinate(bond)) # get the azimuth angle of a bond in radians\n    any(‚âà(œï), (œÄ/6, 7œÄ/6)) && return Coupling(ùïä, :, ('x', 'x'))\n    any(‚âà(œï), (5œÄ/6, 11œÄ/6)) && return Coupling(ùïä, :, ('y', 'y'))\n    any(‚âà(œï), (œÄ/2, 3œÄ/2)) && return Coupling(ùïä, :, ('z', 'z'))\n    error(\"kitaev error: wrong input bond.\")\nend","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Note in all cases, the function to specify a bond dependent coupling pattern can only accept an instance of Bond as its sole argument, but it can return either a Coupling or an iterator of Couplings.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Bond-dependent-amplitude","page":"Couplings among different degrees of freedom","title":"Bond-dependent amplitude","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As is similar to bond-dependent coupling patterns, the bond-dependent amplitude of a term can be achieved by a function that only accepts an instance of Bond as its sole argument and returns a number. For example, for the staggered local chemical potential Œîsum_i(-1)^ic_i^c_i, the bond-dependent amplitude can be specified as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"function staggered(bond::Bond)\n    @assert length(bond)==1 \"staggered error: wrong input bond.\"\n    return (-1)^bond[1].site\nend","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Terms-with-complex-coefficients","page":"Couplings among different degrees of freedom","title":"Terms with complex coefficients","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"A special case must be paid attention to, i.e., a term with a complex coefficient. In the construction function of Term, a complex number with a nonzero imaginary part can not be used to specify the overall coefficient of a term. This is because the Hamiltonian of a quantum lattice system must be Hermitian and a complex coefficient must be accompanied with its complex conjugate. Thus, the positive direction of the phase must be appointed, resulting in a bond-dependent amplitude. Then, it is always feasible to extract a real overall factor as the final coefficient and leave the remaining part to the bond-dependent amplitude function. For example, for the p+ip pairing potential Œîsum_ije^iœï_ijc^_ic^_j + hc, the coefficient is a pure imaginary number along the y direction, and the bond-dependent amplitude of this term can be specified as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"function pip_potential(bond::Bond)\n    œï = azimuth(rcoordinate(bond))\n    return exp(1im*œï)\nend","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Principles-of-the-partition-of-coefficients","page":"Couplings among different degrees of freedom","title":"Principles of the partition of coefficients","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"As has been shown but not explicitly stated, in general, the coefficient of a term is partitioned into three parts in Term, the first part is the overall coefficient which must be a real number and is specified by the value argument in the construction function, the second part is the coefficient occurring in the coupling pattern, and the last part is handled by the bond-dependent amplitude function. Then there exist an ambiguity about how these three parts should be partitioned. Here are the recommended principles:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"The overall real coefficient should contain as much as possible of the coefficient of the term that can be put in front of the summation over bonds.\nThe coefficient of a coupling pattern should be determined by traditions (e.g., i in the œÉ ∏ Pauli matrix), otherwise should be 1.\nThe bond-dependent amplitude should not contain the tuning parameters of a quantum lattice model.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"If the coefficient of a complicated term cannot fulfill the above principles at the same time, then you should consider splitting it into several terms. A simple check of the number of terms is that in principle it should be equal to the number of tunable parameters of the quantum lattice model under study.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Specialized-terms","page":"Couplings among different degrees of freedom","title":"Specialized terms","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For each certain kind of terms, some of the input parameters of the basic construction function are in fact fixed or have default values, e.g., the usual hopping term is always non-Hermitian while the Hubbard term is always Hermitian. Therefore, for each common kind of terms in condensed matter physics, it is more convenient to define the specialized construction function. In the following subsections we will list the predefined specialized terms.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Terms-for-complex-fermionic/bosonic-systems","page":"Couplings among different degrees of freedom","title":"Terms for complex fermionic/bosonic systems","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# termkind = :Onsite\n# bondkind = 0\nOnsite(\n    id::Symbol, value, coupling=Coupling(ùïï(:, :, :, :), ùïï(:, :, :, :));\n    ishermitian::Bool=true,\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Hopping\n# ishermitian = false\nHopping(\n    id::Symbol,\n    value,\n    bondkind,\n    coupling=Coupling(ùïï(:, :, :, :), ùïï(:, :, :, :));\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Pairing\n# ishermitian = false\nPairing(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :Hubbard\n# bondkind = 0\n# coupling = Coupling(ùïï, :, :, (1//2, 1//2, -1//2, -1//2), (2, 1, 2, 1))\n# ishermitian = true\nHubbard(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :InterOrbitalInterSpin\n# bondkind = 0\n# coupling = Coupling(@pattern(\n#     ùïï(:, Œ±, œÉ, 2), ùïï(:, Œ±, œÉ, 1), ùïï(:, Œ≤, œÉ‚Ä≤, 2), ùïï(:, Œ≤, œÉ‚Ä≤, 1);\n#     constraint=Œ±<Œ≤ && œÉ‚â†œÉ‚Ä≤\n# ))\n# ishermitian = true\nInterOrbitalInterSpin(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :InterOrbitalIntraSpin\n# bondkind = 0\n# coupling = Coupling(@pattern(\n#     ùïï(:, Œ±, œÉ, 2), ùïï(:, Œ±, œÉ, 1), ùïï(:, Œ≤, œÉ, 2), ùïï(:, Œ≤, œÉ, 1);\n#     constraint=Œ±<Œ≤\n# ))\n# ishermitian = true\nInterOrbitalIntraSpin(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :SpinFlip\n# bondkind = 0\n# coupling = Coupling(@pattern(\n#     ùïï(:, Œ±, 1//2, 2), ùïï(:, Œ≤, -1//2, 2), ùïï(:, Œ±, -1//2, 1), ùïï(:, Œ≤, 1//2, 1);\n#     constraint=Œ±<Œ≤\n# ))\n# ishermitian = false\nSpinFlip(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :PairHopping\n# bondkind = 0\n# coupling = Coupling(@pattern(\n#     ùïï(:, Œ±, 1//2, 2), ùïï(:, Œ±, -1//2, 2), ùïï(:, Œ≤, -1//2, 1), ùïï(:, Œ≤, 1//2, 1);\n#     constraint=Œ±<Œ≤\n# ))\n# ishermitian = false\nPairHopping(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :Coulomb\nCoulomb(\n    id::Symbol,\n    value,\n    bondkind,\n    coupling=Coupling(ùïï(:, :, :, :), ùïï(:, :, :, :))^2;\n    ishermitian::Bool=true,\n    amplitude::Union{Function, Nothing}=nothing\n)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Default rules for such terms when the site attribute of Index and the orbital, spin and nambu attributes of FockIndex initialized by the : operator are listed as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":" site orbital spin nambu\nOnsite (1À¢·µó, 1À¢·µó) diagonal diagonal (2, 1)\nHopping (1À¢·µó, 2‚Åø·µà) diagonal diagonal (2, 1)\nPairing (1À¢·µó, 1À¢·µó)/(1À¢·µó, 2‚Åø·µà) diagonal diagonal (1, 1)\nHubbard (1À¢·µó, 1À¢·µó, 1À¢·µó, 1À¢·µó) diagonal  \nInterOrbitalInterSpin (1À¢·µó, 1À¢·µó, 1À¢·µó, 1À¢·µó)   \nInterOrbitalIntraSpin (1À¢·µó, 1À¢·µó, 1À¢·µó, 1À¢·µó)   \nSpinFlip (1À¢·µó, 1À¢·µó, 1À¢·µó, 1À¢·µó)   \nPairHopping (1À¢·µó, 1À¢·µó, 1À¢·µó, 1À¢·µó)   \nCoulomb (1À¢·µó, 1À¢·µó, 2‚Åø·µà, 2‚Åø·µà) diagonal diagonal (2, 1, 2, 1)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"note: Note\nFor the Pairing term, the site attributes will be (1À¢·µó, 1À¢·µó) when bondkind=0, otherwise (1À¢·µó, 2‚Åø·µà).\nBlank cells in the above table mean that the corresponding attributes have been explicitly specified by the specialized construction functions. See the comments of the above code block in this subsection.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Terms-for-SU(2)-spin-systems","page":"Couplings among different degrees of freedom","title":"Terms for SU(2) spin systems","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Standard concrete spin terms are summarized as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# termkind = :Zeeman\n# bondkind = 0\n# ishermitian = true\nZeeman(\n    id::Symbol, value, direction::Char, g::Number=1;\n    amplitude::Union{Function, Nothing}=nothing\n)\nZeeman(\n    id::Symbol,\n    value,\n    direction::Union{AbstractVector{<:Number}, Tuple{Number, Number}},\n    g::Union{Number, AbstractMatrix{<:Number}}=1;\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :SingleIonAnisotropy\n# bondkind = 0\n# ishermitian = true\nSingleIonAnisotropy(\n    id::Symbol, value, direction::Char;\n    amplitude::Union{Function, Nothing}=nothing\n)\nSingleIonAnisotropy(\n    id::Symbol, value, matrix::AbstractMatrix{<:Number};\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Ising\n# ishermitian = true\nIsing(\n    id::Symbol, value, bondkind, direction::Char;\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Heisenberg\n# ishermitian = true\nHeisenberg(\n    id::Symbol, value, bondkind;\n    form::Symbol=Symbol(\"+-z\"), amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Kitaev\n# ishermitian = true\nKitaev(\n    id::Symbol, value, bondkind;\n    x::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    y::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    z::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Œì\n# ishermitian = true\nŒì(\n    id::Symbol, value, bondkind;\n    x::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    y::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    z::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :Œì‚Ä≤\n# ishermitian = true\nŒì‚Ä≤(\n    id::Symbol, value, bondkind;\n    x::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    y::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    z::AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}},\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing\n)\n\n# termkind = :DM\n# ishermitian = true\nDM(\n    id::Symbol,\n    value,\n    bondkind,\n    vectors::Pair{<:AbstractVector{<:Union{Number, Tuple{Number, Number}, AbstractVector{<:Number}}}, <:Union{Char, AbstractVector{<:Number}}}...;\n    unit::Symbol=:degree,\n    amplitude::Union{Function, Nothing}=nothing\n)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Beyond the above standard concrete terms, the generic spin term can be used:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# termkind = :SpinTerm\n# ishermitian = true\nSpinTerm(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Here, only the site attribute of Index can be initialized by the : operator. Depending on its rank (i.e. the number of Indexes in the coupling pattern) and the length of the bonds to be summed over, it will be (1À¢·µó, 1À¢·µó, ...) when the bond length is 1 and (1À¢·µó, 2‚Åø·µà, 1À¢·µó, 2‚Åø·µà...) when the bond length is 2. For other generic bonds with more points, no default rule exists.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Terms-for-phononic-systems","page":"Couplings among different degrees of freedom","title":"Terms for phononic systems","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"# termkind = :Kinetic\n# bondkind = 0\n# coupling = Coupling(ùï°(:, :), ùï°(:, :))\n# ishermitian = true\nKinetic(id::Symbol, value; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :Hooke\n# ishermitian = true\nHooke(id::Symbol, value, bondkind; amplitude::Union{Function, Nothing}=nothing)\n\n# termkind = :Elastic\n# ishermitian = true\n# default rules: (1À¢·µó, 2‚Åø·µà) for `site` and diagonal for `direction`\nElastic(id::Symbol, value, bondkind, coupling; amplitude::Union{Function, Nothing}=nothing)","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"For Elastic, the site attribute of Index and the direction attribute of PhononIndex{:u} can be initialized by the : operator. The default rules are also summarized in the comments of the above code block.","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/#Expand-terms-to-obtain-operators","page":"Couplings among different degrees of freedom","title":"Expand terms to obtain operators","text":"","category":"section"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"To obtain the operators of a Term, the expand function exported by this package can be used as follows:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"expand(term::Term, bond::Bond, hilbert::Hilbert) -> Operators\nexpand(term::Term, bonds::AbstractVector{<:Bond}, hilbert::Hilbert) -> Operators","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"Let's see a simple example of the usual hopping term:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> t = Hopping(:t, 2.0, 1);\n\njulia> bond = Bond(1, Point(1, [0.0], [0.0]), Point(2, [0.5], [0.0]));\n\njulia> hilbert = Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:f}(1, 2));\n\njulia> expand(t, bond, hilbert)\nOperators with 4 Operator\n  Operator(2.0, ùïî(1, 1, -1//2, 2, [0.0], [0.0]), ùïî(2, 1, -1//2, 1, [0.5], [0.0]))\n  Operator(2.0, ùïî(2, 1, -1//2, 2, [0.5], [0.0]), ùïî(1, 1, -1//2, 1, [0.0], [0.0]))\n  Operator(2.0, ùïî(1, 1, 1//2, 2, [0.0], [0.0]), ùïî(2, 1, 1//2, 1, [0.5], [0.0]))\n  Operator(2.0, ùïî(2, 1, 1//2, 2, [0.5], [0.0]), ùïî(1, 1, 1//2, 1, [0.0], [0.0]))","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"When a bond and a term do not match each other, the expand function will return an empty Operators:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> t = Hopping(:t, 1.0, 1);\n\njulia> bond = Bond(2, Point(1, [0.0], [0.0]), Point(1, [1.0], [1.0]));\n\njulia> hilbert = Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:f}(1, 2));\n\njulia> expand(t, bond, hilbert)\nOperators with 0 Operator","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"In the expand function, an AbstractVector of Bonds can also be provided to get all the operators expanded on such bonds:","category":"page"},{"location":"unitcell description framework/CouplingsAmongDifferentDegreesOfFreedom/","page":"Couplings among different degrees of freedom","title":"Couplings among different degrees of freedom","text":"julia> t = Hopping(:t, 1.0, 1);\n\njulia> bonds = [\n           Bond(1, Point(2, [0.5], [0.0]), Point(1, [0.0], [0.0])),\n           Bond(1, Point(2, [-0.5], [-1.0]), Point(1, [0.0], [0.0]))\n       ];\n\njulia> hilbert = Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:f}(1, 2));\n\njulia> expand(t, bonds, hilbert)\nOperators with 8 Operator\n  Operator(1.0, ùïî(2, 1, -1//2, 2, [0.5], [0.0]), ùïî(1, 1, -1//2, 1, [0.0], [0.0]))\n  Operator(1.0, ùïî(1, 1, -1//2, 2, [0.0], [0.0]), ùïî(2, 1, -1//2, 1, [0.5], [0.0]))\n  Operator(1.0, ùïî(2, 1, 1//2, 2, [0.5], [0.0]), ùïî(1, 1, 1//2, 1, [0.0], [0.0]))\n  Operator(1.0, ùïî(1, 1, 1//2, 2, [0.0], [0.0]), ùïî(2, 1, 1//2, 1, [0.5], [0.0]))\n  Operator(1.0, ùïî(2, 1, -1//2, 2, [-0.5], [-1.0]), ùïî(1, 1, -1//2, 1, [0.0], [0.0]))\n  Operator(1.0, ùïî(1, 1, -1//2, 2, [0.0], [0.0]), ùïî(2, 1, -1//2, 1, [-0.5], [-1.0]))\n  Operator(1.0, ùïî(2, 1, 1//2, 2, [-0.5], [-1.0]), ùïî(1, 1, 1//2, 1, [0.0], [0.0]))\n  Operator(1.0, ùïî(1, 1, 1//2, 2, [0.0], [0.0]), ùïî(2, 1, 1//2, 1, [-0.5], [-1.0]))","category":"page"},{"location":"advanced topics/Introduction/#AdvancedTopicsIntroduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"advanced topics/Introduction/","page":"Introduction","title":"Introduction","text":"The unitcell description framework is the basics of this package, which completes the goal of describing a quantum lattice system and obtaining its Hamiltonian in the operator form. Here, we introduce some advanced utilities provided in this package that will be useful for the compiling, debugging and applying of quantum many-body algorithms.","category":"page"},{"location":"advanced topics/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"LaTeXFormattedOutputs.md\",\n    \"IndexOrders.md\",\n    \"BoundaryConditions.md\",\n    \"HybridSystems.md\",\n    \"Transformations.md\",\n    \"ManageProjects.md\",\n    ]\nDepth = 2","category":"page"},{"location":"advanced topics/LaTeXFormattedOutputs/#LaTeX-formatted-outputs","page":"LaTeX formatted outputs","title":"LaTeX formatted outputs","text":"","category":"section"},{"location":"man/Spatials/#Spatials","page":"Spatials","title":"Spatials","text":"","category":"section"},{"location":"man/Spatials/#QuantumLattices.Spatials.heatmap","page":"Spatials","title":"QuantumLattices.Spatials.heatmap","text":"@recipe plot(reciprocalspace::BrillouinZone, data::AbstractMatrix{<:Number})\n@recipe plot(reciprocalspace::ReciprocalZone, data::AbstractMatrix{<:Number})\n\nDefine the recipe for the heatmap visualization of data on a Brillouin/reciprocal zone.\n\n\n\n\n\n","category":"constant"},{"location":"man/Spatials/#QuantumLattices.Spatials.line","page":"Spatials","title":"QuantumLattices.Spatials.line","text":"@recipe plot(path::ReciprocalPath, data::AbstractMatrix{<:Number})\n\nDefine the recipe for the line visualization of data along a reciprocal path.\n\n\n\n\n\n","category":"constant"},{"location":"man/Spatials/#QuantumLattices.Spatials.scatter","page":"Spatials","title":"QuantumLattices.Spatials.scatter","text":"@recipe plot(path::ReciprocalPath, data::AbstractMatrix{<:Number}, weights::AbstractArray{<:Number, 3}; weightmultiplier=5.0, weightcolors=nothing, weightlabels=nothing)\n\nDefine the recipe for the scatter visualization of data along a reciprocal path with a series of weights.\n\n\n\n\n\n","category":"constant"},{"location":"man/Spatials/#QuantumLattices.QuantumNumbers.ùïÇ¬≤-Union{Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{AbstractVector{<:Number}, AbstractVector{<:AbstractVector{<:Number}}}} where {N‚ÇÅ, N‚ÇÇ}","page":"Spatials","title":"QuantumLattices.QuantumNumbers.ùïÇ¬≤","text":"ùïÇ¬≤{N‚ÇÅ, N‚ÇÇ}(momentum::AbstractVector{<:Number}, reciprocals::AbstractVector{<:AbstractVector{<:Number}}; atol=atol, rtol=rtol) where {N‚ÇÅ, N‚ÇÇ}\n\nConstruct a 2d quantum momentum by the coordinates.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.QuantumNumbers.ùïÇ¬≥-Union{Tuple{N‚ÇÉ}, Tuple{N‚ÇÇ}, Tuple{N‚ÇÅ}, Tuple{AbstractVector{<:Number}, AbstractVector{<:AbstractVector{<:Number}}}} where {N‚ÇÅ, N‚ÇÇ, N‚ÇÉ}","page":"Spatials","title":"QuantumLattices.QuantumNumbers.ùïÇ¬≥","text":"ùïÇ¬≥{N‚ÇÅ, N‚ÇÇ, N‚ÇÉ}(momentum::AbstractVector{<:Number}, reciprocals::AbstractVector{<:AbstractVector{<:Number}}; atol=atol, rtol=rtol) where {N‚ÇÅ, N‚ÇÇ, N‚ÇÉ}\n\nConstruct a 3d quantum momentum by the coordinates.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.QuantumNumbers.ùïÇ¬π-Union{Tuple{N}, Tuple{AbstractVector{<:Number}, AbstractVector{<:AbstractVector{<:Number}}}} where N","page":"Spatials","title":"QuantumLattices.QuantumNumbers.ùïÇ¬π","text":"ùïÇ¬π{N}(momentum::AbstractVector{<:Number}, reciprocals::AbstractVector{<:AbstractVector{<:Number}}; atol=atol, rtol=rtol) where N\n\nConstruct a 1d quantum momentum by the coordinates.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.AbstractLattice","page":"Spatials","title":"QuantumLattices.Spatials.AbstractLattice","text":"AbstractLattice{N, D<:Number, M}\n\nAbstract type of a unitcell-described lattice.\n\nIt should have the following contents:\n\nname::Symbol: the name of the lattice\ncoordinates::Matrix{D}: the coordinates of the lattice\nvectors::SVector{M, SVector{N, D}}: the translation vectors of the lattice\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Bond","page":"Spatials","title":"QuantumLattices.Spatials.Bond","text":"Bond{K, P<:Point} <: AbstractVector{P}\n\nA generic bond, which could contains several points.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Bond-Tuple{Point}","page":"Spatials","title":"QuantumLattices.Spatials.Bond","text":"Bond(point::Point)\nBond(kind, point‚ÇÅ::Point, point‚ÇÇ::Point, points::Point...)\n\nConstruct a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.BrillouinZone","page":"Spatials","title":"QuantumLattices.Spatials.BrillouinZone","text":"BrillouinZone{K, P<:ùïÇ, N, S<:SVector} <: ProductedReciprocalSpace{K, N, S}\n\nBrillouin zone of a lattice.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.BrillouinZone-Tuple{AbstractVector{<:AbstractVector{<:Number}}, Any}","page":"Spatials","title":"QuantumLattices.Spatials.BrillouinZone","text":"BrillouinZone(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, nk)\nBrillouinZone{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, nk) where K\nBrillouinZone(::Type{P}, reciprocals::AbstractVector{<:AbstractVector{<:Number}}) where {P<:ùïÇ}\nBrillouinZone{K}(::Type{P}, reciprocals::AbstractVector{<:AbstractVector{<:Number}}) where {K, P<:ùïÇ}\n\nConstruct a Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.FractionalReciprocalSpace","page":"Spatials","title":"QuantumLattices.Spatials.FractionalReciprocalSpace","text":"FractionalReciprocalSpace{K, P<:SVector, N} <: ReciprocalSpace{K, P}\n\nAbstract type of reciprocal spaces with fractional coordinates.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Lattice","page":"Spatials","title":"QuantumLattices.Spatials.Lattice","text":"Lattice(lattice::AbstractLattice, ranges::OneAtLeast{Int}, boundaries::OneAtLeast{Union{Char, String, Symbol}}=ntuple(i->'O', Val(fieldcount(typeof(ranges)))); mode::Symbol=:nonnegative)\nLattice(lattice::AbstractLattice, ranges::OneAtLeast{UnitRange{Int}}, boundaries::OneAtLeast{Union{Char, String, Symbol}}=ntuple(i->'O', Val(fieldcount(typeof(ranges)))))\n\nConstruct a lattice from the translations of another.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Lattice-2","page":"Spatials","title":"QuantumLattices.Spatials.Lattice","text":"Lattice{N, D<:Number, M} <: AbstractLattice{N, D, M}\n\nSimplest lattice.\n\nA simplest lattice can be constructed from its coordinates and translation vectors.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Lattice-Union{Tuple{N}, Tuple{NTuple{N, Number}, Vararg{NTuple{N, Number}}}} where N","page":"Spatials","title":"QuantumLattices.Spatials.Lattice","text":"Lattice(coordinates::NTuple{N, Number}...; name::Symbol=:lattice, vectors::Union{AbstractVector{<:AbstractVector{<:Number}}, Nothing}=nothing) where N\nLattice(coordinates::AbstractVector{<:Number}...; name::Symbol=:lattice, vectors::Union{AbstractVector{<:AbstractVector{<:Number}}, Nothing}=nothing)\n\nConstruct a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.Neighbors","page":"Spatials","title":"QuantumLattices.Spatials.Neighbors","text":"Neighbors{K, V<:Number} <: CompositeDict{K, V}\n\nNeighbor vs. bond length maps.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Neighbors-Tuple{AbstractLattice, Integer}","page":"Spatials","title":"QuantumLattices.Spatials.Neighbors","text":"Neighbors(lattice::AbstractLattice, nneighbor::Integer; coordination::Integer=12)\n\nGet the neighbor vs. bond length map of a lattice up to the nneighborth order.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.Point","page":"Spatials","title":"QuantumLattices.Spatials.Point","text":"Point{N, D<:Number}\n\nA point in a unitcell-described lattice.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.Point-Union{Tuple{N}, Tuple{Integer, NTuple{N, var\"#s120\"} where var\"#s120\"<:Number}, Tuple{Integer, NTuple{N, var\"#s119\"} where var\"#s119\"<:Number, NTuple{N, var\"#s118\"} where var\"#s118\"<:Number}} where N","page":"Spatials","title":"QuantumLattices.Spatials.Point","text":"Point(site::Integer, rcoordinate::SVector{N, D}, icoordinate::SVector{N, D}) where {N, D<:Number}\nPoint(site::Integer, rcoordinate::NTuple{N, <:Number}, icoordinate::NTuple{N, <:Number}=ntuple(i->0, Val(N))) where N\nPoint(site::Integer, rcoordinate::AbstractVector{<:Number}, icoordinate::AbstractVector{<:Number}=zero(SVector{length(rcoordinate), Int}))\n\nConstruct a labeled point.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ProductedReciprocalSpace","page":"Spatials","title":"QuantumLattices.Spatials.ProductedReciprocalSpace","text":"ProductedReciprocalSpace{K, N, P<:SVector} <: FractionalReciprocalSpace{K, N, P}\n\nAbstract type of reciprocal spaces whose fractional coordinates are composed of the direct product of several ranges.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalCurve","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalCurve","text":"ReciprocalCurve{K, S<:SVector} <: ReciprocalSpace{K, S}\n\nA curve in the reciprocal space.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalCurve-Tuple{ReciprocalSpace}","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalCurve","text":"ReciprocalCurve(reciprocalspace::ReciprocalSpace)\n\nConstruct a reciprocal curve from a reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalCurve-Union{Tuple{AbstractVector{<:NTuple{N, Number}}}, Tuple{N}} where N","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalCurve","text":"ReciprocalCurve(curve::AbstractVector{<:NTuple{N, Number}}) where N\nReciprocalCurve(curve::AbstractVector{<:AbstractVector{<:Number}})\nReciprocalCurve{K}(curve::AbstractVector{<:NTuple{N, Number}}) where {K, N}\nReciprocalCurve{K}(curve::AbstractVector{<:AbstractVector{<:Number}}) where K\n\nConstruct a curve in the reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalPath","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalPath","text":"ReciprocalPath{K, S<:SVector, N, R} <: ReciprocalSpace{K, S}\n\nA path in the reciprocal space.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalPath-Tuple{AbstractVector{<:AbstractVector{<:Number}}, NamedTuple{(:points, :labels), <:Tuple{var\"#s16\", var\"#s15\"} where {var\"#s16\"<:Tuple, var\"#s15\"<:Tuple}}}","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalPath","text":"ReciprocalPath(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, contents::NamedTuple{(:points, :labels), <:Tuple{<:Tuple, <:Tuple}}; length=100, ends=nothing)\nReciprocalPath{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, contents::NamedTuple{(:points, :labels), <:Tuple{<:Tuple, <:Tuple}}; length=100, ends=nothing) where K\n\nReciprocalPath(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, points::OneOrMore{Number}...; labels=points, length=100, ends=nothing)\nReciprocalPath{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, points::OneOrMore{Number}...; labels=points, length=100, ends=nothing) where K\n\nReciprocalPath(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, segments::Pair{<:OneOrMore{Number}, <:OneOrMore{Number}}...; labels=segments, length=100, ends=nothing)\nReciprocalPath{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, segments::Pair{<:OneOrMore{Number}, <:OneOrMore{Number}}...; labels=segments, length=100, ends=nothing) where K\n\nConstruct a path in the reciprocal space.\n\nnote: Note\nFor connected segments,\nwhen length is an integer, it specifies the length of each segment except for the last whose length will be length+1;\nwhen ends is nothing, the start point will be included while the end point will be not for each segment except for the last both points of which will be included.\nFor disconnected segments, they can be partitioned into several connected parts, and the rules for connected segments apply for each of such connected parts.With the above rules, all the points along the assigned path will be counted once and only once with the largest homogeneity.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalScatter","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalScatter","text":"ReciprocalScatter{K, N, S<:SVector, V<:SVector{N}} <: FractionalReciprocalSpace{K, N, S}\n\nA set of scatter points in the reciprocal space.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalScatter-Tuple{AbstractVector{<:AbstractVector{<:Number}}, AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalScatter","text":"ReciprocalScatter(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, fractionals::AbstractVector{<:AbstractVector{<:Number}})\nReciprocalScatter{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, fractionals::AbstractVector{<:AbstractVector{<:Number}}) where K\n\nConstruct a set of reciprocal scatter points.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalScatter-Tuple{FractionalReciprocalSpace}","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalScatter","text":"ReciprocalScatter(reciprocalspace::FractionalReciprocalSpace)\n\nConstruct a set of reciprocal scatter points from a reciprocal space with fractional coordinates.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalSpace","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalSpace","text":"ReciprocalSpace{K, P<:SVector} <: VectorSpace{P}\n\nAbstract type of reciprocal spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalZone","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalZone","text":"ReciprocalZone{K, N, S<:SVector, V<:Number} <: ProductedReciprocalSpace{K, N, S}\n\nA zone in the reciprocal space.\n\n\n\n\n\n","category":"type"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalZone-Tuple{AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalZone","text":"ReciprocalZone(reciprocals::AbstractVector{<:AbstractVector{<:Number}}; length=100, ends=(true, false))\nReciprocalZone{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}; length=100, ends=(true, false)) where K\n\nReciprocalZone(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, bounds::Pair{<:Number, <:Number}...; length=100, ends=(true, false))\nReciprocalZone{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, bounds::Pair{<:Number, <:Number}...; length=100, ends=(true, false)) where K\n\nReciprocalZone(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, bounds::AbstractVector{<:Pair{<:Number, <:Number}}; length=100, ends=(true, false))\nReciprocalZone{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, bounds::AbstractVector{<:Pair{<:Number, <:Number}}; length=100, ends=(true, false)) where K\n\nReciprocalZone(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, bounds::OneAtLeast{Pair{<:Number, <:Number}}; length=100, ends=(true, false))\nReciprocalZone{K}(reciprocals::AbstractVector{<:AbstractVector{<:Number}}, bounds::OneAtLeast{Pair{<:Number, <:Number}}; length=100, ends=(true, false)) where K\n\nConstruct a rectangular zone in the reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ReciprocalZone-Union{Tuple{ProductedReciprocalSpace{K, N}}, Tuple{N}, Tuple{K}} where {K, N}","page":"Spatials","title":"QuantumLattices.Spatials.ReciprocalZone","text":"ReciprocalZone(reciprocalspace::ProductedReciprocalSpace)\n\nConstruct a reciprocal zone from a reciprocal space whose fractional coordinates are composed of the direct product of several ranges.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.@hexagon_str-Tuple{String}","page":"Spatials","title":"QuantumLattices.Spatials.@hexagon_str","text":"hexagon\"P‚ÇÅ-P‚ÇÇ-P‚ÇÉ-...\"\nhexagon\"P‚ÇÅ-P‚ÇÇ-P‚ÇÉ-..., 120¬∞\"\nhexagon\"P‚ÇÅ-P‚ÇÇ-P‚ÇÉ-..., 60¬∞\"\n\nConstruct a tuple of start-stop point pairs for the hexagonal reciprocal space.\n\n\n\n\n\n","category":"macro"},{"location":"man/Spatials/#QuantumLattices.Spatials.@line_str-Tuple{String}","page":"Spatials","title":"QuantumLattices.Spatials.@line_str","text":"line\"P‚ÇÅ-P‚ÇÇ-P‚ÇÉ-...\"\n\nConstruct a tuple of start-stop point pairs for the one dimensional reciprocal space.\n\n\n\n\n\n","category":"macro"},{"location":"man/Spatials/#QuantumLattices.Spatials.@rectangle_str-Tuple{String}","page":"Spatials","title":"QuantumLattices.Spatials.@rectangle_str","text":"rectangle\"P‚ÇÅ-P‚ÇÇ-P‚ÇÉ-...\"\n\nConstruct a tuple of start-stop point pairs for the rectangular reciprocal space.\n\n\n\n\n\n","category":"macro"},{"location":"man/Spatials/#Base.getindex-Tuple{AbstractLattice, Integer}","page":"Spatials","title":"Base.getindex","text":"getindex(lattice::AbstractLattice, i::Integer) -> SVector\n\nGet the ith coordinate.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.getindex-Tuple{Bond, Integer}","page":"Spatials","title":"Base.getindex","text":"getindex(bond::Bond, i::Integer) -> Point\n\nGet the ith point contained in a generic bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.getindex-Union{Tuple{P}, Tuple{K}, Tuple{BrillouinZone{K, P}, P}} where {K, P<:(ùïÇ)}","page":"Spatials","title":"Base.getindex","text":"getindex(brillouinzone::BrillouinZone{K, P}, index::P) where {K, P<:ùïÇ} -> eltype(brillouinzone)\n\nGet the coordinates of a momentum in a Brillouin zone by its corresponding Abelian quantum number.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.hash-Tuple{BrillouinZone, UInt64}","page":"Spatials","title":"Base.hash","text":"hash(brillouinzone::BrillouinZone, h::UInt)\n\nHash a Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.keys-Union{Tuple{BrillouinZone{K, P}}, Tuple{P}, Tuple{K}} where {K, P<:(ùïÇ)}","page":"Spatials","title":"Base.keys","text":"keys(::BrillouinZone{K, P}) where {K, P<:ùïÇ} -> Momenta{P}\n\nGet the keys of a Brillouin zone, which is defined to be the complete allowed set of Abelian quantum numbers representing the momenta in the Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.keytype-Tuple{BrillouinZone}","page":"Spatials","title":"Base.keytype","text":"keytype(brillouinzone::BrillouinZone)\nkeytype(::Type{<:BrillouinZone{K, P} where K}) where {P<:ùïÇ}\n\nGet the keytype of a Brillouin zone, which is defined to be the type of the Abelian quantum number representing a momentum in the Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.length-Tuple{AbstractLattice}","page":"Spatials","title":"Base.length","text":"length(lattice::AbstractLattice) -> Int\n\nGet the number of points contained in a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.range-Tuple{BrillouinZone, Integer}","page":"Spatials","title":"Base.range","text":"range(brillouinzone::BrillouinZone, i::Integer) -> StepRangeLen{Float64}\n\nGet the ith axis range of the fractional coordinates of a Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.range-Tuple{ReciprocalZone, Integer}","page":"Spatials","title":"Base.range","text":"range(reciprocalzone::ReciprocalZone, i::Integer) -> StepRangeLen{Float64}\n\nGet the ith axis range of the fractional coordinates of a reciprocal zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.reverse-Tuple{Bond}","page":"Spatials","title":"Base.reverse","text":"reverse(bond::Bond) -> Bond\n\nGet the reversed bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#Base.step-Tuple{ReciprocalPath, Integer}","page":"Spatials","title":"Base.step","text":"step(path::ReciprocalPath, i::Integer) -> scalartype(path)\n\nGet the step between the ith and the (i+1)th points in the path.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.QuantumOperators.matrix-Tuple{AbstractVector{<:AbstractVector}}","page":"Spatials","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix(vs::AbstractVector{<:AbstractVector}) -> Matrix\n\nConvert a vector of vector to a matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.QuantumOperators.scalartype-Union{Tuple{Type{<:AbstractLattice{N, D} where N}}, Tuple{D}} where D<:Number","page":"Spatials","title":"QuantumLattices.QuantumOperators.scalartype","text":"scalartype(::Type{<:AbstractLattice{N, D} where N}) where {D<:Number}\n\nGet the data type of the coordinates of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.QuantumOperators.scalartype-Union{Tuple{Type{<:Point{N, D} where N}}, Tuple{D}} where D<:Number","page":"Spatials","title":"QuantumLattices.QuantumOperators.scalartype","text":"scalartype(::Type{<:Point{N, D} where N}) where {D<:Number}\n\nGet the data type of the coordinates of a point.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.QuantumOperators.scalartype-Union{Tuple{Type{<:ReciprocalSpace{K, P} where K}}, Tuple{P}} where P<:(StaticArraysCore.SVector)","page":"Spatials","title":"QuantumLattices.QuantumOperators.scalartype","text":"scalartype(::Type{<:ReciprocalSpace{K, P} where K}) where {P<:SVector}\n\nGet the data type of the coordinates of a reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.azimuth-Tuple{AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.azimuth","text":"azimuth(v::AbstractVector{<:Number}) -> Number\n\nGet the azimuth angle in radians of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.azimuthd-Tuple{AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.azimuthd","text":"azimuthd(v::AbstractVector{<:Number}) -> Number\n\nGet the azimuth angle in degrees of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.bonds!-Tuple{Vector, AbstractLattice, Integer}","page":"Spatials","title":"QuantumLattices.Spatials.bonds!","text":"bonds!(bonds::Vector, lattice::AbstractLattice, nneighbor::Integer; coordination::Integer=12)\nbonds!(bonds::Vector, lattice::AbstractLattice, neighbors::Neighbors) -> typeof(bonds)\n\nGet the required bonds of a lattice and append them to the input bonds.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.bonds-Tuple{AbstractLattice, Integer}","page":"Spatials","title":"QuantumLattices.Spatials.bonds","text":"bonds(lattice::AbstractLattice, nneighbor::Integer; coordination::Integer=12) -> Vector{Bond{Int, Point{dimension(lattice), scalartype(lattice)}}}\nbonds(lattice::AbstractLattice, neighbors::Neighbors) -> Vector{Bond{keytype(neighbors), Point{dimension(lattice), scalartype(lattice)}}}\n\nGet the required bonds of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.direction-Tuple{Char, Vararg{Any}}","page":"Spatials","title":"QuantumLattices.Spatials.direction","text":"direction(v::Char, args...) -> SVector{3, <:Number}\ndirection(v::Number, unit::Symbol) -> SVector{2, <:Number}\ndirection(v::Tuple{Number, Number}, unit::Symbol) -> SVector{3, <:Number}\ndirection(v::AbstractVector{<:Number}, args...) -> AbstractVector{<:Number}\n\nGet the unit vector that specifies the direction of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.distance-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.distance","text":"distance(p‚ÇÅ::AbstractVector{<:Number}, p‚ÇÇ::AbstractVector{<:Number}) -> Number\n\nGet the distance between two points.\n\nnote: Note\nCompared to norm(p‚ÇÅ-p‚ÇÇ), this function avoids the memory allocation for p‚ÇÅ-p‚ÇÇ, thus is more efficient.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.distance-Tuple{ReciprocalPath}","page":"Spatials","title":"QuantumLattices.Spatials.distance","text":"distance(path::ReciprocalPath) -> scalartype(path)\ndistance(path::ReciprocalPath, i::Integer) -> scalartype(path)\ndistance(path::ReciprocalPath, i::Integer, j::Integer) -> scalartype(path)\n\nGet the distance\n\nof the total path,\nfrom the start point to the ith point in the path,\nfrom the ith point to the jth point in the path (when i is greater than j, the value is negative).\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.dlmsave","page":"Spatials","title":"QuantumLattices.Spatials.dlmsave","text":"dlmsave(filename::AbstractString, x::AbstractVector{<:Number}, y::Union{AbstractVector{<:Number}, AbstractMatrix{<:Number}}, delim='\t')\ndlmsave(filename::AbstractString, x::AbstractVector{<:Number}, y::AbstractVector{<:Number}, z::Union{AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}}, delim='\t')\ndlmsave(filename::AbstractString, reciprocalspace::Union{BrillouinZone, ReciprocalZone}, data::Union{AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}}, delim='\t'; fractional::Bool=true)\ndlmsave(filename::AbstractString, reciprocalscatter::ReciprocalScatter, weights::AbstractMatrix{<:Number}, delim='\t'; fractional::Bool=true)\ndlmsave(filename::AbstractString, path::ReciprocalPath, data:AbstractMatrix{<:Number}, delim='\t'; distance::Bool=true)\ndlmsave(filename::AbstractString, path::ReciprocalPath, data::AbstractMatrix{<:Number}, weights::AbstractArray{<:Number, 3}, delim='\t'; distance::Bool=true)\ndlmsave(filename::AbstractString, path::ReciprocalPath, y::AbstractVector{<:Number}, data::Union{AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}}, delim='\t'; distance::Bool=true)\n\nSave data to delimited files.\n\n\n\n\n\n","category":"function"},{"location":"man/Spatials/#QuantumLattices.Spatials.fractionals-Tuple{ReciprocalScatter}","page":"Spatials","title":"QuantumLattices.Spatials.fractionals","text":"fractionals(reciprocalscatter::ReciprocalScatter) -> Vector{<:SVector}\n\nGet the fractional coordinates of a reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.fractionals-Union{Tuple{ProductedReciprocalSpace{K, N}}, Tuple{N}, Tuple{K}} where {K, N}","page":"Spatials","title":"QuantumLattices.Spatials.fractionals","text":"fractionals(reciprocalspace::ProductedReciprocalSpace{K, N}) where {K, N} -> AbstractVector{SVector{N, scalartype(reciprocalspace)}}\n\nGet the fractional coordinates of a reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.icoordinate-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Spatials.icoordinate","text":"icoordinate(bond::Bond) -> SVector\n\nGet the icoordinate of the bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.interlinks-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Neighbors}","page":"Spatials","title":"QuantumLattices.Spatials.interlinks","text":"interlinks(cluster‚ÇÅ::AbstractMatrix{<:Number}, cluster‚ÇÇ::AbstractMatrix{<:Number}, neighbors::Neighbors) -> Vector{Tuple{Int, Int, Int}}\n\nUse kdtree to get the intercluster nearest neighbors.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.iscontinuous-Tuple{BrillouinZone}","page":"Spatials","title":"QuantumLattices.Spatials.iscontinuous","text":"iscontinuous(brillouinzone::BrillouinZone) -> Bool\niscontinuous(::Type{<:BrillouinZone{K, P} where K}) where {P<:ùïÇ} -> Bool\n\nJudge whether a Brillouin zone is continuous.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isdiscrete-Tuple{BrillouinZone}","page":"Spatials","title":"QuantumLattices.Spatials.isdiscrete","text":"isdiscrete(brillouinzone::BrillouinZone) -> Bool\nisdiscrete(::Type{<:BrillouinZone{K, P} where K}) where {P<:ùïÇ} -> Bool\n\nJudge whether a Brillouin zone is discrete.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isintracell-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Spatials.isintracell","text":"isintracell(bond::Bond) -> Bool\n\nJudge whether a bond is intra the unit cell of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isintracell-Tuple{Point}","page":"Spatials","title":"QuantumLattices.Spatials.isintracell","text":"isintracell(point::Point) -> Bool\n\nJudge whether a point is intra the unitcell.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isintratriangle-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.isintratriangle","text":"isintratriangle(\n    p::AbstractVector{<:Number}, p‚ÇÅ::AbstractVector{<:Number}, p‚ÇÇ::AbstractVector{<:Number}, p‚ÇÉ::AbstractVector{<:Number};\n    vertexes::NTuple{3, Bool}=(true, true, true), edges::NTuple{3, Bool}=(true, true, true), atol::Real=atol, rtol::Real=rtol\n) -> Bool\n\nJudge whether a point belongs to the interior of a triangle whose vertexes are p‚ÇÅ, 'p‚ÇÇ' and p‚ÇÉ with the give tolerance. vertexes and edges define whether the interior should contain the vertexes or edges, respectively.\n\nnote: Note\nThe vertexes are in the order (p‚ÇÅ, p‚ÇÇ, p‚ÇÉ) and the edges are in the order (p‚ÇÅp‚ÇÇ, p‚ÇÇp‚ÇÉ, p‚ÇÉp‚ÇÅ).\nThe edges do not contain the vertexes.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isonline-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.isonline","text":"isonline(\n    p::AbstractVector{<:Number}, p‚ÇÅ::AbstractVector{<:Number}, p‚ÇÇ::AbstractVector{<:Number};\n    ends::Tuple{Bool, Bool}=(true, true), atol::Real=atol, rtol::Real=rtol\n) -> Bool\n\nJudge whether a point is on a line segment whose end points are p‚ÇÅ and p‚ÇÇ with the given tolerance. ends defines whether the line segment should contain its ends.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.isparallel-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.isparallel","text":"isparallel(v‚ÇÅ::AbstractVector{<:Number}, v‚ÇÇ::AbstractVector{<:Number}; atol::Real=atol, rtol::Real=rtol) -> Int\n\nJudge whether two vectors are parallel to each other with the given tolerance, 0 for not parallel, 1 for parallel and -1 for antiparallel.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.issubordinate-Tuple{AbstractVector{<:Number}, AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.Spatials.issubordinate","text":"issubordinate(coordinate::AbstractVector{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}; atol::Real=atol, rtol::Real=rtol) -> Bool\n\nJudge whether a coordinate belongs to a lattice defined by vectors with the given tolerance.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.label-Tuple{ReciprocalSpace, Integer}","page":"Spatials","title":"QuantumLattices.Spatials.label","text":"label(reciprocalspace::ReciprocalSpace, i::Integer) -> String\nlabel(::Type{<:ReciprocalSpace{K}}, i::Integer) where K -> String\n\nGet the label of the ith axis of a reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.label-Tuple{ReciprocalSpace}","page":"Spatials","title":"QuantumLattices.Spatials.label","text":"label(reciprocalspace::ReciprocalSpace) -> Symbol\nlabel(::Type{<:ReciprocalSpace{K}}) where K -> Symbol\n\nGet the label of a reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.minimumlengths","page":"Spatials","title":"QuantumLattices.Spatials.minimumlengths","text":"minimumlengths(cluster::AbstractVector{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, nneighbor::Integer=1; coordination::Integer=12) -> Vector{Float}\nminimumlengths(cluster::AbstractMatrix{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, nneighbor::Integer=1; coordination::Integer=12) -> Vector{Float}\n\nUse kdtree to search the lowest several minimum bond lengths within a lattice translated by a cluster.\n\nWhen the translation vectors are not empty, the lattice will be considered periodic in the corresponding directions. Otherwise the lattice will be open in all directions. To search for the bonds across the periodic boundaries, the cluster will be pre-translated to become a supercluster, which has open boundaries but is large enough to contain all the nearest neighbors within the required order. The coordination parameter sets the average number of each order of nearest neighbors. If it is to small, larger bond lengths may not be searched, and the result will contain Inf. This is a sign that you may need a larger coordination. Another situation that Inf appears in the result occurs when the minimum lengths are searched in open lattices. Indeed, the cluster may be too small so that the required order just goes beyond it. In this case the warning message can be safely ignored.\n\n\n\n\n\n","category":"function"},{"location":"man/Spatials/#QuantumLattices.Spatials.polar-Tuple{AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.polar","text":"polar(v::AbstractVector{<:Number}) -> Number\n\nGet the polar angle in radians of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.polard-Tuple{AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.polard","text":"polard(v::AbstractVector{<:Number}) -> Number\n\nGet the polar angle in degrees of a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.rcoordinate-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.Spatials.rcoordinate","text":"rcoordinate(bond::Bond) -> SVector\n\nGet the rcoordinate of the bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.reciprocals-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.Spatials.reciprocals","text":"reciprocals(lattice::AbstractLattice) -> Vector{<:SVector}\n\nGet the reciprocal translation vectors of the dual lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.reciprocals-Tuple{AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.Spatials.reciprocals","text":"reciprocals(vectors::AbstractVector{AbstractVector{<:Number}}) -> AbstractVector{<:AbstractVector{<:Number}}\n\nGet the reciprocals dual to the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.reciprocals-Tuple{FractionalReciprocalSpace}","page":"Spatials","title":"QuantumLattices.Spatials.reciprocals","text":"reciprocals(reciprocalspace::FractionalReciprocalSpace) -> AbstractVector{<:AbstractVector{<:Number}}\n\nGet the reciprocal lattice vectors of a reciprocal space with fractional coordinates.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.rotate-Tuple{AbstractVector{<:Number}, Number}","page":"Spatials","title":"QuantumLattices.Spatials.rotate","text":"rotate(vector::AbstractVector{<:Number}, angle::Number; axis::Tuple{Union{AbstractVector{<:Number}, Nothing}, Tuple{<:Number, <:Number}}=(nothing, (0, 0))) -> AbstractVector{<:Number}\nrotate(cluster::AbstractMatrix{<:Number}, angle::Number; axis::Tuple{Union{AbstractVector{<:Number}, Nothing}, Tuple{<:Number, <:Number}}=(nothing, (0, 0))) -> AbstractMatrix{<:Number}\n\nGet a rotated vector/cluster of the original one by a certain angle around an axis.\n\nThe axis is determined by a point it gets through (nothing can be used to denote the origin), and its polar as well as azimuth angles in radians. The default axis is the z axis.\n\nnote: Note\nThe result is given by the Rodrigues' rotation formula.\nOnly 2 and 3 dimensional vectors can be rotated.\nWhen the input vectors are 2 dimensional, both the polar and azimuth of the axis must be 0.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.selectpath-Tuple{BrillouinZone, NamedTuple{(:points, :labels), <:Tuple{var\"#s88\", var\"#s87\"} where {var\"#s88\"<:Tuple, var\"#s87\"<:Tuple}}}","page":"Spatials","title":"QuantumLattices.Spatials.selectpath","text":"selectpath(brillouinzone::BrillouinZone, contents::NamedTuple{(:points, :labels), <:Tuple{<:Tuple, <:Tuple}}; ends=nothing, atol::Real=atol, rtol::Real=rtol) -> Tuple(ReciprocalPath, Vector{Int})\nselectpath(brillouinzone::BrillouinZone, points::OneOrMore{Number}...; labels=points, ends=nothing, atol::Real=atol, rtol::Real=rtol) -> Tuple(ReciprocalPath, Vector{Int})\nselectpath(brillouinzone::BrillouinZone, segments::Pair{<:OneOrMore{Number}, <:OneOrMore{Number}}...; labels=segments, ends=nothing, atol::Real=atol, rtol::Real=rtol) -> Tuple(ReciprocalPath, Vector{Int})\n\nSelect a path from a BrillouinZone. Return a ReciprocalPath and the positions of the equivalent points in the BrillouinZone.\n\nnote: Note\nFor connected segments, the start point will be included while the stop point will be not for each segment except for the last both points of which will be included if ends is nothing.\nFor disconnected segments, they can be partitioned into several connected parts, and the rule for connected segments applies for each of such connected parts.With the above rules, all the points along the assigned path will be counted once and only once.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.setup-Tuple{Expr}","page":"Spatials","title":"QuantumLattices.Spatials.setup","text":"@recipe plot(reciprocalspace::BrillouinZone, data::AbstractArray{<:Number, 3}; subtitles=nothing, subtitlefontsize=8, nrow=nothing, ncol=nothing, clims=nothing)\n@recipe plot(reciprocalspace::ReciprocalZone, data::AbstractArray{<:Number, 3}; subtitles=nothing, subtitlefontsize=8, nrow=nothing, ncol=nothing, clims=nothing)\n@recipe plot(path::ReciprocalPath, y::AbstractVector{<:Number}, data::AbstractArray{<:Number, 3}; subtitles=nothing, subtitlefontsize=8, nrow=nothing, ncol=nothing, clims=nothing)\n\nDefine the recipe for the heatmap visualization of a series of data on \n\na Brillouin zone,\na reciprocal zone,\nthe x-y plain with the x axis being a reciprocal path.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.shrink-Union{Tuple{N}, Tuple{K}, Tuple{ReciprocalZone{K}, Vararg{OrdinalRange{<:Integer}, N}}} where {K, N}","page":"Spatials","title":"QuantumLattices.Spatials.shrink","text":"shrink(reciprocalzone::ReciprocalZone{K}, ranges::Vararg{OrdinalRange{<:Integer}, N}) where {K, N} -> ReciprocalZone\n\nShrink a reciprocal zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.ticks-Tuple{ReciprocalPath}","page":"Spatials","title":"QuantumLattices.Spatials.ticks","text":"ticks(path::ReciprocalPath) -> Tuple{Vector{scalartype(path)}, Vector{String}}\n\nGet the position-label pairs of the ticks of a path.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.tile-Tuple{AbstractVector{<:Number}, AbstractVector{<:AbstractVector{<:Number}}, Any}","page":"Spatials","title":"QuantumLattices.Spatials.tile","text":"tile(cluster::AbstractVector{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, translations) -> AbstractMatrix{<:Number}\ntile(cluster::AbstractMatrix{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}, translations) -> AbstractMatrix{<:Number}\n\nTile a supercluster by translations of the input cluster.\n\nBasically, the final supercluster is composed of several parts, each of which is a translation of the original cluster, with the translation vectors specified by vectors and each set of the translation indices contained in translations. When translation vectors are empty, a copy of the original cluster will be returned.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.translate-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.Spatials.translate","text":"translate(cluster::AbstractVector{<:Number}, vector::AbstractVector{<:Number}) -> AbstractVector{<:Number}\ntranslate(cluster::AbstractMatrix{<:Number}, vector::AbstractVector{<:Number}) -> AbstractMatrix{<:Number}\n\nGet the translated cluster of the original one by a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.volume-Tuple{AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.Spatials.volume","text":"volume(vectors::AbstractVector{<:AbstractVector{<:Number}}) -> Number\nvolume(v::AbstractVector{<:Number}) -> Number\nvolume(v‚ÇÅ::AbstractVector{<:Number}, v‚ÇÇ::AbstractVector{<:Number}) -> Number\nvolume(v‚ÇÅ::AbstractVector{<:Number}, v‚ÇÇ::AbstractVector{<:Number}, v‚ÇÉ::AbstractVector{<:Number}) -> Number\n\nGet the volume spanned by the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.volume-Tuple{BrillouinZone}","page":"Spatials","title":"QuantumLattices.Spatials.volume","text":"volume(brillouinzone::BrillouinZone) -> Number\n\nGet the volume of a Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.Spatials.volume-Tuple{ReciprocalZone}","page":"Spatials","title":"QuantumLattices.Spatials.volume","text":"volume(reciprocalzone::ReciprocalZone) -> Number\n\nGet the volume of a reciprocal zone.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.decompose-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Spatials","title":"QuantumLattices.decompose","text":"decompose(m::AbstractMatrix{<:Number}, m‚ÇÄ::AbstractMatrix{<:Number}) -> Number\ndecompose(m::AbstractMatrix{<:Number}, ms::Tuple{Vararg{AbstractMatrix{<:Number}}}) -> Tuple{Vararg{Number}}\ndecompose(m::AbstractMatrix{<:Number}, ms::AbstractVector{<:AbstractMatrix{<:Number}}) -> Vector{<:Number}\n\nDecompose a matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.decompose-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.decompose","text":"decompose(v‚ÇÄ::AbstractVector{<:Number}, v‚ÇÅ::AbstractVector{<:Number}) -> Number\ndecompose(v‚ÇÄ::AbstractVector{<:Number}, v‚ÇÅ::AbstractVector{<:Number}, v‚ÇÇ::AbstractVector{<:Number}) -> Tuple{Number, Number}\ndecompose(v‚ÇÄ::AbstractVector{<:Number}, v‚ÇÅ::AbstractVector{<:Number}, v‚ÇÇ::AbstractVector{<:Number}, v‚ÇÉ::AbstractVector{<:Number}) -> Tuple{Number, Number, Number}\ndecompose(v‚ÇÄ::AbstractVector{<:Number}, vs::AbstractVector{<:AbstractVector{<:Number}}) -> Vector{<:Number}\n\nDecompose a vector with respect to input basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dimension-Tuple{AbstractLattice}","page":"Spatials","title":"QuantumLattices.dimension","text":"dimension(lattice::AbstractLattice) -> Int\ndimension(::Type{<:AbstractLattice{N}}) where N -> Int\n\nGet the space dimension of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dimension-Tuple{Bond}","page":"Spatials","title":"QuantumLattices.dimension","text":"dimension(bond::Bond) -> Int\ndimension(::Type{<:Bond{K, P} where K}) where {P<:Point} -> Int\n\nGet the space dimension of a concrete bond.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dimension-Tuple{Point}","page":"Spatials","title":"QuantumLattices.dimension","text":"dimension(point::Point) -> Int\ndimension(::Type{<:Point{N}}) where N -> Int\n\nGet the spatial dimension of a point.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.dimension-Tuple{ReciprocalSpace}","page":"Spatials","title":"QuantumLattices.dimension","text":"dimension(reciprocalspace::ReciprocalSpace) -> Int\ndimension(::Type{<:ReciprocalSpace{K, P} where K}) where {P<:SVector} -> Int\n\nGet the spatial dimension of a reciprocal space.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.expand-Tuple{FractionalReciprocalSpace, AbstractVector{<:Number}}","page":"Spatials","title":"QuantumLattices.expand","text":"expand(reciprocalspace::FractionalReciprocalSpace, fractional::AbstractVector{<:Number}) -> AbstractVector{<:AbstractVector{<:Number}}\n\nExpand the fractional coordinate in a reciprocal space to the Cartesian coordinate.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#QuantumLattices.expand-Tuple{ùïÇ, AbstractVector{<:AbstractVector{<:Number}}}","page":"Spatials","title":"QuantumLattices.expand","text":"expand(momentum::ùïÇ, reciprocals::AbstractVector{<:AbstractVector{<:Number}}) -> eltype(reciprocals)\n\nExpand the momentum from integral values to real values with the given reciprocals.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#RecipesBase.apply_recipe","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(lattice::AbstractLattice, neighbors::Union{Int, Neighbors}, filter::Function=bond->true; siteon=false)\n\nDefine the recipe for the visualization of a lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/Spatials/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ReciprocalCurve}","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(curve::ReciprocalCurve)\n\nDefine the recipe for the visualization of a reciprocal curve.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ReciprocalPath, AbstractVector{<:Number}, AbstractMatrix{<:Number}}","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(path::ReciprocalPath, y::AbstractVector{<:Number}, data::AbstractMatrix{<:Number})\n\nDefine the recipe for the heatmap visualization of data on the x-y plain with the x axis being a reciprocal path.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ReciprocalPath}","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(path::ReciprocalPath)\n\nDefine the recipe for the visualization of a reciprocal path.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{K}, Tuple{AbstractDict{Symbol, Any}, FractionalReciprocalSpace{K, N}}} where {K, N}","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(reciprocalspace::FractionalReciprocalSpace; fractional=false, autolims=true)\n\nDefine the recipe for the visualization of a reciprocal space with fractional coordinates.\n\nWhen fractional is true, the fractional coordinates will be plotted. Otherwise the Cartesian coordinates will be plotted.\n\n\n\n\n\n","category":"method"},{"location":"man/Spatials/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{K}, Tuple{AbstractDict{Symbol, Any}, ReciprocalScatter{K, N, S, V} where {S<:(StaticArraysCore.SVector), V<:(StaticArraysCore.SVector{N})}, AbstractMatrix{<:Number}}} where {K, N}","page":"Spatials","title":"RecipesBase.apply_recipe","text":"@recipe plot(reciprocalscatter::ReciprocalScatter, weights::AbstractMatrix{<:Number}; fractional=true, weightmultiplier=1.0, weightcolors=nothing, weightlabels=nothing)\n\nDefine the recipe for the scatter visualization of reciprocal points with a series of weights.\n\n\n\n\n\n","category":"method"},{"location":"advanced topics/IndexOrders/#Index-orders","page":"Index orders","title":"Index orders","text":"","category":"section"},{"location":"man/DegreesOfFreedom/#Degrees-of-freedom","page":"Degrees of freedom","title":"Degrees of freedom","text":"","category":"section"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.À¢·µó","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.À¢·µó","text":"const À¢·µó = ‚Åø·µà =  ≥·µà = ·µó ∞ = Ordinal(1)\n\nConstant ordinals.\n\n\n\n\n\n","category":"constant"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.AllEqual","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.AllEqual","text":"AllEqual{Fields} <: Function\n\nAll-equal constraint for the direct product of homogenous simple internal indexes that for every specified field the values of the internal indexes should be all equal.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.AllEqual-Tuple{Vararg{Symbol}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.AllEqual","text":"AllEqual(fields::Tuple{Vararg{Symbol}})\nAllEqual(fields::Symbol...)\n\nConstruct an all-equal constraint.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.AllEqual-Union{Tuple{InternalIndexProd{NTuple{N, I}}}, Tuple{I}, Tuple{N}, Tuple{fields}} where {fields, N, I<:SimpleInternalIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.AllEqual","text":"(constraint::AllEqual{fields})(index::InternalIndexProd{NTuple{N, I}}) where {fields, N, I<:SimpleInternalIndex} -> Bool\n\nJudge whether the direct product of a set of homogenous simple internal indexes is subject to an all-equal constraint.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.AllEqual-Union{Tuple{Type{I}}, Tuple{I}} where I<:SimpleInternalIndex","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.AllEqual","text":"AllEqual(::Type{I}) where {I<:SimpleInternalIndex}\n\nConstruct an all-equal constraint based on the type of a simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Boundary","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Boundary","text":"Boundary{Names}(values::AbstractVector{<:Number}, vectors::AbstractVector{<:AbstractVector{<:Number}}) where Names\n\nBoundary twist of operators.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Boundary-Tuple{Operator}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Boundary","text":"(bound::Boundary)(operator::Operator; origin::Union{AbstractVector, Nothing}=nothing) -> Operator\n\nGet the boundary twisted operator.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Component","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Component","text":"Component{T‚ÇÅ, T‚ÇÇ} <: VectorSpace{Tuple{T‚ÇÅ, T‚ÇÅ, T‚ÇÇ}}\n\nA component of a matrix coupling, i.e., a matrix acting on a separated internal space.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeIndex","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CompositeIndex","text":"CompositeIndex{I<:Index} <: OperatorIndex\n\nAbstract type of a composite index.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CompositeInternal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CompositeInternal","text":"CompositeInternal{T<:Tuple{Vararg{SimpleInternal}}, I<:InternalIndex} <: Internal{I}\n\nAbstract type of the composition (i.e., direct sum or direct product) of several simple internal spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.ConstrainedInternal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.ConstrainedInternal","text":"ConstrainedInternal{P<:InternalProd, C<:InternalPattern}\n\nConstrained internal space.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.ConstrainedInternal-Tuple{SimpleInternal, InternalPattern}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.ConstrainedInternal","text":"ConstrainedInternal(internal::SimpleInternal, pattern::InternalPattern)\nConstrainedInternal(internal::InternalProd, pattern::InternalPattern)\n\nConstruct a constrained internal space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CoordinatedIndex","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CoordinatedIndex","text":"CoordinatedIndex{I<:Index, V<:SVector} <: CompositeIndex{I}\n\nCoordinated index, i.e., index with coordinates in the unitcell.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.CoordinatedIndex-Tuple{Index, Any, Any}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.CoordinatedIndex","text":"CoordinatedIndex(index::Index, rcoordinate, icoordinate)\nCoordinatedIndex(index::Index; rcoordinate, icoordinate)\n\nConstruct a coordinated index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Coupling","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Coupling","text":"Coupling{V, P<:Pattern} <: OperatorPack{V, P}\n\nCoupling among internal degrees of freedom at different or same lattice points.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Coupling-Tuple{Pattern}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Coupling","text":"Coupling(value, pattern::Pattern)\nCoupling(pattern::Pattern)\n\nConstruct a coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Coupling-Tuple{Vararg{Index}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Coupling","text":"Coupling(indexes::Index...)\nCoupling(value::Number, indexes::Index...)\nCoupling(value::Number, indexes::Tuple{Vararg{Index}})\n\nConstruct a coupling with the input indexes as the pattern.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Coupling-Union{Tuple{I}, Tuple{N}, Tuple{Union{Colon, NTuple{N, Ordinal}}, Type{I}, Vararg{Union{Colon, NTuple{N, T} where T}}}} where {N, I<:SimpleInternalIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Coupling","text":"Coupling(sites::Union{NTuple{N, Ordinal}, Colon}, ::Type{I}, fields::Union{NTuple{N}, Colon}...) where {N, I<:SimpleInternalIndex}\nCoupling(value::Number, sites::Union{NTuple{N, Ordinal}, Colon}, ::Type{I}, fields::Union{NTuple{N}, Colon}...) where {N, I<:SimpleInternalIndex}\nCoupling{N}(sites::Union{NTuple{N, Ordinal}, Colon}, ::Type{I}, fields::Union{NTuple{N}, Colon}...) where {N, I<:SimpleInternalIndex}\nCoupling{N}(value::Number, sites::Union{NTuple{N, Ordinal}, Colon}, ::Type{I}, fields::Union{NTuple{N}, Colon}...) where {N, I<:SimpleInternalIndex}\n\nConstruct a Coupling with the input sites and the fields of a kind of simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Coupling-Union{Tuple{N}, Tuple{Union{Function, Type{<:Function}}, Union{Colon, NTuple{N, Ordinal}}, Vararg{Union{Colon, NTuple{N, T} where T}}}} where N","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Coupling","text":"Coupling(f::Union{Function, Type{<:Function}}, sites::Union{NTuple{N, Ordinal}, Colon}, fields::Union{NTuple{N}, Colon}...) where N\nCoupling(value::Number, f::Union{Function, Type{<:Function}}, sites::Union{NTuple{N, Ordinal}, Colon}, fields::Union{NTuple{N}, Colon}...) where N\nCoupling{N}(f::Union{Function, Type{<:Function}}, sites::Union{NTuple{N, Ordinal}, Colon}, fields::Union{NTuple{N}, Colon}...) where N\nCoupling{N}(value::Number, f::Union{Function, Type{<:Function}}, sites::Union{NTuple{N, Ordinal}, Colon}, fields::Union{NTuple{N}, Colon}...) where N\n\nConstruct a Coupling by a function that can construct an Index with the input sites and the fields of a kind of simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Hilbert","text":"Hilbert{I<:Internal} <: CompositeDict{Int, I}\n\nHilbert space at a lattice.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert-Tuple{Internal, Integer}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Hilbert","text":"Hilbert(internal::Internal, num::Integer)\n\nConstruct a Hilbert space with all same internal spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert-Tuple{Internal, Vararg{Internal}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Hilbert","text":"Hilbert(internals::Internal...)\nHilbert(internals::OneAtLeast{Internal})\nHilbert(internals::AbstractVector{<:Internal})\n\nConstruct a Hilbert space with the given internal spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Hilbert-Tuple{Pair, Vararg{Pair}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Hilbert","text":"Hilbert(ps::Pair...)\nHilbert(kv)\n\nConstruct a Hilbert space the same way as an OrderedDict.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Index","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Index","text":"Index(site::Union{Int, Ordinal, Colon}, internal::SimpleInternalIndex)\n\nIndex of a degree of freedom, which consist of the spatial part (i.e., the site index) and the internal part (i.e., the internal index).\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Index-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Index","text":"Index(index::OperatorIndex)\n\nGet the Index part of an OperatorIndex.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Internal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Internal","text":"Internal{I<:InternalIndex} <: VectorSpace{I}\n\nInternal space at a single point.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalIndex","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalIndex","text":"InternalIndex <: OperatorIndex\n\nInternal index of an internal degree of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalIndex-Tuple{InternalIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalIndex","text":"InternalIndex(index::OperatorIndex)\n\nGet the InternalIndex part of an OperatorIndex.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalIndexProd","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalIndexProd","text":"InternalIndexProd{T<:Tuple{Vararg{SimpleInternalIndex}}} <: InternalIndex\n\nDirect product of several simple internal indexes.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalIndexProd-Tuple{Vararg{SimpleInternalIndex}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalIndexProd","text":"InternalIndexProd(contents::SimpleInternalIndex...)\n\nConstruct the direct product of several simple internal indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalPattern","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalPattern","text":"InternalPattern(index::InternalIndexProd, constraint::Function, representation::String=string(constraint))\nInternalPattern{P}(index::InternalIndexProd, constraints::NTuple{N, Function}, representations::NTuple{N, String}=map(string, constraints))  where {P, N}\n\nConstruct an internal pattern for the direct product of a set of simple internal indexes with 1) only one constraint function, and 2) several constraint functions.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalPattern-2","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalPattern","text":"InternalPattern{I, P, N, C<:NTuple{N, Function}} <: QuantumOperator\n\nInternal pattern for the direct product of a set of simple internal indexes with extra constraints.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalPattern-Tuple{SimpleInternalIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalPattern","text":"InternalPattern(index::SimpleInternalIndex)\nInternalPattern(index::InternalIndexProd{<:Tuple{Vararg{I}}}) where {I<:SimpleInternalIndex}\n\nConstruct an internal pattern whose constraint is an AllEqual function for the direct product of a homogeneous set of simple internal indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalProd","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalProd","text":"InternalProd{T<:Tuple{Vararg{SimpleInternal}}, I<:InternalIndex} <: CompositeInternal{T, I}\n\nDirect product of several single internal spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.InternalSum","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.InternalSum","text":"InternalSum{T<:Tuple{Vararg{SimpleInternal}}, I<:InternalIndex} <: CompositeInternal{T, I}\n\nDirect sum of several single internal spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.MatrixCoupling","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.MatrixCoupling","text":"MatrixCoupling{I}(sites::Union{NTuple{2, Ordinal}, NTuple{2, Colon}}, contents::Tuple{Vararg{Component}}) where {I<:SimpleInternalIndex}\nMatrixCoupling(sites::Union{NTuple{2, Ordinal}, Colon}, ::Type{I}, contents::Component...) where {I<:SimpleInternalIndex}\n\nMatrix coupling, i.e., a set of couplings whose coefficients are specified by matrices acting on separated internal spaces.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.MatrixCouplingProd","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.MatrixCouplingProd","text":"MatrixCouplingProd{V<:Number, C<:Tuple{Vararg{MatrixCoupling}}} <: VectorSpace{Coupling}\n\nProduct of matrix couplings together with an overall coefficient.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.MatrixCouplingSum","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.MatrixCouplingSum","text":"MatrixCouplingSum{C<:MatrixCouplingProd, N} <: VectorSpace{Coupling}\n\nSum of the products of matrix couplings.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Metric","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Metric","text":"Metric <: Function\n\nRules for measuring an operator index so that different operator indexes can be compared.\n\nAs a function, every instance should accept only one positional argument, i.e. the operator index to be measured.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.OperatorIndexToTuple","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.OperatorIndexToTuple","text":"OperatorIndexToTuple{Fields} <: Metric\n\nA rule that converts an operator index into a tuple based on the specified type parameter Fields.\n\nHere, Fields must be a tuple of Union{Symbol, Function}, which determines the elements of the converted tuple on an element-by-element basis.\n\nFor the ith element of Fields:\n\nIf it is a Symbol, it represents the name of a single index of an OperatorIndex, and its value will become the corresponding element in the converted tuple.\nIf it is a Function, it should be a trait function of an OperatorIndex, and its return value will become the corresponding element in the converted tuple.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.OperatorIndexToTuple-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.OperatorIndexToTuple","text":"(operatorunittotuple::OperatorIndexToTuple)(index::Index) -> Tuple\n\nConvert an index to a tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.OperatorIndexToTuple-Union{Tuple{Type{I}}, Tuple{I}} where I<:Index","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.OperatorIndexToTuple","text":"OperatorIndexToTuple(::Type{I}) where {I<:Index}\n\nConstruct the metric rule from the information of the Index type.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Ordinal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Ordinal","text":"Ordinal\n\nOrdinal of an Int.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Pattern","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Pattern","text":"Pattern{C<:InternalPattern, S<:Tuple{Vararg{Union{Ordinal, Colon}}}} <: QuantumOperator\n\nCoupling pattern.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Pattern-Tuple{Vararg{Index}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Pattern","text":"Pattern(indexes::Index...)\nPattern(indexes::Tuple{Vararg{Index}})\n\nConstruct a coupling pattern from a set of indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.SimpleInternal","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.SimpleInternal","text":"SimpleInternal{I<:SimpleInternalIndex} <: Internal{I}\n\nSimple internal space at a single point.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.SimpleInternalIndex","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.SimpleInternalIndex","text":"SimpleInternalIndex <: InternalIndex\n\nSimple internal index, i.e., a complete set of indexes to denote an internal degree of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Table","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Table","text":"Table(hilbert::Hilbert, by::Metric=OperatorIndexToTuple(typeof(hilbert))) -> Table\n\nGet the index-sequence table of a Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Table-2","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Table","text":"Table{I, B<:Metric} <: CompositeDict{I, Int}\n\nTable of operator index v.s. sequence pairs.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Table-3","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Table","text":"Table(indexes::AbstractVector{<:OperatorIndex}, by::Metric=OperatorIndexToTuple(eltype(indexes)))\n\nConvert a set of operator units to the corresponding table of operator index vs. sequence pairs.\n\nThe input operator units are measured by the input by function with the duplicates removed. The resulting unique values are sorted, which determines the sequence of the input indexes. Note that two operator units have the same sequence if their converted values are equal to each other.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Term","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Term","text":"Term{K, I, V, B, C<:TermCoupling, A<:TermAmplitude}\n\nTerm of a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.Term-Union{Tuple{K}, Tuple{Symbol, Any, Any, Any, Bool}} where K","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.Term","text":"Term{K}(id::Symbol, value, bondkind, coupling, ishermitian::Bool; amplitude::Union{Function, Nothing}=nothing, ismodulatable::Bool=true) where K\n\nConstruct a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.TermAmplitude","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.TermAmplitude","text":"TermAmplitude{F} <: TermFunction{F}\n\nFunction for the amplitude of a term.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.TermCoupling","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.TermCoupling","text":"TermCoupling{C<:Coupling, F} <: TermFunction{F}\n\nFunction for the coupling of a term.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.TermFunction","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.TermFunction","text":"TermFunction{F} <: Function\n\nAbstract type for concrete term functions.\n\n\n\n\n\n","category":"type"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.@pattern-Tuple","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.@pattern","text":"@pattern index‚ÇÅ index‚ÇÇ ...\n@pattern(index‚ÇÅ, index‚ÇÇ, ...; constraint=...)\n\nConstruct a coupling pattern according to the pattern of the input indexes and an optional constraint.\n\n\n\n\n\n","category":"macro"},{"location":"man/DegreesOfFreedom/#Base.:*-Tuple{MatrixCoupling, MatrixCoupling}","page":"Degrees of freedom","title":"Base.:*","text":"*(mc‚ÇÅ::MatrixCoupling, mc‚ÇÇ::MatrixCoupling) -> MatrixCouplingProd\n*(mc::MatrixCoupling, mcp::MatrixCouplingProd) -> MatrixCouplingProd\n*(mcp::MatrixCouplingProd, mc::MatrixCoupling) -> MatrixCouplingProd\n*(mcp‚ÇÅ::MatrixCouplingProd, mcp‚ÇÇ::MatrixCouplingProd) -> MatrixCouplingProd\n*(mc::MatrixCoupling, factor::Number) -> MatrixCouplingProd\n*(factor::Number, mc::MatrixCoupling) -> MatrixCouplingProd\n*(factor::Number, mcp::MatrixCouplingProd) -> MatrixCouplingProd\n*(mcp::MatrixCouplingProd, factor::Number) -> MatrixCouplingProd\n*(mcs::MatrixCouplingSum, element::Union{Number, MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n*(element::Union{Number, MatrixCoupling, MatrixCouplingProd}, mcs::MatrixCouplingSum) -> MatrixCouplingSum\n*(mcs‚ÇÅ::MatrixCouplingSum, mcs‚ÇÇ::MatrixCouplingSum) -> MatrixCouplingSum\n\nProduct between MatrixCouplings and MatrixCouplingProds.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.:+-Tuple{Union{MatrixCoupling, MatrixCouplingProd}, Union{MatrixCoupling, MatrixCouplingProd}}","page":"Degrees of freedom","title":"Base.:+","text":"+(mc‚ÇÅ::Union{MatrixCoupling, MatrixCouplingProd}, mc‚ÇÇ::Union{MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n+(mc::Union{MatrixCoupling, MatrixCouplingProd}, mcs::MatrixCouplingSum) -> MatrixCouplingSum\n+(mcs::MatrixCouplingSum, mc::Union{MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n+(mcs‚ÇÅ::MatrixCouplingSum, mcs‚ÇÇ::MatrixCouplingSum) -> MatrixCouplingSum\n\nAddition between MatrixCouplings and MatrixCouplingProds.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.:/-Tuple{MatrixCouplingProd, Number}","page":"Degrees of freedom","title":"Base.:/","text":"/(mcp::MatrixCouplingProd, factor::Number) -> MatrixCouplingProd\n/(mcs::MatrixCouplingSum, factor::Number) -> MatrixCouplingSum\n/(mc::MatrixCoupling, factor::Number) -> MatrixCouplingProd\n//(mcp::MatrixCouplingProd, factor::Number) -> MatrixCouplingProd\n//(mcs::MatrixCouplingSum, factor::Number) -> MatrixCouplingSum\n//(mc::MatrixCoupling, factor::Number) -> MatrixCouplingProd\n-(mc::MatrixCoupling) -> MatrixCouplingProd\n-(mcp::MatrixCouplingProd) -> MatrixCouplingProd\n-(mcs::MatrixCouplingSum) -> MatrixCouplingSum\n-(mc‚ÇÅ::Union{MatrixCoupling, MatrixCouplingProd}, mc‚ÇÇ::Union{MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n-(mc::Union{MatrixCoupling, MatrixCouplingProd}, mcs::MatrixCouplingSum) -> MatrixCouplingSum\n-(mcs::MatrixCouplingSum, mc::Union{MatrixCoupling, MatrixCouplingProd}) -> MatrixCouplingSum\n-(mcs‚ÇÅ::MatrixCouplingSum, mcs‚ÇÇ::MatrixCouplingSum) -> MatrixCouplingSum\n\nDefine right-division, minus and subtraction operator for a MatrixCoupling/MatrixCouplingProd/MatrixCouplingSum.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.:^-Tuple{Union{MatrixCoupling, MatrixCouplingProd, MatrixCouplingSum}, Integer}","page":"Degrees of freedom","title":"Base.:^","text":"^(mc::Union{MatrixCoupling, MatrixCouplingProd, MatrixCouplingSum}, n::Integer) -> Union{MatrixCoupling, MatrixCouplingProd, MatrixCouplingSum}\n\nGet the nth power of a MatrixCoupling/MatrixCouplingProd/MatrixCouplingSum.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.adjoint-Tuple{CoordinatedIndex}","page":"Degrees of freedom","title":"Base.adjoint","text":"adjoint(index::CoordinatedIndex) -> typeof(index)\n\nGet the adjoint of a coordinated index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.adjoint-Tuple{Index}","page":"Degrees of freedom","title":"Base.adjoint","text":"adjoint(index::Index) -> typeof(index)\n\nGet the adjoint of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.filter-Tuple{SimpleInternalIndex, CompositeInternal}","page":"Degrees of freedom","title":"Base.filter","text":"filter(ii::SimpleInternalIndex, ci::CompositeInternal) -> Union{Nothing, SimpleInternal, CompositeInternal}\nfilter(::Type{I}, ci::CompositeInternal) where {I<:SimpleInternalIndex} -> Union{Nothing, SimpleInternal, CompositeInternal}\n\nFilter the composite internal space and select those that match the input simple internal index or the type of a simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.filter-Tuple{SimpleInternalIndex, SimpleInternal}","page":"Degrees of freedom","title":"Base.filter","text":"filter(ii::SimpleInternalIndex, i::SimpleInternal) -> Union{Nothing, typeof(internal)}\nfilter(::Type{I}, i::SimpleInternal) where {I<:SimpleInternalIndex} -> Union{Nothing, typeof(internal)}\n\nFilter a simple internal space with respect to the input simple internal index or the type of a simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.filter-Union{Tuple{CI}, Tuple{SimpleInternalIndex, Type{CI}}} where CI<:CompositeInternal","page":"Degrees of freedom","title":"Base.filter","text":"filter(ii::SimpleInternalIndex, ::Type{CI}) where {CI<:CompositeInternal}\nfilter(::Type{I}, ::Type{CI}) where {I<:SimpleInternalIndex, CI<:CompositeInternal}\n\nFilter the type of a composite internal space and select those that match the input simple internal index or the type of a simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.filter-Union{Tuple{SI}, Tuple{SimpleInternalIndex, Type{SI}}} where SI<:SimpleInternal","page":"Degrees of freedom","title":"Base.filter","text":"filter(ii::SimpleInternalIndex, ::Type{SI}) where {SI<:SimpleInternal}\nfilter(::Type{I}, ::Type{SI}) where {I<:SimpleInternalIndex, SI<:SimpleInternal}\n\nFilter the type of a simple internal space with respect to the input simple internal index or the type of a simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.findall-Tuple{Function, Hilbert, Table}","page":"Degrees of freedom","title":"Base.findall","text":"findall(select::Function, hilbert::Hilbert, table::Table) -> Vector{Int}\n\nFind all the sequences of indexes contained in a Hilbert space according to a table and a select function.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.getindex-Tuple{Table, OperatorIndex}","page":"Degrees of freedom","title":"Base.getindex","text":"getindex(table::Table, index::OperatorIndex) -> Int\n\nInquiry the sequence of an operator index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.haskey-Tuple{Table, OperatorIndex}","page":"Degrees of freedom","title":"Base.haskey","text":"haskey(table::Table, index::OperatorIndex) -> Bool\nhaskey(table::Table, indexes::ID{OperatorIndex}) -> Tuple{Vararg{Bool}}\n\nJudge whether a single operator index or a set of operator indexes have been assigned with sequences in table.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.keys-Tuple{Boundary}","page":"Degrees of freedom","title":"Base.keys","text":"keys(bound::Boundary) -> Tuple{Vararg{Symbol}}\nkeys(::Type{<:Boundary{Names}}) where Names -> Names\n\nGet the names of the boundary parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.keys-Union{Tuple{OperatorIndexToTuple{Fields}}, Tuple{Fields}} where Fields","page":"Degrees of freedom","title":"Base.keys","text":"keys(::OperatorIndexToTuple{Fields}) where Fields -> Fields\nkeys(::Type{<:OperatorIndexToTuple{Fields}}) where Fields -> Fields\n\nGet the values of the type parameter Fields.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.match-Tuple{InternalPattern, InternalIndexProd}","page":"Degrees of freedom","title":"Base.match","text":"match(pattern::InternalPattern, index::InternalIndexProd) -> Bool\n\nJudge whether the direct product of a set of simple internal indexes satisfies an internal pattern.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.match-Tuple{SimpleInternalIndex, SimpleInternal}","page":"Degrees of freedom","title":"Base.match","text":"match(ii::SimpleInternalIndex, i::SimpleInternal) -> Bool\nmatch(::Type{I}, i::SimpleInternal) where {I<:SimpleInternalIndex} -> Bool\nmatch(ii::SimpleInternalIndex, ::Type{SI}) where {SI<:SimpleInternal} -> Bool\nmatch(::Type{I}, ::Type{SI}) where {I<:SimpleInternalIndex, SI<:SimpleInternal} -> Bool\n\nJudge whether a simple internal space or the type of a simple internal space matches a simple internal index or the type of a simple internal index.\n\nHere, \"match\" means that the eltype of the simple internal space is consistent with the type of the simple internal index, which usually means that they share the same type name.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.merge!-Tuple{Boundary, Boundary}","page":"Degrees of freedom","title":"Base.merge!","text":"merge!(bound::Boundary, another::Boundary) -> typeof(bound)\n\nMerge the values and vectors of the twisted boundary condition from another one.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.one-Tuple{Term}","page":"Degrees of freedom","title":"Base.one","text":"one(term::Term) -> Term\n\nGet a unit term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.replace-Tuple{Boundary}","page":"Degrees of freedom","title":"Base.replace","text":"replace(bound::Boundary; values=bound.values, vectors=bound.vectors) -> Boundary\n\nReplace the values or vectors of a twisted boundary condition and get the new one.\n\nnote: Note\nThe plain boundary condition keeps plain even when replaced with new values or new vectors.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.replace-Tuple{Term, Any}","page":"Degrees of freedom","title":"Base.replace","text":"replace(term::Term, value) -> Term\n\nReplace the value of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.string-Tuple{Term, Bond, Hilbert}","page":"Degrees of freedom","title":"Base.string","text":"string(term::Term, bond::Bond, hilbert::Hilbert) -> String\n\nGet the string representation of a term on a bond with a given Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.union-Tuple{Vararg{Table}}","page":"Degrees of freedom","title":"Base.union","text":"union(tables::Table...) -> Table\n\nUnite several operator index vs. sequence tables.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.valtype-Tuple{Term}","page":"Degrees of freedom","title":"Base.valtype","text":"valtype(term::Term)\nvaltype(::Type{<:Term)\n\nGet the value type of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.valtype-Tuple{Tuple{Term, Vararg{Term}}}","page":"Degrees of freedom","title":"Base.valtype","text":"valtype(terms::Tuple{Term, Vararg{Term}})\nvaltype(::Type{<:T}) where {T<:Tuple{Term, Vararg{Term}}}\n\nGet the common value type of a set of terms.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.valtype-Union{Tuple{I}, Tuple{M}, Tuple{Type{M}, Type{I}}} where {M<:OperatorIndexToTuple, I<:Index}","page":"Degrees of freedom","title":"Base.valtype","text":"valtype(::Type{<:OperatorIndexToTuple}, ::Type{<:Index})\n\nGet the valtype of applying an OperatorIndexToTuple rule to an Index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#Base.zero-Tuple{Term}","page":"Degrees of freedom","title":"Base.zero","text":"zero(term::Term) -> Term\n\nGet a zero term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LaTeXStrings.latexstring-Tuple{Coupling}","page":"Degrees of freedom","title":"LaTeXStrings.latexstring","text":"latexstring(coupling::Coupling) -> String\n\nConvert a coupling to the latex format.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LaTeXStrings.latexstring-Tuple{InternalPattern}","page":"Degrees of freedom","title":"LaTeXStrings.latexstring","text":"latexstring(pattern::InternalPattern) -> String\n\nConvert an internal pattern to the latex format.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LaTeXStrings.latexstring-Tuple{Pattern}","page":"Degrees of freedom","title":"LaTeXStrings.latexstring","text":"latexstring(pattern::Pattern) -> String\n\nConvert a coupling pattern to the latex format.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{CompositeInternal}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(ci::CompositeInternal) -> Int\nrank(::Type{<:CompositeInternal{T}}) where {T<:Tuple{Vararg{SimpleInternal}}} -> Int\n\nGet the number of simple internal spaces in a composite internal space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{Coupling}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(coupling::Coupling) -> Int\nrank(::Type{M}) where {M<:Coupling} -> Int\n\nGet the rank of a coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{InternalIndexProd}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(cii::InternalIndexProd) -> Int\nrank(::Type{<:InternalIndexProd{T}}) where {T<:Tuple{Vararg{SimpleInternalIndex}}} -> Int\n\nGet the number of simple internal indexes in a direct product.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{InternalPattern, Integer}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(pattern::InternalPattern, i::Integer) -> Int\nrank(::Type{P}, i::Integer) where {P<:InternalPattern} -> Int\n\nGet the rank of the direct product of the simple internal indexes that the ith constraint in an internal pattern can apply.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{InternalPattern}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(pattern::InternalPattern) -> Int\nrank(::Type{P}) where {P<:InternalPattern} -> Int\n\nGet the rank of the direct product of the simple internal indexes that an internal pattern can apply.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{Pattern}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(pattern::Pattern) -> Int\nrank(::Type{<:Pattern{<:InternalPattern, S}}) where {S<:Tuple{Vararg{Union{Ordinal, Colon}}}} -> Int\n\nGet the rank of a coupling pattern.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#LinearAlgebra.rank-Tuple{Term}","page":"Degrees of freedom","title":"LinearAlgebra.rank","text":"rank(term::Term) -> Int\nrank(::Type{<:Term) -> Int\n\nGet the rank of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:‚äï-Tuple{SimpleInternal, Vararg{SimpleInternal}}","page":"Degrees of freedom","title":"QuantumLattices.:‚äï","text":"‚äï(i::SimpleInternal, is::SimpleInternal...) -> InternalSum\n‚äï(i::SimpleInternal, ci::InternalSum) -> InternalSum\n‚äï(ci::InternalSum, i::SimpleInternal) -> InternalSum\n‚äï(ci‚ÇÅ::InternalSum, ci‚ÇÇ::InternalSum) -> InternalSum\n\nDirect sum between simple internal spaces and composite internal spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:‚äó-Tuple{Coupling, Coupling}","page":"Degrees of freedom","title":"QuantumLattices.:‚äó","text":"*(cp‚ÇÅ::Coupling, cp‚ÇÇ::Coupling) -> Coupling\n‚äó(cp‚ÇÅ::Coupling, cp‚ÇÇ::Coupling) -> Coupling\n\nGet the multiplication between two coupling.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:‚äó-Tuple{InternalPattern, InternalPattern}","page":"Degrees of freedom","title":"QuantumLattices.:‚äó","text":"‚äó(pattern‚ÇÅ::InternalPattern, pattern‚ÇÇ::InternalPattern) -> InternalPattern\n\nGet the combination of two internal patterns.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:‚äó-Tuple{Pattern, Pattern}","page":"Degrees of freedom","title":"QuantumLattices.:‚äó","text":"‚äó(pattern‚ÇÅ::Pattern, pattern‚ÇÇ::Pattern) -> Pattern\n\nGet the combination of two coupling patterns.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:‚äó-Tuple{SimpleInternal, Vararg{SimpleInternal}}","page":"Degrees of freedom","title":"QuantumLattices.:‚äó","text":"‚äó(i::SimpleInternal, is::SimpleInternal...) -> InternalProd\n‚äó(i::SimpleInternal, ci::InternalProd) -> InternalProd\n‚äó(ci::InternalProd, i::SimpleInternal) -> InternalProd\n‚äó(ci‚ÇÅ::InternalProd, ci‚ÇÇ::InternalProd) -> InternalProd\n\nDirect product between simple internal spaces and composite internal spaces.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.:‚äó-Tuple{SimpleInternalIndex, Vararg{SimpleInternalIndex}}","page":"Degrees of freedom","title":"QuantumLattices.:‚äó","text":"‚äó(ii::SimpleInternalIndex, iis::SimpleInternalIndex...) -> InternalIndexProd\n‚äó(ii::SimpleInternalIndex, cii::InternalIndexProd) -> InternalIndexProd\n‚äó(cii::InternalIndexProd, ii::SimpleInternalIndex) -> InternalIndexProd\n‚äó(cii‚ÇÅ::InternalIndexProd, cii‚ÇÇ::InternalIndexProd) -> InternalIndexProd\n\nDirect product between internal indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.allequalfields-Union{Tuple{Type{I}}, Tuple{I}} where I<:SimpleInternalIndex","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.allequalfields","text":"allequalfields(::Type{I}) where {I<:SimpleInternalIndex} -> Tuple{Vararg{Symbol}}\n\nGet the field names that can be subject to all-equal constraint based on the type of a simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.coordinatedindextype-Tuple{Type{<:SimpleInternal}, Type{<:Point}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.coordinatedindextype","text":"coordinatedindextype(I::Type{<:SimpleInternal}, P::Type{<:Point})\n\nGet the compatible type of the coordinated index based on the type of an internal space and the type of a point.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.indextype-Tuple{OperatorIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.indextype","text":"indextype(index::OperatorIndex)\nindextype(::Type{I}) where {I<:OperatorIndex}\n\nGet the type of the Index part of an OperatorIndex.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.indextype-Tuple{Type{<:SimpleInternal}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.indextype","text":"indextype(I::Type{<:SimpleInternal})\n\nGet the compatible type of the index based on the type of an internal space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.internalindextype-Tuple{OperatorIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.internalindextype","text":"internalindextype(index::OperatorIndex)\ninternalindextype(::Type{I}) where {I<:OperatorIndex}\n\nGet the type of the InternalIndex part of an OperatorIndex.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.isdefinite-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.isdefinite","text":"isdefinite(index::Index) -> Bool\nisdefinite(::Type{<:Index{I}}) where {I<:SimpleInternalIndex} -> Bool\n\nDetermine whether an index denotes a definite degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.isdefinite-Tuple{InternalIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.isdefinite","text":"isdefinite(ii::InternalIndex) -> Bool\nisdefinite(::Type{<:InternalIndex}) -> Bool\n\nJudge whether an internal index denotes a definite internal degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.isdefinite-Tuple{Tuple{Vararg{Index}}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.isdefinite","text":"isdefinite(indexes::Tuple{Vararg{Index}}) -> Bool\nisdefinite(::Type{T}) where {T<:Tuple{Vararg{Index}}} -> Bool\n\nDetermine whether a tuple of indexes denotes a definite degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.partition-Tuple{InternalPattern}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.partition","text":"partition(pattern::InternalPattern) -> Tuple{Vararg{Int}}\npartition(::Type{<:InternalPattern{I, P} where I}) where P -> P\n\nGet the partition of the direct product of a set of simple internal indexes on which the extra constraints operate independently.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.patternrule","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.patternrule","text":"patternrule(value, ::Val{Name}, args...; kwargs...) where Name\n\nBy overriding this function, a named rule for the value of some attributes in a pattern can be defined so that the value can be transformed into the desired one.\n\nIn most cases, such overridden functions define the default rules for the attributes in a pattern when they take on the default value :. \n\n\n\n\n\n","category":"function"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.patternrule-Tuple{Any, Val, Vararg{Any}}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.patternrule","text":"patternrule(value, ::Val, args...; kwargs...)-> typeof(value)\n\nDefault pattern rule unless otherwise specified.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.patternrule-Union{Tuple{Name}, Tuple{T}, Tuple{N}, Tuple{InternalIndexProd{T}, Val{Name}}} where {N, T<:NTuple{N, SimpleInternalIndex}, Name}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.patternrule","text":"patternrule(index::InternalIndexProd{T}, ::Val{Name}) where {N, T<:NTuple{N, SimpleInternalIndex}, Name} -> InternalIndexProd\n\nDefine the default rule for the internal index in an internal pattern.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.patternrule-Union{Tuple{N}, Tuple{NTuple{N, Colon}, Val, Integer}} where N","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.patternrule","text":"patternrule(sites::NTuple{N, Colon}, ::Val, bondlength::Integer) where N -> NTuple{N, Ordinal}\n\nDefine the default rule for the sites of a set of indexes in a coupling pattern.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.plain","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.plain","text":"plain\n\nPlain boundary condition without any twist.\n\n\n\n\n\n","category":"function"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.statistics-Tuple{CompositeIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.statistics","text":"statistics(index::CompositeIndex) -> Symbol\nstatistics(::Type{I}) where {I<:CompositeIndex} -> Symbol\n\nGet the statistics of a composite index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.statistics-Tuple{Index}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.statistics","text":"statistics(index::Index) -> Symbol\nstatistics(::Type{I}) where {I<:Index} -> Symbol\n\nGet the statistics of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.statistics-Tuple{SimpleInternalIndex}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.statistics","text":"statistics(ii::SimpleInternalIndex) -> Symbol\n\nGet the statistics of a simple internal index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.DegreesOfFreedom.statistics-Tuple{SimpleInternal}","page":"Degrees of freedom","title":"QuantumLattices.DegreesOfFreedom.statistics","text":"statistics(i::SimpleInternal) -> Symbol\nstatistics(::Type{<:SimpleInternal{I}}) where {I<:SimpleInternalIndex} -> Symbol\n\nGet the statistics of a simple internal space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.operatortype-Union{Tuple{T}, Tuple{H}, Tuple{B}, Tuple{Type{B}, Type{H}, Type{T}}} where {B<:Bond, H<:Hilbert, T<:Term}","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.operatortype","text":"operatortype(::Type{B}, ::Type{H}, ::Type{T}) where {B<:Bond, H<:Hilbert, T<:Term}\n\nGet the compatible Operator type from the type of a term, a Hilbert space and a bond.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.script-Tuple{CoordinatedIndex, Val{:integercoordinate}}","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.script","text":"script(index::CoordinatedIndex, ::Val{:integercoordinate}; vectors, kwargs...)\n\nGet the integer coordinate script of a coordinated index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.script-Tuple{CoordinatedIndex, Val{:rcoordinate}}","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.script","text":"script(index::CoordinatedIndex, ::Val{:rcoordinate}; kwargs...) -> String\nscript(index::CoordinatedIndex, ::Val{:icoordinate}; kwargs...) -> String\n\nGet the rcoordinate/icoordinate script of a coordinated index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.script-Tuple{Index, Val{:site}}","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.script","text":"script(index::Index, ::Val{:site}; kwargs...) -> String\nscript(index::Index, attr::Val; kwargs...) -> String\n\nGet the required script of an index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.QuantumOperators.script-Union{Tuple{attr}, Tuple{CompositeIndex, Val{attr}}} where attr","page":"Degrees of freedom","title":"QuantumLattices.QuantumOperators.script","text":"script(index::CompositeIndex, ::Val{attr}; kwargs...) where attr\n\nGet the attr script of a composite index.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.Spatials.icoordinate-Tuple{Operator{<:Number, <:NTuple{N, CoordinatedIndex} where N}}","page":"Degrees of freedom","title":"QuantumLattices.Spatials.icoordinate","text":"icoordinate(opt::Operator{<:Number, <:ID{CoordinatedIndex}}) -> SVector\n\nGet the whole icoordinate of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.Spatials.nneighbor-Tuple{Term}","page":"Degrees of freedom","title":"QuantumLattices.Spatials.nneighbor","text":"nneighbor(term::Term) -> Int\nnneighbor(terms::Tuple{Term, Vararg{Term}}) -> Int\n\nGet the\n\norder of neighbor in a single term;\nhighest order of neighbors in a set of terms.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.Spatials.rcoordinate-Tuple{Operator{<:Number, <:NTuple{N, CoordinatedIndex} where N}}","page":"Degrees of freedom","title":"QuantumLattices.Spatials.rcoordinate","text":"rcoordinate(opt::Operator{<:Number, <:ID{CoordinatedIndex}}) -> SVector\n\nGet the whole rcoordinate of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.dimension-Tuple{Internal}","page":"Degrees of freedom","title":"QuantumLattices.dimension","text":"dimension(i::Internal) -> Int\n\nGet the dimension of an internal space at a single point.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.expand!-Tuple{Operators, Term, Bond, Hilbert}","page":"Degrees of freedom","title":"QuantumLattices.expand!","text":"expand!(operators::Operators, term::Term, bond::Bond, hilbert::Hilbert; half::Bool=false) -> Operators\nexpand!(operators::Operators, term::Term, bonds, hilbert::Hilbert; half::Bool=false) -> Operators\n\nExpand the operators of a term on a bond/set-of-bonds with a given Hilbert space.\n\nThe half parameter determines the behavior of generating operators, which falls into the following two categories\n\ntrue: \"Hermitian half\" of the generated operators\nfalse: \"Hermitian whole\" of the generated operators\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.expand-Tuple{Term, Bond, Hilbert}","page":"Degrees of freedom","title":"QuantumLattices.expand","text":"expand(term::Term, bond::Bond, hilbert::Hilbert; half::Bool=false) -> Operators\nexpand(term::Term, bonds, hilbert::Hilbert; half::Bool=false) -> Operators\n\nExpand the operators of a term on a bond/set-of-bonds with a given Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.expand-Union{Tuple{Rule}, Tuple{Coupling, Val{Rule}, Bond, Hilbert}} where Rule","page":"Degrees of freedom","title":"QuantumLattices.expand","text":"expand(coupling::Coupling, ::Val{Rule}, bond::Bond, hilbert::Hilbert) where Rule\n\nExpand a coupling with the given bond and Hilbert space under a given named pattern rule.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.id-Tuple{Term}","page":"Degrees of freedom","title":"QuantumLattices.id","text":"id(term::Term) -> Symbol\nid(::Type{<:Term) -> Symbol\n\nGet the id of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.kind-Tuple{Term}","page":"Degrees of freedom","title":"QuantumLattices.kind","text":"kind(term::Term) -> Symbol\nkind(::Type{<:Term) -> Symbol\n\nGet the kind of a term.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.permute-Tuple{CoordinatedIndex, CoordinatedIndex}","page":"Degrees of freedom","title":"QuantumLattices.permute","text":"permute(index‚ÇÅ::CoordinatedIndex, index‚ÇÇ::CoordinatedIndex) -> Tuple{Vararg{Operator}}\n\nGet the permutation of two coordinated indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.permute-Tuple{Index, Index}","page":"Degrees of freedom","title":"QuantumLattices.permute","text":"permute(index‚ÇÅ::Index, index‚ÇÇ::Index) -> Tuple{Vararg{Operator}}\n\nGet the permutation of two indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.reset!-Tuple{Table, AbstractVector{<:OperatorIndex}}","page":"Degrees of freedom","title":"QuantumLattices.reset!","text":"reset!(table::Table, indexes::AbstractVector{<:OperatorIndex}) -> Table\n\nReset a table by a new set of indexes.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.reset!-Tuple{Table, Hilbert}","page":"Degrees of freedom","title":"QuantumLattices.reset!","text":"reset!(table::Table, hilbert::Hilbert) -> Table\n\nReset a table by a Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.shape-Tuple{SimpleInternal, SimpleInternalIndex}","page":"Degrees of freedom","title":"QuantumLattices.shape","text":"shape(internal::SimpleInternal, index::SimpleInternalIndex) -> OrdinalRange{Int, Int}\n\nGet the shape of a simple internal space when a labeled simple internal index are considered.\n\nA constrained internal space need this function to generate all the internal indexes that match the internal pattern, which gets a default implementation, i.e.,\n\nshape(internal::SimpleInternal, index::SimpleInternalIndex) = shape(internal)\n\nIt can be overloaded to restrict the shape of a simple internal space based on the input simple internal index to significantly improve efficiency, but this is not necessary.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.update!-Tuple{Boundary}","page":"Degrees of freedom","title":"QuantumLattices.update!","text":"update!(bound::Boundary; parameters...) -> Boundary\n\nUpdate the values of the boundary twisted phase.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.update!-Tuple{Term, Vararg{Any}}","page":"Degrees of freedom","title":"QuantumLattices.update!","text":"update!(term::Term, args...; kwargs...) -> Term\n\nUpdate the value of a term if it is ismodulatable.\n\n\n\n\n\n","category":"method"},{"location":"man/DegreesOfFreedom/#QuantumLattices.value-Tuple{Term}","page":"Degrees of freedom","title":"QuantumLattices.value","text":"value(term::Term) -> valtype(term)\n\nGet the value of a term.\n\n\n\n\n\n","category":"method"},{"location":"unitcell description framework/Introduction/#UnitcellDescriptionIntroduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"A quantum lattice system can be completely described based on its unitcell. Basically, this description should contain three types of information:","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"the spatial information, such as the coordinates of the points contained in the unitcell;\nthe internal degrees of freedom, such as the local algebra acting on the local Hilbert space at each point;\nthe couplings among different degrees of freedom, such as the terms present in the Hamiltonian.","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"In theory, as long as the above information is told, one could easily write down the operator representation of the Hamiltonian of the system. For example, in the phrase \"the single orbital electronic Hubbard model with only nearest neighbor hopping on a one dimensional lattice with only two sites\", \"one dimensional lattice with only two sites\" is the spatial information, \"single orbital electronic\" defines the local Hilbert space and thus the local algebra, and \"Hubbard model with only nearest neighbor hopping\" describes the terms present in the Hamiltonian. From this phrase, we also know that the Hamiltonian of the system is","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"H=tc^_1c_2+tc^_2c_1+tc^_1c_2+tc^_2c_1+Uc^_1c_1c^_1c_1+Uc^_2c_2c^_2c_2","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"where t is the hopping amplitudeÔºå U is the Hubbard interaction strength and the electronic creation/annihilation operator c^dagger_isigmac_isigma carries a site index i (i=1 2) and a spin index sigma (sigma=uparrow downarrow). Actually, the unitcell description framework follows exactly after the above train of thought. For example, the aforementioned system can be constructed by the following codes:","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"using QuantumLattices\nusing SymPy: Sym, symbols\n\n# define the unitcell\nlattice = Lattice([zero(Sym)], [one(Sym)])\n\n# define the internal degrees of freedom, i.e., the single-orbital spin-1/2 fermionic algebra\nhilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice))\n\n# define the terms\nt = Hopping(:t, symbols(\"t\", real=true), 1)\nU = Hubbard(:U, symbols(\"U\", real=true))\n\n# get the Hamiltonian\noperators = expand(OperatorGenerator(bonds(lattice, 1), hilbert, (t, U)))","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"The last line displays all the generated operators in the Hamiltonian in the LaTeX format. Here, in the subscript of the electronic annihilation/creation operator, an extra orbital index is also displayed.","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"In the following pages listed below, we will explain in detail how these codes work. Firstly, in the page of Spatial information of a unitcell, we will introduce the construction of the unitcell as well as the ways to obtain the bonds at different orders of nearest neighbors. Secondly, in the page of Internal degrees of freedom, we will explain the hierarchy of the internal degrees of freedom and discuss how they are organized for different categories of quantum systems. Thirdly, in the page of Couplings among different degrees of freedom, we will discuss the ways to specify the terms present in the Hamiltonian. Finally, in the page of Generator of operators, we will show how to combine all to get the operator representation of the Hamiltonian of a quantum lattice system. For more sophisticated information, the manual of this package can also be referred.","category":"page"},{"location":"unitcell description framework/Introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\n        \"SpatialInfoOfAUnitcell.md\",\n        \"InternalDegreesOfFreedom.md\",\n        \"CouplingsAmongDifferentDegreesOfFreedom.md\",\n        \"GeneratorOfOperators.md\",\n        ]\nDepth = 2","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Spatial-information-of-a-unitcell","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"The first step toward the complete description of a quantum lattice system is the understanding of the spatial information of a unitcell.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Construction-of-a-lattice","page":"Spatial information of a unitcell","title":"Construction of a lattice","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"In general, a lattice has translation symmetry. This symmetry introduces an equivalence relation for the points in a lattice when they can be translated into each other by multiple times of the translation vectors. This observation sets the mathematical foundation of the unitcell construction. As a result, it is enough for a lattice to restrict all points within the origin unitcell together with the translation vectors.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Lattice is the simplest structure to encode all the spatial information within the origin unitcell. Apparently, it must contain all the coordinates of the points in the origin unitcell and the translation vectors of the lattice. It also appears to be useful to associate a lattice with a name. Therefore, in this package, Lattice has three attributes:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"name::Symbol: the name of the lattice\ncoordinates::Matrix{<:Number}: the coordinates of the points within the origin unitcell\nvectors::Vector{<:StaticArraysCore.SVector}: the translation vectors of the lattice","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Lattice can be constructed by offering the coordinates, with optional keyword arguments to specify its name and translation vectors:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> Lattice([0.0])\nLattice(lattice)\n  with 1 point:\n    [0.0]\n\njulia> Lattice((0.0, 0.0), (0.5, 0.5); vectors=[[1.0, 0.0], [0.0, 1.0]], name=:Square)\nLattice(Square)\n  with 2 points:\n    [0.0, 0.0]\n    [0.5, 0.5]\n  with 2 translation vectors:\n    [1.0, 0.0]\n    [0.0, 1.0]\n\njulia> Lattice(\n           (0.0, 0.0, 0.0);\n           name=:Cube,\n           vectors=[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n       )\nLattice(Cube)\n  with 1 point:\n    [0.0, 0.0, 0.0]\n  with 3 translation vectors:\n    [1.0, 0.0, 0.0]\n    [0.0, 1.0, 0.0]\n    [0.0, 0.0, 1.0]","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"The coordinates could be specified by vectors or tuples.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Iteration over a lattice will get the coordinates of the points in it:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice((0.0, 0.0), (0.5, 0.5); vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> length(lattice)\n2\n\njulia> [lattice[1], lattice[2]]\n2-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n [0.5, 0.5]\n\njulia> collect(lattice)\n2-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n [0.5, 0.5]","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"The reciprocal translation vectors of the dual lattice can be obtained by reciprocals:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice((0.0, 0.0); vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> reciprocals(lattice)\n2-element StaticArraysCore.SVector{2, StaticArraysCore.SVector{2, Float64}} with indices SOneTo(2):\n [6.283185307179586, -0.0]\n [-0.0, 6.283185307179586]","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Request-for-the-bonds-of-a-lattice","page":"Spatial information of a unitcell","title":"Request for the bonds of a lattice","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Before the introduction of how to obtain the bonds of a lattice, let's discuss more about the unitcell construction to clarify the logic behind the definitions of the Point type and the Bond type in this package.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Point","page":"Spatial information of a unitcell","title":"Point","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"With the translation symmetry, all points of a lattice are equivalent to those within the origin unitcell. However, it becomes complicated when the bonds are requested. The bonds inter different unitcells cannot be compressed into a single unitcell. Therefore, even in the unitcell construction framework, it turns out to be unavoidable to specify a point outside the origin unitcell, which requires extra information beyond a single coordinate if we want to remember which point it is equivalent to within the origin unitcell at the same time. In fact, it is customary in literature to express the coordinate mathbfR of a point in a lattice as mathbfR=mathbfR_i+mathbfr, where mathbfR_i is the integral coordinate of the unitcell the point belongs to and mathbfr is the relative displacement of the point in the unitcell. Apparently, any two of these three coordinates are complete to get the full information. In this package, we choose mathbfR and mathbfR_i as the complete set for a individual lattice point. Besides, we also associate a site index with a point for the fast lookup for its equivalence within the origin unitcell although it is redundant in theory. Thus, the Point defined in this package has three attributes as follows:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"site::Int: the site index of a point that specifies the equivalent point within the origin unitcell\nrcoordinate::StaticArraysCore.SVector: the real coordinate of the point (mathbfR)\nicoordinate::StaticArraysCore.SVector: the integral coordinate of the unitcell the point belongs to (mathbfR_i)","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"At the construction of a Point, rcoordinate and icoordinate can accept tuples or usual vectors as inputs, such as","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> Point(1, [0.0], [0.0])\nPoint(1, [0.0], [0.0])\n\njulia> Point(1, (1.5, 0.0), (1.0, 0.0))\nPoint(1, [1.5, 0.0], [1.0, 0.0])","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"icoordinate can be omitted, then it will be initialized by a zero StaticArraysCore.SVector:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> Point(1, [0.0, 0.5])\nPoint(1, [0.0, 0.5], [0.0, 0.0])","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Bond","page":"Spatial information of a unitcell","title":"Bond","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"A bond in the narrow sense consist of two points. However, in quantum lattice systems, it is common to refer to generic bonds with only one or more than two points. In addition, it is also convenient to associate a bond with a kind information, such as the order of the nearest neighbors of the bond. Thus, the Bond is defined as follows:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"kind: the kind information of a generic bond\npoints::Vector{<:Point}: the points a generic bond contains","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> Bond(Point(1, [0.0, 0.0], [0.0, 0.0])) # 1-point bond\nBond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))\n\njulia> Bond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(1, [1.0, 1.0], [1.0, 1.0])) # 2-point bond\nBond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(1, [1.0, 1.0], [1.0, 1.0]))\n\njulia> Bond(:plaquette, Point(1, [0.0, 0.0]), Point(2, [1.0, 0.0]), Point(3, [1.0, 1.0]), Point(4, [0.0, 1.0])) # generic bond with 4 points\nBond(:plaquette, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(2, [1.0, 0.0], [0.0, 0.0]), Point(3, [1.0, 1.0], [0.0, 0.0]), Point(4, [0.0, 1.0], [0.0, 0.0]))","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"It is noted that the kind attribute of a bond with only one point is set to be 0.","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Iteration over a bond will get the points it contains:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> bond = Bond(2, Point(1, [0.0, 0.0], [0.0, 0.0]), Point(2, [1.0, 0.0], [0.0, 0.0]));\n\njulia> length(bond)\n2\n\njulia> [bond[1], bond[2]]\n2-element Vector{Point{2, Float64}}:\n Point(1, [0.0, 0.0], [0.0, 0.0])\n Point(2, [1.0, 0.0], [0.0, 0.0])\n\njulia> collect(bond)\n2-element Vector{Point{2, Float64}}:\n Point(1, [0.0, 0.0], [0.0, 0.0])\n Point(2, [1.0, 0.0], [0.0, 0.0])","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"The coordinate of a bond as a whole is also defined for those that only contain one or two points. The coordinate of a 1-point bond is defined to be the corresponding coordinate of this point, and the coordinate of a 2-point bond is defined to be the corresponding coordinate of the second point minus that of the first:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> bond1p = Bond(Point(1, [2.0], [1.0]));\n\njulia> rcoordinate(bond1p)\n1-element StaticArraysCore.SVector{1, Float64} with indices SOneTo(1):\n 2.0\n\njulia> icoordinate(bond1p)\n1-element StaticArraysCore.SVector{1, Float64} with indices SOneTo(1):\n 1.0\n\njulia> bond2p = Bond(1, Point(1, [1.0, 1.0], [1.0, 1.0]), Point(2, [0.5, 0.5], [0.0, 0.0]));\n\njulia> rcoordinate(bond2p)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n -0.5\n -0.5\n\njulia> icoordinate(bond2p)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n -1.0\n -1.0","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/#Generation-of-1-point-and-2-point-bonds-of-a-lattice","page":"Spatial information of a unitcell","title":"Generation of 1-point and 2-point bonds of a lattice","text":"","category":"section"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"In this package, we provide the function bonds to get the 1-point and 2-point bonds of a lattice:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"bonds(lattice::Lattice, nneighbor::Int) -> Vector{<:Bond}\nbonds(lattice::Lattice, neighbors::Neighbors) -> Vector{<:Bond}","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"which is based on the KDTree type provided by the NearestNeighbors.jl package. In the first method, all the bonds up to the nneighborth nearest neighbors are returned, including the 1-point bonds:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> bonds(lattice, 2)\n5-element Vector{Bond{Int64, Point{2, Float64}}}:\n Bond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(1, Point(1, [0.0, -1.0], [0.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(1, Point(1, [-1.0, 0.0], [-1.0, 0.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"However, this method is not so efficient, as KDTree only searches the bonds with the lengths less than a value, and it does not know the bond lengths for each order of nearest neighbors. Such information must be computed as first. Therefore, in the second method, bonds can accept a new type, the Neighbors, as its second positional parameter to improve the efficiency, which could tell the program the information of the bond lengths in priori:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> bonds(lattice, Neighbors(0=>0.0, 1=>1.0, 2=>‚àö2))\n5-element Vector{Bond{Int64, Point{2, Float64}}}:\n Bond(0, Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(1, Point(1, [0.0, -1.0], [0.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(1, Point(1, [-1.0, 0.0], [-1.0, 0.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"Meanwhile, an instance of Neighbors could also serve as a filter of the generated bonds, which select those bonds with the given bond lengths:","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"julia> lattice = Lattice([0.0, 0.0]; vectors=[[1.0, 0.0], [0.0, 1.0]]);\n\njulia> bonds(lattice, Neighbors(2=>‚àö2))\n2-element Vector{Bond{Int64, Point{2, Float64}}}:\n Bond(2, Point(1, [-1.0, -1.0], [-1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))\n Bond(2, Point(1, [1.0, -1.0], [1.0, -1.0]), Point(1, [0.0, 0.0], [0.0, 0.0]))","category":"page"},{"location":"unitcell description framework/SpatialInfoOfAUnitcell/","page":"Spatial information of a unitcell","title":"Spatial information of a unitcell","text":"To obtain generic bonds containing more points, user are encouraged to implement their own bonds methods. Pull requests are welcomed.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Internal-degrees-of-freedom","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's move to the second step, the internal degrees of freedom.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Hierarchy-of-the-internal-degrees-of-freedom","page":"Internal degrees of freedom","title":"Hierarchy of the internal degrees of freedom","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"In general, a lattice Hamiltonian can be expressed by the generators of the algebra that acts on the Hilbert space of the system. For example for the complex fermionic (bosonic) system, the Hilbert space is the Fock space, and the lattice Hamiltonian can be expressed by the generators of the fermionic (bosonic) algebra, i.e., the the creation and annihilation operators c^dagger_alpha c_alpha left(b^dagger_alpha b_alpharight). For another example for the local spin-1/2 system, the Hilbert space is the otimes_alphalvertuparrowrangle lvertdownarrowrangle_alpha space, and the lattice Hamiltonian can be expressed by the generators of the SU(2) spin algebra, i.e., the spin operators S^x_alpha S^y_alpha S^z_alpha or S^+_alpha S^-_alpha S^z_alpha. In both examples, the subscript alpha denotes a complete set of indexes of the internal degrees of freedom of the quantum system. Therefore, the determination of the algebra acting on the system's Hilbert space and its corresponding generators lies at the center of the constructions of the operator representations of lattice Hamiltonians.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The global Hilbert space of a lattice system can be decomposed into the direct product of the local internal spaces \"living\" on individual points, leading to a similar decomposition of the global algebra into local ones. To incorporate with the unitcell construction of the lattice, an extra intermediate representation of the translation-equivalent internal degrees of freedom within the origin unitcell is also needed. Thus, from the microscopic to the macroscopic, we arrive at a three level hierarchy, namely the local-unitcell-global hierarchy, of the internal degrees of freedom.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the local or the individual-point level, the local algebra is represented by the type Internal, and a local generator of the local algebra is represented by the type InternalIndex. Both types are abstract types with their concrete subtypes to represent concrete local algebras and concrete local generators of different quantum lattice systems with different internal structures, respectively.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the unitcell level, the algebra of the system is represented by the type Hilbert, which defines the concrete local algebras point by point within the origin unitcell. Accordingly, the type Index, which combines a site index and an instance of InternalIndex, could specify a translation-equivalent generator within the origin unitcell.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the global or the whole-lattice level, we do not actually need a representation of the algebra of the system, but really do for the generators because we have to specify them outside the origin unitcell when the bond goes across the unitcell boundaries. The type CoordinatedIndex, which combines an instance of Index and the coordinates mathbfR and mathbfR_i of the underlying point, represents a generator at such a level.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The above discussions can be summarized by the following table, which also displays how the spatial part of a quantum lattice system is represented:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":" local (individual-point) level unitcell level global (whole-lattice) level\nspatial Point Lattice \nalgebra Internal and its concrete subtypes Hilbert \ngenerator InternalIndex and its concrete subtypes Index CoordinatedIndex","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Quantum-lattice-systems-with-different-internal-structures","page":"Internal degrees of freedom","title":"Quantum lattice systems with different internal structures","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"In this section, we will explain in detail for the common categories of quantum lattice systems implemented in this package about how their algebras and generators are organized according to the above three level hierarchy.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Canonical-complex-fermionic,-canonical-complex-bosonic-and-hard-core-bosonic-systems","page":"Internal degrees of freedom","title":"Canonical complex fermionic, canonical complex bosonic and hard-core bosonic systems","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Local-level:-Fock-and-FockIndex","page":"Internal degrees of freedom","title":"Local level: Fock and FockIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Roughly speaking, these systems share similar internal structures of local Hilbert spaces termed as the Fock space where the generators of local algebras are the annihilation and creation operators. Besides the nambu index to distinguish whether it is an annihilation one or a creation one, such a generator usually adopts an orbital index and a spin index. Thus, the type FockIndex<:InternalIndex, which specifies a certain local generator of a local Fock algebra, has the following attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"orbital::Int: the orbital index\nspin::Rational{Int}: the spin index, which must be a half integer\nnambu::Int: the nambu index, which must be 1(annihilation) or 2(creation).","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Correspondingly, the type Fock<:Internal, which specifies the local algebra acting on the local Fock space, has the following attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"norbital::Int: the number of allowed orbital indices\nnspin::Int: the number of allowed spin indices","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To distinguish whether the system is a fermionic one or a bosonic one, FockIndex and Fock take a symbol :f(for fermionic) or :b(for bosonic) to be their first type parameters.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's see some examples.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"An FockIndex instance can be initialized by giving all its three attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> FockIndex{:f}(2, 1//2, 1)\nùïî(2, 1//2, 1)\n\njulia> FockIndex{:b}(2, 0, 1)\nùïì(2, 0, 1)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Here, ùïî (\\bbc<tab>) and ùïì (\\bbb<tab>) are two functions that are convenient to construct and display instances of FockIndex{:f} and FockIndex{:b}, respectively.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùïî(2, 1//2, 1) isa FockIndex{:f}\ntrue\n\njulia> ùïì(2, 0, 1) isa FockIndex{:b}\ntrue","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The adjoint of an FockIndex instance is also defined:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùïî(3, 3//2, 1)'\nùïî(3, 3//2, 2)\n\njulia> ùïì(3, 3//2, 2)'\nùïì(3, 3//2, 1)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Apparently, this operation is nothing but the \"Hermitian conjugate\".","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"A Fock instance can be initialized by giving all its attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Fock{:f}(1, 2)\n4-element Fock{:f}:\n ùïî(1, -1//2, 1)\n ùïî(1, 1//2, 1)\n ùïî(1, -1//2, 2)\n ùïî(1, 1//2, 2)\n\njulia> Fock{:b}(1, 1)\n2-element Fock{:b}:\n ùïì(1, 0, 1)\n ùïì(1, 0, 2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"As can be seen, a Fock instance behaves like a vector (because the parent type Internal is a subtype of AbstractVector), and its iteration just generates all the allowed FockIndex instances on its associated spatial point:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> fck = Fock{:f}(2, 1);\n\njulia> fck |> typeof |> eltype\nFockIndex{:f, Int64, Rational{Int64}, Int64}\n\njulia> fck |> length\n4\n\njulia> [fck[1], fck[2], fck[3], fck[4]]\n4-element Vector{FockIndex{:f, Int64, Rational{Int64}, Int64}}:\n ùïî(1, 0, 1)\n ùïî(2, 0, 1)\n ùïî(1, 0, 2)\n ùïî(2, 0, 2)\n\njulia> fck |> collect\n4-element Vector{FockIndex{:f, Int64, Rational{Int64}, Int64}}:\n ùïî(1, 0, 1)\n ùïî(2, 0, 1)\n ùïî(1, 0, 2)\n ùïî(2, 0, 2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"This is isomorphic to the mathematical fact that a local algebra is a vector space of the local generators.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Unitcell-level:-Hilbert-and-Index","page":"Internal degrees of freedom","title":"Unitcell level: Hilbert and Index","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To specify the Fock algebra at the unitcell level, Hilbert associate each point within the origin unitcell with an instance of Fock:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:f}(1, 2))\nHilbert{Fock{:f}} with 2 entries:\n  1 => Fock{:f}(norbital=1, nspin=2)\n  2 => Fock{:f}(norbital=1, nspin=2)\n\njulia> Hilbert(site=>Fock{:f}(2, 2) for site=1:2)\nHilbert{Fock{:f}} with 2 entries:\n  1 => Fock{:f}(norbital=2, nspin=2)\n  2 => Fock{:f}(norbital=2, nspin=2)\n\njulia> Hilbert(Fock{:f}(2, 2), 2)\nHilbert{Fock{:f}} with 2 entries:\n  1 => Fock{:f}(norbital=2, nspin=2)\n  2 => Fock{:f}(norbital=2, nspin=2)\n\njulia> Hilbert([Fock{:f}(2, 2), Fock{:f}(2, 2)])\nHilbert{Fock{:f}} with 2 entries:\n  1 => Fock{:f}(norbital=2, nspin=2)\n  2 => Fock{:f}(norbital=2, nspin=2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"In general, at different sites, the local Fock algebra could be different:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Hilbert(site=>Fock{:f}(iseven(site) ? 2 : 1, 1) for site=1:2)\nHilbert{Fock{:f}} with 2 entries:\n  1 => Fock{:f}(norbital=1, nspin=1)\n  2 => Fock{:f}(norbital=2, nspin=1)\n\njulia> Hilbert(1=>Fock{:f}(1, 2), 2=>Fock{:b}(1, 2))\nHilbert{Fock} with 2 entries:\n  1 => Fock{:f}(norbital=1, nspin=2)\n  2 => Fock{:b}(norbital=1, nspin=2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Hilbert itself is a subtype of AbstractDict, the iteration over the keys gives the sites, and the iteration over the values gives the local algebras:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> hilbert = Hilbert(site=>Fock{:f}(iseven(site) ? 2 : 1, 1) for site=1:2);\n\njulia> collect(keys(hilbert))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> collect(values(hilbert))\n2-element Vector{Fock{:f}}:\n Fock{:f}(norbital=1, nspin=1)\n Fock{:f}(norbital=2, nspin=1)\n\njulia> collect(hilbert)\n2-element Vector{Pair{Int64, Fock{:f}}}:\n 1 => Fock{:f}(norbital=1, nspin=1)\n 2 => Fock{:f}(norbital=2, nspin=1)\n\njulia> [hilbert[1], hilbert[2]]\n2-element Vector{Fock{:f}}:\n Fock{:f}(norbital=1, nspin=1)\n Fock{:f}(norbital=2, nspin=1)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To specify a translation-equivalent generator of the Fock algebra within the unitcell, Index just combines a site::Int attribute and an internal::FockIndex attribute:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> index = Index(1, FockIndex{:f}(1, -1//2, 2))\nùïî(1, 1, -1//2, 2)\n\njulia> index.site\n1\n\njulia> index.internal\nùïî(1, -1//2, 2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Here, the functions ùïî and ùïì can also construct and display instances of Index{<:FockIndex{:f}} and Index{<:FockIndex{:b}}, respectively.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùïî(1, 1, -1//2, 2) isa Index{<:FockIndex{:f}}\ntrue\n\njulia> ùïì(1, 1, -1//2, 2) isa Index{<:FockIndex{:b}}\ntrue","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The Hermitian conjugate of an Index is also defined:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùïî(1, 1, -1//2, 2)'\nùïî(1, 1, -1//2, 1)\n\njulia> ùïì(1, 1, -1//2, 1)'\nùïì(1, 1, -1//2, 2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Global-level:-CoordinatedIndex","page":"Internal degrees of freedom","title":"Global level: CoordinatedIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Since the local algebra of a quantum lattice system can be defined point by point, the global algebra can be completely compressed into the origin unitcell. However, the generator outside the origin unitcell cannot be avoided because we have to use them to compose the Hamiltonian on the bonds that goes across the unitcell boundaries. This situation is similar to the case of Lattice and Point. Therefore, we take a similar solution for the generators to that is adopted for the Point, i.e., we include the mathbfR coordinate (by the rcoordinate attribute) and the mathbfR_i coordinate (by the icoordinate attribute) of the underlying point together with the index::Index attribute in the CoordinatedIndex type to represent a generator that could be inside or outside the origin unitcell:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> index = CoordinatedIndex(Index(1, FockIndex{:f}(1, 0, 2)), [0.5, 0.0], [0.0, 0.0])\nùïî(1, 1, 0, 2, [0.5, 0.0], [0.0, 0.0])\n\njulia> index.index\nùïî(1, 1, 0, 2)\n\njulia> index.rcoordinate\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 0.5\n 0.0\n\njulia> index.icoordinate\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 0.0\n 0.0\n\njulia> index' # the Hermitian conjugate of a CoordinatedIndex is also defined\nùïî(1, 1, 0, 1, [0.5, 0.0], [0.0, 0.0])","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Here, as can be expected, the functions ùïî and ùïì can construct and display instances of CoordinatedIndex{<:Index{<:FockIndex{:f}}} and CoordinatedIndex{<:Index{<:FockIndex{:b}}}, respectively, as well.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùïî(1, 1, 0, 2, [0.5, 0.0], [0.0, 0.0]) isa CoordinatedIndex{<:Index{<:FockIndex{:f}}}\ntrue\n\njulia> ùïì(1, 1, 0, 2, [0.5, 0.0], [0.0, 0.0]) isa CoordinatedIndex{<:Index{<:FockIndex{:b}}}\ntrue","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#SU(2)-spin-systems","page":"Internal degrees of freedom","title":"SU(2) spin systems","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Local-level:-Spin-and-SpinIndex","page":"Internal degrees of freedom","title":"Local level: Spin and SpinIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Spin<:Internal and SpinIndex<:InternalIndex are designed to deal with SU(2) spin systems at the local level.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Although spin systems are essentially bosonic, the commonly-used local Hilbert space is distinct from that of an usual bosonic system: it is the space spanned by the eigenstates of a local S^z operator rather than a Fock space. At the same time, a spin Hamiltonian is usually expressed by local spin operators, such as S^x, S^y, S^z, S^+ and S^-, instead of creation and annihilation operators. Therefore, it is convenient to define another set of concrete subtypes for spin systems.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To specify which one of the five S^x S^y S^z S^+ S^- a local spin operator is, the type SpinIndex has the following attribute:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"tag::Char: the tag, which must be 'x', 'y', 'z', '+' or '-'.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Correspondingly, the type Spin, which defines the local SU(2) spin algebra, does not need any attribute.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"For SpinIndex and Spin, it is also necessary to know what the total spin is, which is taken as their first type parameters and should be a half-integer or an integer.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's see examples.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"An SpinIndex instance can be initialized as follows","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> SpinIndex{3//2}('x')\nùïä{3//2}('x')\n\njulia> SpinIndex{1//2}('z')\nùïä{1//2}('z')\n\njulia> SpinIndex{1}('+')\nùïä{1}('+')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Here, the type ùïä (\\bbS<tab>) plays a similar role in spin systems as ùïî and ùïì in Fock systems.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùïä{3//2}('x') isa SpinIndex{3//2}\ntrue","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The \"Hermitian conjugate\" of an SpinIndex instance can be obtained by the adjoint operation:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùïä{3//2}('x')'\nùïä{3//2}('x')\n\njulia> ùïä{3//2}('y')'\nùïä{3//2}('y')\n\njulia> ùïä{3//2}('z')'\nùïä{3//2}('z')\n\njulia> ùïä{3//2}('+')'\nùïä{3//2}('-')\n\njulia> ùïä{3//2}('-')'\nùïä{3//2}('+')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The local spin space is determined by the total spin. The standard matrix representation of an SpinIndex instance on this local spin space can be obtained by the matrix function exported by this package:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùïä{1//2}('x') |> matrix\n2√ó2 Matrix{ComplexF64}:\n 0.0+0.0im  0.5+0.0im\n 0.5+0.0im  0.0+0.0im\n\njulia> ùïä{1//2}('y') |> matrix\n2√ó2 Matrix{ComplexF64}:\n  0.0-0.0im  0.0-0.5im\n -0.0+0.5im  0.0-0.0im\n\njulia> ùïä{1//2}('z') |> matrix\n2√ó2 Matrix{ComplexF64}:\n  0.5+0.0im   0.0+0.0im\n -0.0+0.0im  -0.5+0.0im\n\njulia> ùïä{1//2}('+') |> matrix\n2√ó2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 0.0+0.0im  0.0+0.0im\n\njulia> ùïä{1//2}('-') |> matrix\n2√ó2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"A Spin instance can be initialized as follows:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Spin{1}()\n3-element Spin{1}:\n ùïä{1}('x')\n ùïä{1}('y')\n ùïä{1}('z')\n\njulia> Spin{1//2}()\n3-element Spin{1//2}:\n ùïä{1//2}('x')\n ùïä{1//2}('y')\n ùïä{1//2}('z')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Similar to Fock, a Spin instance behaves like a vector whose iteration generates the SpinIndex instances on its associated spatial point:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> sp = Spin{1}();\n\njulia> sp |> typeof |> eltype\nSpinIndex{1, Char}\n\njulia> sp |> length\n3\n\njulia> [sp[1], sp[2], sp[3]]\n3-element Vector{SpinIndex{1, Char}}:\n ùïä{1}('x')\n ùïä{1}('y')\n ùïä{1}('z')\n\njulia> sp |> collect\n3-element Vector{SpinIndex{1, Char}}:\n ùïä{1}('x')\n ùïä{1}('y')\n ùïä{1}('z')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that a Spin instance only generates SpinIndex instances limited to those of S^x, S^y, S^z but not those of S^+ and S^- because the former three has already formed a complete set of the generators of the local SU(2) spin algebra. This doesn't matter if you also want to construct your spin Hamiltonian by use of S^+ and S^-. For more details, see Couplings among different degrees of freedom.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Unitcell-and-global-levels:-Hilbert,-Index-and-CoordinatedIndex","page":"Internal degrees of freedom","title":"Unitcell and global levels: Hilbert, Index and CoordinatedIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the unitcell and global levels to construct the SU(2) spin algebra and spin generators, it is completely the same to that of the Fock algebra and Fock generators as long as we replace Fock and FockIndex with Spin and SpinIndex, respectively:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Hilbert(1=>Spin{1//2}(), 2=>Spin{1}())\nHilbert{Spin} with 2 entries:\n  1 => Spin{1//2}()\n  2 => Spin{1}()\n\njulia> Index(1, SpinIndex{1//2}('+'))\nùïä{1//2}(1, '+')\n\njulia> ùïä{1//2}(1, '+') isa Index{<:SpinIndex{1//2}}\ntrue\n\njulia> CoordinatedIndex(Index(1, SpinIndex{1//2}('-')), [0.5, 0.5], [1.0, 1.0])\nùïä{1//2}(1, '-', [0.5, 0.5], [1.0, 1.0])\n\njulia> ùïä{1//2}(1, '-', [0.5, 0.5], [1.0, 1.0]) isa CoordinatedIndex{<:Index{<:SpinIndex{1//2}}}\ntrue","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Phononic-systems","page":"Internal degrees of freedom","title":"Phononic systems","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Local-level:-Phonon-and-PhononIndex","page":"Internal degrees of freedom","title":"Local level: Phonon and PhononIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Phononic systems are also bosonic systems. However, the canonical creation and annihilation operators of phonons depends on the eigenvalues and eigenvectors of the dynamical matrix, making them difficult to be defined locally at each point. Instead, we resort to the displacement (mathbfu) and momentum (mathbfp) operators of lattice vibrations as the generators, which can be easily defined locally. The type PhononIndex<:InternalIndex could specify such a local generator, which has the following attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"direction::Char: the direction, which must be one of 'x', 'y' and 'z', to indicate which spatial directional component of the generator it is","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Correspondingly, the type Phonon<:Internal, which defines the local mathbfu mathbfp algebra of the lattice vibrations, has the following attributes:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"ndirection::Int: the spatial dimension of the lattice vibrations, which must be 1, 2, or 3.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"For PhononIndex and Phonon, it is also necessary to distinguish whether it is for the displacement (mathbfu) or for the momentum (mathbfp). Their first type parameters are designed to solve this problem, with :u and :b denoting mathbfu and mathbfp, respectively.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now let's see examples:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> PhononIndex{:u}('x')\nùï¶('x')\n\njulia> PhononIndex{:p}('x')\nùï°('x')\n\njulia> # one-dimensional lattice vibration only has the x component\n\njulia> Phonon{:u}(1)\n1-element Phonon{:u}:\n ùï¶('x')\n\njulia> Phonon{:p}(1)\n1-element Phonon{:p}:\n ùï°('x')\n\njulia> # two-dimensional lattice vibration only has the x and y components\n\njulia> Phonon{:u}(2) \n2-element Phonon{:u}:\n ùï¶('x')\n ùï¶('y')\n\njulia> Phonon{:p}(2)\n2-element Phonon{:p}:\n ùï°('x')\n ùï°('y')\n\njulia> # three-dimensional lattice vibration has the x, y and z components\n\njulia> Phonon{:u}(3)\n3-element Phonon{:u}:\n ùï¶('x')\n ùï¶('y')\n ùï¶('z')\n\njulia> Phonon{:p}(3)\n3-element Phonon{:p}:\n ùï°('x')\n ùï°('y')\n ùï°('z')","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"As is usual, we define functions ùï¶ (\\bbu<tab>) and ùï° (\\bbp<tab>) to construct and display instances of PhononIndex{:u} and PhononIndex{:p} for convenience, respectively.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ùï¶('x') isa PhononIndex{:u}\ntrue\n\njulia> ùï°('x') isa PhononIndex{:p}\ntrue","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Unitcell-and-global-levels:-Hilbert,-Index-and-CoordinatedIndex-2","page":"Internal degrees of freedom","title":"Unitcell and global levels: Hilbert, Index and CoordinatedIndex","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"At the unitcell and global levels, lattice-vibration algebras and generators are the same to previous situations by Phonon and PhononIndex replaced with in the corresponding types:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Hilbert(site=>Phonon(2) for site=1:3)\nHilbert{Phonon{:}} with 3 entries:\n  1 => Phonon(ndirection=2)\n  2 => Phonon(ndirection=2)\n  3 => Phonon(ndirection=2)\n\njulia> Index(1, PhononIndex{:u}('x'))\nùï¶(1, 'x')\n\njulia> ùï¶(1, 'x') isa Index{<:PhononIndex{:u}}\ntrue\n\njulia> Index(1, PhononIndex{:p}('x'))\nùï°(1, 'x')\n\njulia> ùï°(1, 'x') isa Index{<:PhononIndex{:p}}\ntrue\n\njulia> CoordinatedIndex(Index(1, PhononIndex{:u}('x')), [0.5, 0.5], [1.0, 1.0])\nùï¶(1, 'x', [0.5, 0.5], [1.0, 1.0])\n\njulia> ùï¶(1, 'x', [0.5, 0.5], [1.0, 1.0]) isa CoordinatedIndex{<:Index{<:PhononIndex{:u}}}\ntrue\n\njulia> CoordinatedIndex(Index(1, PhononIndex{:p}('x')), [0.5, 0.5], [1.0, 1.0])\nùï°(1, 'x', [0.5, 0.5], [1.0, 1.0])\n\njulia> ùï°(1, 'x', [0.5, 0.5], [1.0, 1.0]) isa CoordinatedIndex{<:Index{<:PhononIndex{:p}}}\ntrue","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that Phonon{:} is a special kind of Phonon, which are used to specify the Hilbert space of lattice vibrations. In this way, both the displacement (mathbfu) and the momentum (mathbfp) degrees of freedom can be incorporated.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/#Operator-and-Operators","page":"Internal degrees of freedom","title":"Operator and Operators","text":"","category":"section"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Now we arrive at the core types of this package, the Operator and Operators. They are defined to deal with the mathematical operations, i.e., the +/-/* operations between two elements of the algebra acting on the Hilbert space, and the scalar multiplication between an element of the algebra and a number. Specifically, an Operator represents a product of several generators of the algebra specified at any of the three levels along with a coefficient, and an Operators represents the sum of several instances of Operator.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Operator can be initialized by two ways:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operator(2, ùïî(1, -1//2, 2), ùïî(1, -1//2, 1), ùïä{1//2}('z'))\nOperator(2, ùïî(1, -1//2, 2), ùïî(1, -1//2, 1), ùïä{1//2}('z'))\n\njulia> 2 * ùïî(1, 1, -1//2, 2) * ùïä{1//2}(2, 'z')\nOperator(2, ùïî(1, 1, -1//2, 2), ùïä{1//2}(2, 'z'))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that the number of the generators can be any natural number.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Although generators at different levels can be producted to make an Operator, it is not recommended to do so because the logic will be muddled:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operator(2, ùïî(1, 0, 2), ùïî(2, 1, 0, 1, [0.0], [0.0])) # never do this !!!\nOperator(2, ùïî(1, 0, 2), ùïî(2, 1, 0, 1, [0.0], [0.0]))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Operator can be iterated and indexed by integers, which will give the corresponding generators in the product:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> op = Operator(2, ùïî(1, 1//2, 2), ùïî(1, 1//2, 1));\n\njulia> length(op)\n2\n\njulia> [op[1], op[2]]\n2-element Vector{FockIndex{:f, Int64, Rational{Int64}, Int64}}:\n ùïî(1, 1//2, 2)\n ùïî(1, 1//2, 1)\n\njulia> collect(op)\n2-element Vector{FockIndex{:f, Int64, Rational{Int64}, Int64}}:\n ùïî(1, 1//2, 2)\n ùïî(1, 1//2, 1)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"To get the coefficient of an Operator or all its individual generators as a whole, use the value and id function exported by this package, respectively:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> op = Operator(2, ùïî(1, 0, 2), ùïî(1, 0, 1));\n\njulia> value(op)\n2\n\njulia> id(op)\n(ùïî(1, 0, 2), ùïî(1, 0, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The product between two Operators, or the scalar multiplication between a number and an Operator is also an Operator:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operator(2, ùïî(1, 1//2, 2)) * Operator(3, ùïî(1, 1//2, 1))\nOperator(6, ùïî(1, 1//2, 2), ùïî(1, 1//2, 1))\n\njulia> 3 * Operator(2, ùïî(1, 1//2, 2))\nOperator(6, ùïî(1, 1//2, 2))\n\njulia> Operator(2, ùïî(1, 1//2, 2)) * 3\nOperator(6, ùïî(1, 1//2, 2))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The Hermitian conjugate of an Operator can be obtained by the adjoint operator:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> op = Operator(6, ùïî(2, 1//2, 2), ùïî(1, 1//2, 1));\n\njulia> op'\nOperator(6, ùïî(1, 1//2, 2), ùïî(2, 1//2, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"There also exists a special Operator, which only has the coefficient:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operator(2)\nOperator(2)","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Operators can be initialized by two ways:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operators(Operator(2, ùïî(1, 1//2, 1)), Operator(3, ùïî(1, 1//2, 2)))\nOperators with 2 Operator\n  Operator(2, ùïî(1, 1//2, 1))\n  Operator(3, ùïî(1, 1//2, 2))\n\njulia> Operator(2, ùïî(1, 1//2, 1)) - Operator(3, ùïì(1, 1//2, 2))\nOperators with 2 Operator\n  Operator(2, ùïî(1, 1//2, 1))\n  Operator(-3, ùïì(1, 1//2, 2))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Similar items are automatically merged during the construction of Operators:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> Operators(Operator(2, ùïî(1, 1//2, 1)), Operator(3, ùïî(1, 1//2, 1)))\nOperators with 1 Operator\n  Operator(5, ùïî(1, 1//2, 1))\n\njulia> Operator(2, ùïî(1, 1//2, 1)) + Operator(3, ùïî(1, 1//2, 1))\nOperators with 1 Operator\n  Operator(5, ùïî(1, 1//2, 1))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The multiplication between two Operatorses, or between an Operators and an Operator, or between a number and an Operators are defined:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ops = Operator(2, ùïî(1, 1//2, 1)) + Operator(3, ùïî(1, 1//2, 2));\n\njulia> op = Operator(2, ùïî(2, 1//2, 1));\n\njulia> ops * op\nOperators with 2 Operator\n  Operator(4, ùïî(1, 1//2, 1), ùïî(2, 1//2, 1))\n  Operator(6, ùïî(1, 1//2, 2), ùïî(2, 1//2, 1))\n\njulia> op * ops\nOperators with 2 Operator\n  Operator(4, ùïî(2, 1//2, 1), ùïî(1, 1//2, 1))\n  Operator(6, ùïî(2, 1//2, 1), ùïî(1, 1//2, 2))\n\njulia> another = Operator(2, ùïî(1, 1//2, 1)) + Operator(3, ùïî(1, 1//2, 2));\n\njulia> ops * another\nOperators with 2 Operator\n  Operator(6, ùïî(1, 1//2, 1), ùïî(1, 1//2, 2))\n  Operator(6, ùïî(1, 1//2, 2), ùïî(1, 1//2, 1))\n\njulia> 2 * ops\nOperators with 2 Operator\n  Operator(4, ùïî(1, 1//2, 1))\n  Operator(6, ùïî(1, 1//2, 2))\n\njulia> ops * 2\nOperators with 2 Operator\n  Operator(4, ùïî(1, 1//2, 1))\n  Operator(6, ùïî(1, 1//2, 2))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"It is noted that in the result, the distributive law automatically applies. Besides, the fermion operator relation c^2=(c^dagger)^2=0 is also used.","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"As is usual, the Hermitian conjugate of an Operators can be obtained by the adjoint operator:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> op‚ÇÅ = Operator(6, ùïî(1, 1//2, 2), ùïî(2, 1//2, 1));\n\njulia> op‚ÇÇ = Operator(4, ùïî(1, 1//2, 1), ùïî(2, 1//2, 1));\n\njulia> ops = op‚ÇÅ + op‚ÇÇ;\n\njulia> ops'\nOperators with 2 Operator\n  Operator(6, ùïî(2, 1//2, 2), ùïî(1, 1//2, 1))\n  Operator(4, ùïî(2, 1//2, 2), ùïî(1, 1//2, 2))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"Operators can be iterated and indexed:","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"julia> ops = Operator(2, ùïî(1, 1//2, 1)) + Operator(3, ùïî(1, 1//2, 2));\n\njulia> collect(ops)\n2-element Vector{Operator{Int64, Tuple{FockIndex{:f, Int64, Rational{Int64}, Int64}}}}:\n Operator(2, ùïî(1, 1//2, 1))\n Operator(3, ùïî(1, 1//2, 2))\n\njulia> ops[1]\nOperator(2, ùïî(1, 1//2, 1))\n\njulia> ops[2]\nOperator(3, ùïî(1, 1//2, 2))","category":"page"},{"location":"unitcell description framework/InternalDegreesOfFreedom/","page":"Internal degrees of freedom","title":"Internal degrees of freedom","text":"The index order of an Operators is the insertion order of the operators it contains.","category":"page"},{"location":"advanced topics/BoundaryConditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"man/QuantumOperators/#Quantum-operators","page":"Quantum operators","title":"Quantum operators","text":"","category":"section"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"Quantum operators form an algebra over a field, which are vector spaces with a bilinear operation (often called the \"multiplication\") between vectors defined.","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"With the help of the structure constants of the algebra, the result of the bilinear operation between any arbitrary two vectors can be expressed by a sum of individual ones. Therefore, in principle, an algebra can be represented by the complete basis set of its corresponding vector space and a rank-3 tensor encapsulating its structure constants. It is noted that the \"bilinear operation\" is not restricted to the usual multiplication. For example, it is the commutator, which is a composition of the usual multiplication and subtraction (for any A and B, the commutator [A, B] is defined as [A, B]‚âùAB-BA) that serves as the bilinear operator for Lie algebras.","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"In general, there are three basic operations on quantum operators, i.e. the scalar multiplication between a scalar and a quantum operator, the usual addition and the usual multiplication between quantum operators. Other complicated operations can be composed from these basic ones. These basic operations are implemented in this module.","category":"page"},{"location":"man/QuantumOperators/#OperatorIndex","page":"Quantum operators","title":"OperatorIndex","text":"","category":"section"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"OperatorIndex is the building block of quantum operators, which specifies the basis of the vector space of the corresponding algebra.","category":"page"},{"location":"man/QuantumOperators/#OperatorProd-and-OperatorSum","page":"Quantum operators","title":"OperatorProd and OperatorSum","text":"","category":"section"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"OperatorProd defines the product operator as an entity of basis quantum operators while OperatorSum defines the summation as an entity of OperatorProds. Both of them are subtypes of QuantumOperator, which is the abstract type for all quantum operators.","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"An OperatorProd must have two predefined contents:","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"value::Number: the coefficient of the quantum operator\nid::ID: the id of the quantum operator","category":"page"},{"location":"man/QuantumOperators/","page":"Quantum operators","title":"Quantum operators","text":"Arithmetic operations (+, -, *, /) between a scalar, an OperatorProd or an OperatorSum is defined. See Manual for details.","category":"page"},{"location":"man/QuantumOperators/#Manual","page":"Quantum operators","title":"Manual","text":"","category":"section"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.ID","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.ID","text":"ID{U<:OperatorIndex, N}\n\nID of a composite quantum operator, which is an ordered set of operator units.\n\nType alias for NTuple{N, U} where {U<:OperatorIndex}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.ID-Tuple{Vararg{OperatorIndex}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.ID","text":"ID(id::OperatorIndex...)\nID(u::OperatorIndex, id::ID{OperatorIndex})\nID(id::ID{OperatorIndex}, u::OperatorIndex)\nID(id‚ÇÅ::ID{OperatorIndex}, id‚ÇÇ::ID{OperatorIndex})\n\nGet the id from operator units/ids.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.ID-Union{Tuple{M}, Tuple{N}, Tuple{U}, Tuple{Type{U}, Vararg{NTuple{N, Any}, M}}} where {U<:OperatorIndex, N, M}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.ID","text":"ID(::Type{U}, attrs::Vararg{NTuple{N}, M}) where {U<:OperatorIndex, N, M}\n\nGet the composite id from the components of singular ids.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.LaTeX","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.LaTeX","text":"LaTeX{SP, SB}(body, spdelimiter::String=\", \", sbdelimiter::String=\", \"; options...) where {SP, SB}\n\nLaTeX string representation of quantum operators.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.LinearFunction","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.LinearFunction","text":"LinearFunction{F<:Function} <: LinearTransformation\n\nWrapper a function to be a linear transformation.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.LinearTransformation","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.LinearTransformation","text":"LinearTransformation <: Transformation\n\nAbstract linear transformation on quantum operators.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.LinearTransformation-Tuple{OperatorSet}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.LinearTransformation","text":"(transformation::LinearTransformation)(ms::OperatorSet; kwargs...) -> OperatorSet\n\nGet the linear transformed quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Matrixization","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Matrixization","text":"Matrixization <: LinearTransformation\n\nMatrixization transformation.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Operator","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Operator","text":"Operator{V, I<:ID{OperatorIndex}} <: OperatorProd{V, I}\n\nOperator.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorIndex","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorIndex","text":"OperatorIndex <: QuantumOperator\n\nAn operator index is the irreducible symbolic unit to completely represent a quantum operator.\n\nIt plays the role of the symbols as in usual computer algebras while it can host internal structures, which is convenient to represent quantum operators with complicated spatial and/or internal degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorPack","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorPack","text":"OperatorPack{V, I} <: QuantumOperator\n\nEntity that represent the pack of a number and an id of a quantum operator.\n\nBasically, a concrete subtype should contain two predefined contents:\n\nvalue::V: the coefficient of the pack\nid::I: the id of the pack\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorProd","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorProd","text":"OperatorProd{V, I<:Tuple} <: OperatorPack{V, I}\n\nA special kind of OperatorPack, where the relation between the coefficient and each component of the operator id can be viewed as product.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorSet","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorSet","text":"OperatorSet{M<:OperatorPack} <: QuantumOperator\n\nSet of OperatorPacks.\n\nThe relation between two OperatorPacks in an OperatorSet can be viewed as addition.\nBut in general, only iteration over OperatorPacks and length are supported.\nTo use arithmetic operations, please refer to its subtype, OperatorSum.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorSum","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorSum","text":"OperatorSum{M<:OperatorPack, I} <: OperatorSet{M}\n\nSum of OperatorPacks.\n\nSimilar items are automatically merged with the aid of the id system.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.OperatorSum-Tuple{Vararg{QuantumOperator}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.OperatorSum","text":"OperatorSum(ms)\nOperatorSum(ms::QuantumOperator...)\nOperatorSum{M}(ms) where {M<:OperatorPack}\nOperatorSum{M}(ms::QuantumOperator...) where {M<:OperatorPack}\n\nGet the sum of OperatorPacks.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Operators","text":"Operators{O<:Operator, I<:ID{OperatorIndex}}\n\nA set of operators.\n\nType alias for OperatorSum{O<:Operator, I<:ID{OperatorIndex}}.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Operators-Tuple{Vararg{Operator}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Operators","text":"Operators(opts::Operator...)\nOperators{M}(opts::Operator...)\n\nGet a set of operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Permutation","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Permutation","text":"Permutation{T} <: LinearTransformation\n\nPermutation transformation.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Permutation-Tuple{OperatorProd}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Permutation","text":"(permutation::Permutation)(m::OperatorProd; rev::Bool=false, kwargs...) -> OperatorSum\n\nPermute the operator units of an OperatorProd to the descending order according to the table contained in permutation.\n\nnote: Note\nTo use this function, the user must implement a method of permute, which computes the result of the permutation of two operator units:permute(u‚ÇÅ::OperatorIndex, u‚ÇÇ::OperatorIndex) -> Union{OperatorProd, OperatorSum}Here, u‚ÇÅ and u‚ÇÇ are two arbitrary operator units contained in id(m).\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.QuantumOperator","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.QuantumOperator","text":"QuantumOperator\n\nAbstract type of any quantum operator.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.RankFilter","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.RankFilter","text":"RankFilter{R} <: LinearTransformation\n\nRank filter, which filters out the OperatorProd with a given rank R.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.TabledUnitSubstitution","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.TabledUnitSubstitution","text":"TabledUnitSubstitution{U<:OperatorIndex, S<:OperatorSum, T<:AbstractDict{U, S}} <: UnitSubstitution{U, S}\n\nA concrete unit substitution transformation, which stores every substitution of the old OperatorIndexs in its table as a dictionary.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.Transformation","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.Transformation","text":"Transformation <: Function\n\nAbstract transformation on quantum operators.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.UnitSubstitution","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.UnitSubstitution","text":"UnitSubstitution{U<:OperatorIndex, S<:OperatorSum} <: LinearTransformation\n\nUnit substitution transformation, which substitutes each OperatorIndex in the old quantum operators to a new expression represented by an OperatorSum.\n\n\n\n\n\n","category":"type"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.UnitSubstitution-Tuple{OperatorProd}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.UnitSubstitution","text":"(unitsubstitution::UnitSubstitution)(m::OperatorProd; kwargs...) -> OperatorSum\n\nSubstitute every OperatorIndex in an OperatorProd with a new OperatorSum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:*-Tuple{Number, OperatorIndex}","page":"Quantum operators","title":"Base.:*","text":"*(factor::Number, m::OperatorIndex) -> Operator\n*(m::OperatorIndex, factor::Number) -> Operator\n*(m‚ÇÅ::OperatorIndex, m‚ÇÇ::OperatorIndex) -> Operator\n*(factor::Number, m::OperatorPack) -> OperatorPack\n*(m::OperatorPack, factor::Number) -> OperatorPack\n*(m‚ÇÅ::OperatorPack, m‚ÇÇ::OperatorIndex) -> OperatorPack\n*(m‚ÇÅ::OperatorIndex, m‚ÇÅ::OperatorPack) -> OperatorPack\n*(m‚ÇÅ::OperatorPack, m‚ÇÇ::OperatorPack) -> OperatorPack\n*(factor::Number, ms::OperatorSum) -> OperatorSum\n*(ms::OperatorSum, factor::Number) -> OperatorSum\n*(m::OperatorIndex, ms::OperatorSum) -> OperatorSum\n*(ms::OperatorSum, m::OperatorIndex) -> OperatorSum\n*(m::OperatorPack, ms::OperatorSum) -> OperatorSum\n*(ms::OperatorSum, m::OperatorPack) -> OperatorSum\n*(ms‚ÇÅ::OperatorSum, ms‚ÇÇ::OperatorSum) -> OperatorSum\n\nOverloaded * between quantum operators or a quantum operator and a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:+-Tuple{QuantumOperator}","page":"Quantum operators","title":"Base.:+","text":"+(m::QuantumOperator) -> typeof(m)\n+(m‚ÇÅ::QuantumOperator, m‚ÇÇ::QuantumOperator) -> OperatorSum\n+(factor::Number, m::QuantumOperator) -> OperatorSum\n+(m::QuantumOperator, factor::Number) -> OperatorSum\n\nOverloaded + between quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:--Tuple{QuantumOperator}","page":"Quantum operators","title":"Base.:-","text":"-(m::QuantumOperator) -> QuantumOperator\n-(m‚ÇÅ::QuantumOperator, m‚ÇÇ::QuantumOperator) -> OperatorSum\n-(factor::Number, m::QuantumOperator) -> OperatorSum\n-(m::QuantumOperator, factor::Number) -> OperatorSum\n\nOverloaded - between quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:/-Tuple{QuantumOperator, Number}","page":"Quantum operators","title":"Base.:/","text":"/(m::QuantumOperator, factor::Number) -> QuantumOperator\n\nOverloaded / between a quantum operator and a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.://-Tuple{QuantumOperator, Number}","page":"Quantum operators","title":"Base.://","text":"//(m::QuantumOperator, factor::Number) -> QuantumOperator\n\nOverloaded // between a quantum operator and a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.:^-Tuple{QuantumOperator, Integer}","page":"Quantum operators","title":"Base.:^","text":"^(m::QuantumOperator, n::Integer) -> QuantumOperator\n\nOverloaded ^ between a quantum operator and an integer.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.adjoint-Tuple{NTuple{N, OperatorIndex} where N}","page":"Quantum operators","title":"Base.adjoint","text":"adjoint(id::ID{OperatorIndex}) -> ID\n\nGet the adjoint of an id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.adjoint-Tuple{Operators}","page":"Quantum operators","title":"Base.adjoint","text":"adjoint(opts::Operators) -> Operators\n\nGet the adjoint of a set of operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.adjoint-Tuple{Operator}","page":"Quantum operators","title":"Base.adjoint","text":"adjoint(m::Operator) -> Operator\n\nGet the adjoint of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.conj-Tuple{OperatorIndex}","page":"Quantum operators","title":"Base.conj","text":"conj(m::OperatorIndex) -> OperatorIndex\nconj(m::OperatorPack) -> OperatorPack\nconj(m::OperatorSum) -> OperatorSum\n\nGet the conjugation.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.convert-Union{Tuple{M}, Tuple{Type{M}, Number}} where M<:OperatorProd","page":"Quantum operators","title":"Base.convert","text":"convert(::Type{M}, m::Number) where {M<:OperatorProd}\n\nConvert a number to a quantum operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.convert-Union{Tuple{M}, Tuple{Type{M}, OperatorIndex}} where M<:Operator","page":"Quantum operators","title":"Base.convert","text":"convert(::Type{M}, u::OperatorIndex) where {M<:Operator}\n\nConvert an operator index to an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.convert-Union{Tuple{M}, Tuple{Type{M}, OperatorPack}} where M<:OperatorPack","page":"Quantum operators","title":"Base.convert","text":"convert(::Type{M}, m::OperatorPack) where {M<:OperatorPack}\n\nConvert a quantum operator from one type to another.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.eltype-Tuple{OperatorProd}","page":"Quantum operators","title":"Base.eltype","text":"eltype(m::OperatorProd)\neltype(::Type{M}) where {M<:OperatorProd}\n\nGet the eltype of an OperatorProd.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.eltype-Tuple{OperatorSet}","page":"Quantum operators","title":"Base.eltype","text":"eltype(ms::OperatorSet)\neltype(::Type{<:OperatorSet{M}}) where {M<:OperatorPack}\n\nGet the eltype of an OperatorSet.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.empty-Tuple{OperatorSum}","page":"Quantum operators","title":"Base.empty","text":"empty(ms::OperatorSum) -> typeof(ms)\nempty!(ms::OperatorSum) -> typeof(ms)\n\nGet an empty copy or empty an OperatorSum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.getindex-Tuple{OperatorProd, Integer}","page":"Quantum operators","title":"Base.getindex","text":"getindex(m::OperatorProd, i::Integer) -> eltype(idtype(m))\ngetindex(m::OperatorProd, slice) -> OperatorProd\n\nOverloaded [].\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.getindex-Tuple{OperatorSum, Integer}","page":"Quantum operators","title":"Base.getindex","text":"getindex(ms::OperatorSum, index::Integer) -> eltype(ms)\ngetindex(ms::OperatorSum, indexes::AbstractVector{<:Integer}) -> typeof(ms)\ngetindex(ms::OperatorSum, ::Colon) -> typeof(ms)\n\nOverloaded [].\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.getproperty-Tuple{NTuple{N, OperatorIndex} where N, Symbol}","page":"Quantum operators","title":"Base.getproperty","text":"getproperty(id::ID{OperatorIndex}, name::Symbol)\n\nGet the property of a composite id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.haskey-Tuple{OperatorSum, Any}","page":"Quantum operators","title":"Base.haskey","text":"haskey(ms::OperatorSum, id) -> Bool\n\nJudge whether an OperatorSum contains an OperatorPack with the given id. \n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.isapprox-Tuple{OperatorPack, OperatorPack}","page":"Quantum operators","title":"Base.isapprox","text":"isapprox(m‚ÇÅ::OperatorPack, m‚ÇÇ::OperatorPack; atol::Real=atol, rtol::Real=rtol) -> Bool\n\nCompare two OperatorPacks and judge whether they are approximate to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.isapprox-Tuple{OperatorSum, OperatorSum}","page":"Quantum operators","title":"Base.isapprox","text":"isapprox(ms‚ÇÅ::OperatorSum, ms‚ÇÇ::OperatorSum; atol::Real=atol, rtol::Real=rtol) -> Bool\n\nCompare two OperatorSums and judge whether they are approximate to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.iszero-Tuple{OperatorIndex}","page":"Quantum operators","title":"Base.iszero","text":"iszero(u::OperatorIndex) -> Bool\n\nJudge whether an OperatorIndex is zero, which is defined to be always false.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.iszero-Tuple{OperatorPack}","page":"Quantum operators","title":"Base.iszero","text":"iszero(m::OperatorPack) -> Bool\n\nJudge whether an OperatorPack is zero, i.e., its value is zero.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.iszero-Tuple{OperatorSet}","page":"Quantum operators","title":"Base.iszero","text":"iszero(ms::OperatorSet) -> Bool\n\nJudge whether an OperatorSet is zero, i.e, it does not contain any OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.iszero-Tuple{OperatorSum}","page":"Quantum operators","title":"Base.iszero","text":"iszero(ms::OperatorSum) -> Bool\n\nJudge whether an OperatorSum is zero, i.e, it does not contain any OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.iterate-Tuple{OperatorProd}","page":"Quantum operators","title":"Base.iterate","text":"iterate(m::OperatorProd)\niterate(m::OperatorProd, state)\n\nIterate over the components of the id of an OperatorProd.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.iterate-Tuple{OperatorSum}","page":"Quantum operators","title":"Base.iterate","text":"iterate(ms::OperatorSum)\niterate(ms::OperatorSum, state)\n\nIterate over the OperatorPacks contained in an OperatorSum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.length-Tuple{OperatorProd}","page":"Quantum operators","title":"Base.length","text":"length(m::OperatorProd) -> Int\n\nGet the length of an OperatorProd.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.length-Tuple{OperatorSum}","page":"Quantum operators","title":"Base.length","text":"length(ms::OperatorSum) -> Int\n\nGet the number of OperatorPacks contained in an OperatorSum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.map!-Tuple{Function, OperatorSum}","page":"Quantum operators","title":"Base.map!","text":"map!(f::Function, ms::OperatorSum; kwargs...) -> typeof(ms)\n\nIn place map of an OperatorSum by the function f elementally.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.one-Union{Tuple{Type{M}}, Tuple{M}} where M<:OperatorProd","page":"Quantum operators","title":"Base.one","text":"one(::Type{M}) where {M<:OperatorProd}\none(m::OperatorProd)\n\nGet the identity quantum operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.propertynames-Tuple{NTuple{N, OperatorIndex} where N}","page":"Quantum operators","title":"Base.propertynames","text":"propertynames(::Type{I}) where I<:ID{OperatorIndex} -> Tuple{Vararg{Symbol}}\n\nGet the property names of a composite id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.replace-Tuple{OperatorPack, Any}","page":"Quantum operators","title":"Base.replace","text":"replace(m::OperatorPack, v) -> OperatorPack\n\nReplace the value of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.show-Tuple{IO, MIME{Symbol(\"text/latex\")}, QuantumOperator}","page":"Quantum operators","title":"Base.show","text":"show(io::IO, ::MIME\"text/latex\", m::QuantumOperator)\n\nShow a quantum operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.split-Tuple{OperatorProd}","page":"Quantum operators","title":"Base.split","text":"split(m::OperatorProd) -> Tuple{valtype(m), Vararg{Any}}\n\nSplit an OperatorProd into the coefficient and a sequence of the components of its id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.valtype-Tuple{OperatorPack}","page":"Quantum operators","title":"Base.valtype","text":"valtype(m::OperatorPack)\nvaltype(::Type{T}) where {T<:OperatorPack}\n\nGet the type of the value of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.zero-Tuple{QuantumOperator}","page":"Quantum operators","title":"Base.zero","text":"zero(m::QuantumOperator)\n\nGet a zero QuantumOperator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#Base.zero-Union{Tuple{Type{M}}, Tuple{M}} where M<:OperatorIndex","page":"Quantum operators","title":"Base.zero","text":"zero(::Type{M}) where {M<:OperatorIndex} -> OperatorSum\nzero(::Type{M}) where {M<:OperatorPack} -> OperatorSum\nzero(::Type{M}) where {M<:OperatorSum} -> OperatorSum\n\nGet the zero sum.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LaTeXStrings.latexstring-Tuple{OperatorIndex}","page":"Quantum operators","title":"LaTeXStrings.latexstring","text":"latexstring(u::OperatorIndex) -> String\n\nLaTeX string representation of an operator index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LaTeXStrings.latexstring-Tuple{OperatorProd}","page":"Quantum operators","title":"LaTeXStrings.latexstring","text":"latexstring(opt::OperatorProd) -> String\n\nGet the string representation of an operator in the LaTeX format.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LaTeXStrings.latexstring-Tuple{OperatorSet}","page":"Quantum operators","title":"LaTeXStrings.latexstring","text":"latexstring(opts::OperatorSet) -> String\n\nGet the string representation of a set of operators in the LaTeX format.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.dot-Tuple{QuantumOperator, QuantumOperator}","page":"Quantum operators","title":"LinearAlgebra.dot","text":"dot(m‚ÇÅ::QuantumOperator, m‚ÇÇ::QuantumOperator)\ndot(m::QuantumOperator, c::Number)\ndot(c::Number, m::QuantumOperator)\n\nDot product between two QuantumOperators or between a QuantumOperator and a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.ishermitian-Tuple{NTuple{N, OperatorIndex} where N}","page":"Quantum operators","title":"LinearAlgebra.ishermitian","text":"ishermitian(id::ID{OperatorIndex}) -> Bool\n\nJudge whether an id is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.ishermitian-Tuple{Operators}","page":"Quantum operators","title":"LinearAlgebra.ishermitian","text":"ishermitian(opts::Operators) -> Bool\n\nJudge whether a set of operators as a whole is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.ishermitian-Tuple{Operator}","page":"Quantum operators","title":"LinearAlgebra.ishermitian","text":"ishermitian(m::Operator) -> Bool\n\nJudge whether an operator is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.mul!-Tuple{OperatorSum, Number}","page":"Quantum operators","title":"LinearAlgebra.mul!","text":"mul!(ms::OperatorSum, factor::Number) -> OperatorSum\n\nGet the in-place multiplication of an OperatorSum with a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.rank-Tuple{NTuple{N, OperatorIndex} where N}","page":"Quantum operators","title":"LinearAlgebra.rank","text":"rank(id::ID{OperatorIndex}) -> Int\nrank(::Type{<:ID{OperatorIndex, N}}) where N -> Int\n\nGet the rank of an id.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#LinearAlgebra.rank-Tuple{OperatorProd}","page":"Quantum operators","title":"LinearAlgebra.rank","text":"rank(m::OperatorProd) -> Int\nrank(::Type{M}) where {M<:OperatorProd} -> Int\n\nGet the rank of an OperatorProd.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.idtype-Tuple{OperatorPack}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.idtype","text":"idtype(m::OperatorPack)\nidtype(::Type{T}) where {T<:OperatorPack}\n\nGet the type of the id of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.isequivalenttoscalar-Tuple{QuantumOperator}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.isequivalenttoscalar","text":"isequivalenttoscalar(m::QuantumOperator) -> Bool\nisequivalenttoscalar(::Type{M}) where {M<:QuantumOperator} -> Bool\n\nJudge whether a QuantumOperator is equivalent to a scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.isequivalenttoscalar-Tuple{Type{<:OperatorPack}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.isequivalenttoscalar","text":"isequivalenttoscalar(::Type{<:OperatorPack}) -> Bool\nisequivalenttoscalar(::Type{<:OperatorPack{V, Tuple{}} where V}) -> Bool\n\nJudge whether an OperatorPack is equivalent to a scalar.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.latexformat-Tuple{Type{<:OperatorIndex}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.latexformat","text":"latexformat(T::Type{<:OperatorIndex}) -> LaTeX\nlatexformat(T::Type{<:OperatorIndex}, l::LaTeX) -> LaTeX\n\nGet/Set the LaTeX format for a subtype of OperatorIndex.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.latexname-Tuple{Type{<:OperatorIndex}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.latexname","text":"latexname(T::Type{<:OperatorIndex}) -> Symbol\n\nGet the name of a type of OperatorIndex in the latex format lookups.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.matrix","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.matrix","text":"matrix\n\nGeneric matrix representation.\n\n\n\n\n\n","category":"function"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.operatortype-Tuple{QuantumOperator}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.operatortype","text":"operatortype(m::QuantumOperator)\n\nGet the operator type of a QuantumOperator, which is defined to be the type it corresponds to so that addition between two such objects can be performed directly. Usually, it is a subtype of OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.operatortype-Union{Tuple{Type{M}}, Tuple{M}} where M<:OperatorIndex","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.operatortype","text":"operatortype(::Type{M}) where {M<:OperatorIndex}\noperatortype(::Type{M}) where {M<:OperatorPack}\noperatortype(::Type{M}) where {M<:OperatorSet}\n\nGet the corresponding OperatorPack type of a quantum operator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.scalartype-Tuple{Any}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.scalartype","text":"scalartype(t)\nscalartype(::Type{T}) where {T<:Number}\nscalartype(::Type{<:AbstractArray{T}}) where T\nscalartype(::Type{<:Tuple{Vararg{T}}}) where T\n\nGet the scalar type of an object.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.scalartype-Union{Tuple{Type{M}}, Tuple{M}} where M<:QuantumOperator","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.scalartype","text":"scalartype(::Type{M}) where {M<:QuantumOperator}\n\nGet the scalar type of a QuantumOperator.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.scalartype-Union{Tuple{Type{T}}, Tuple{T}} where T<:OperatorPack","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.scalartype","text":"scalartype(::Type{T}) where {T<:OperatorPack}\n\nScalar type of the coefficient of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.script-Tuple{OperatorIndex, LaTeX, Val{:BD}}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.script","text":"script(u::OperatorIndex, l::LaTeX, ::Val{:BD}) -> Any\nscript(u::OperatorIndex, l::LaTeX, ::Val{:SP}) -> Tuple\nscript(u::OperatorIndex, l::LaTeX, ::Val{:SB}) -> Tuple\n\nGet the body/superscript/subscript of the LaTeX string representation of an operator index.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.script-Tuple{OperatorIndex, Val}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.script","text":"script(u::OperatorIndex, ::Val{}; kwargs...) -> String\n\nDefault script for an operator index, which always return an empty string.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.QuantumOperators.sequence-Tuple{OperatorProd, Any}","page":"Quantum operators","title":"QuantumLattices.QuantumOperators.sequence","text":"sequence(m::OperatorProd, table) -> NTuple{rank(m), Int}\n\nGet the sequence of the id of a quantum operator according to a table.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.add!-Tuple{Any, LinearTransformation, OperatorPack}","page":"Quantum operators","title":"QuantumLattices.add!","text":"add!(destination, transformation::LinearTransformation, op::OperatorPack; kwargs...) -> typeof(destination)\nadd!(destination, transformation::LinearTransformation, op::OperatorSet; kwargs...) -> typeof(destination)\n\nAdd the result of the linear transformation on a quantum operator to the destination.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.add!-Tuple{OperatorSum}","page":"Quantum operators","title":"QuantumLattices.add!","text":"add!(ms::OperatorSum) -> typeof(ms)\nadd!(ms::OperatorSum, m::Union{Number, OperatorIndex, OperatorPack}) -> typeof(ms)\nadd!(ms::OperatorSum, mms::OperatorSum) -> typeof(ms)\n\nGet the in-place addition of quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.div!-Tuple{OperatorSum, Number}","page":"Quantum operators","title":"QuantumLattices.div!","text":"div!(ms::OperatorSum, factor::Number) -> OperatorSum\n\nGet the in-place division of an OperatorSum with a number.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.expand-Tuple{QuantumOperator}","page":"Quantum operators","title":"QuantumLattices.expand","text":"expand(m::QuantumOperator) -> typeof(m)\n\nExpand a QuantumOperator, which is defined to be itself.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.id-Tuple{OperatorPack}","page":"Quantum operators","title":"QuantumLattices.id","text":"id(m::OperatorPack) -> idtype(m)\n\nGet the id of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.sub!-Tuple{OperatorSum}","page":"Quantum operators","title":"QuantumLattices.sub!","text":"sub!(ms::OperatorSum) -> typeof(ms)\nsub!(ms::OperatorSum, m::Union{Number, OperatorIndex, OperatorPack}) -> typeof(ms)\nsub!(ms::OperatorSum, mms::OperatorSum) -> typeof(ms)\n\nGet the in-place subtraction of quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.update!-Tuple{QuantumOperator}","page":"Quantum operators","title":"QuantumLattices.update!","text":"update!(m::QuantumOperator; parameters...) -> typeof(m)\n\nUpdate the parameters of a QuantumOperator in place and return the updated one.\n\nBy default, the parameter update of a QuantumOperator does nothing.\n\n\n\n\n\n","category":"method"},{"location":"man/QuantumOperators/#QuantumLattices.value-Tuple{OperatorPack}","page":"Quantum operators","title":"QuantumLattices.value","text":"value(m::OperatorPack) -> valtype(m)\n\nGet the value of an OperatorPack.\n\n\n\n\n\n","category":"method"},{"location":"unitcell description framework/GeneratorOfOperators/#Generator-of-operators","page":"Generator of operators","title":"Generator of operators","text":"","category":"section"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"In previous pages we have introduced the essential elements in detail of a quantum lattice system in the unitcell description framework. In this page, we will discuss how such elements can be incorporated to get the operator representation of the lattice Hamiltonian.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/#Operator-formed-lattice-Hamiltonians","page":"Generator of operators","title":"Operator-formed lattice Hamiltonians","text":"","category":"section"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"The essential elements to obtain an operator-formed lattice Hamiltonian are 1) terms, 2) bonds and 3) Hilbert space.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Accordingly, OperatorGenerator is the type to incorporate all these elements:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"OperatorGenerator(bonds::Vector{<:Bond}, hilbert::Hilbert, terms::OneOrMore{Term})","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Then, the operator representation of the lattice Hamiltonian can be obtained by the expand function:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"expand(gen::OperatorGenerator)","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"which is based on the expansion of terms introduced in the last section of the previous page Couplings among different degrees of freedom.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Now, let's go back to the example proposed in the page of Introduction:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"lattice = Lattice([zero(Sym)], [one(Sym)]);\nhilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice));\nt = Hopping(:t, symbols(\"t\", real=true), 1);\nU = Hubbard(:U, symbols(\"U\", real=true));\noperators = expand(OperatorGenerator(bonds(lattice, 1), hilbert, (t, U)))","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Note to run the above codes, SymPy.Sym and SymPy.symbols should be imported first.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"The LaTeX formatted outputs will be discussed in the page of LaTeX formatted outputs.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Here, we have two comments:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"In the construction of OperatorGenerator, a vector of Bonds other than a Lattice is required. Indeed, it is more flexible to control the generated operators by passing a vector of Bonds. By restricting the range of the input bonds, a certain subset of the lattice Hamiltonian can be easily obtained, which is sometimes useful in some quantum many-body algorithms.\nThe Hilbert space is essential because in general not all information of the local generators of a concrete quantum lattice system is contained in the terms. Remind: 1) the statistics of particles or the total spin of local spins is usually omitted in the coupling pattern of a term, and 2) the total number of local orbital/spin degrees of freedom, or the dimension of lattice vibrations, cannot be determined solely by the information provided by the coupling pattern of a term. Therefore, in order to obtain the lattice Hamiltonian, such incomplete information must be supplemented by the Hilbert space.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/#Parameters-tuning-of-lattice-Hamiltonians","page":"Generator of operators","title":"Parameters tuning of lattice Hamiltonians","text":"","category":"section"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"It is customary to tune the parameters of a lattice Hamiltonian. This can be achieved by the update! function exported by this package:","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"update!(gen::OperatorGenerator; termid‚ÇÅ=termvalue‚ÇÅ, termid‚ÇÅ=termvalue‚ÇÇ, ...)","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Here, termid·µ¢ (i = 1, 2, ...) is the id of a term in the lattice Hamiltonian, and termvalue·µ¢ is the new overall coefficient of this term.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"The parameters of the terms in an OperatorGenerator can be requested by the type Parameters (a type alias of NamedTuple):","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Parameters(gen::OperatorGenerator) -> Parameters","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"Let's see an example.","category":"page"},{"location":"unitcell description framework/GeneratorOfOperators/","page":"Generator of operators","title":"Generator of operators","text":"julia> lattice = Lattice([0.0], [1.0]);\n\njulia> hilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice));\n\njulia> t = Hopping(:t, 1.0, 1);\n\njulia> gen = OperatorGenerator(bonds(lattice, 1), hilbert, t);\n\njulia> Parameters(gen)\n(t = 1.0,)\n\njulia> expand(gen)\nOperators with 4 Operator\n  Operator(1.0, ùïî(2, 1, -1//2, 2, [1.0], [0.0]), ùïî(1, 1, -1//2, 1, [0.0], [0.0]))\n  Operator(1.0, ùïî(1, 1, -1//2, 2, [0.0], [0.0]), ùïî(2, 1, -1//2, 1, [1.0], [0.0]))\n  Operator(1.0, ùïî(2, 1, 1//2, 2, [1.0], [0.0]), ùïî(1, 1, 1//2, 1, [0.0], [0.0]))\n  Operator(1.0, ùïî(1, 1, 1//2, 2, [0.0], [0.0]), ùïî(2, 1, 1//2, 1, [1.0], [0.0]))\n\njulia> update!(gen; t=2.0);\n\njulia> Parameters(gen)\n(t = 2.0,)\n\njulia> expand(gen)\nOperators with 4 Operator\n  Operator(2.0, ùïî(2, 1, -1//2, 2, [1.0], [0.0]), ùïî(1, 1, -1//2, 1, [0.0], [0.0]))\n  Operator(2.0, ùïî(1, 1, -1//2, 2, [0.0], [0.0]), ùïî(2, 1, -1//2, 1, [1.0], [0.0]))\n  Operator(2.0, ùïî(2, 1, 1//2, 2, [1.0], [0.0]), ùïî(1, 1, 1//2, 1, [0.0], [0.0]))\n  Operator(2.0, ùïî(1, 1, 1//2, 2, [0.0], [0.0]), ùïî(2, 1, 1//2, 1, [1.0], [0.0]))","category":"page"},{"location":"#QuantumLattices.jl","page":"Home","title":"QuantumLattices.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov) (Image: ) (Image: ) (Image: 996.icu) (Image: LICENSE) (Image: LICENSE) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia package for the construction of quantum lattice systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to QuantumLattices. Here we provide a general framework to construct the operator-formed Hamiltonian of any quantum lattice system, with the inputs as simple as its description by the natural language. This operator-formed Hamiltonian supports complete symbolic computations when combined with SymPy, and can serve as a convenient frontend of quantum many-body algorithms, such as TBA (tight-bind approximation), LSWT (linear spin wave theory), SCMF (self-consistent mean field theory), ED (exact diagonalization), CPT/VCA (cluster perturbation theory / variational cluster approach), DMRG (density matrix renormalization group), RPA (random phase approximation), etc. Generic interfaces are defined to provide a unified access to these algorithms with automatic project management.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Julia v1.8+, please type ] in the REPL to use the package mode, then type this command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add QuantumLattices","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The mathematical foundations of our package is that the operators in a lattice Hamiltonian:","category":"page"},{"location":"","page":"Home","title":"Home","text":"act on local Hilbert spaces, and\nform an algebra over the complex field.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Based on this, the package has the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unitcell Description Framework: the Hamiltonian can be constructed based on the unitcell of a lattice with the information of the local algebra acting on the local Hilbert space living on each point and the terms that couples different degrees of freedom on the same or different points. Such information can be input into the program as simple as describing the quantum system in a usual research paper.\nComplete Symbolic Computation: with only this package, symbolic computation between operators is realized while the coefficient of any operator remains numeric; by integrating it with SymPy, complete symbolic computation can be achieved and no modifications need be made on the methods in this package.\nGeneric Frontend of Many-Body Algorithms: with the operator-formed Hamiltonian as the foothold, quantum many-body algorithms can be initialized in quite similar ways with only minor modifications needed. Moreover, automatic project management is realized, including that of result recording, data caching, parameter updating, information logging, dependency managing, etc.","category":"page"},{"location":"#Supported-Systems","page":"Home","title":"Supported Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Four common categories of quantum lattice systems in condensed matter physics are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"canonical complex fermionic systems\ncanonical complex and hard-core bosonic systems\nSU(2) spin systems\nPhononic systems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, other systems can be supported easily by extending the generic protocols provided in this package.","category":"page"},{"location":"#Supported-Algorithms","page":"Home","title":"Supported Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Concrete algorithms could be considered as the \"backend\" of quantum lattice systems. They are developed in separate packages (still in progress):","category":"page"},{"location":"","page":"Home","title":"Home","text":"TBA: tight-binding approximation for complex-fermionic/complex-bosonic/phononic systems;\nLSWT: linear spin wave theory for magnetically ordered local-spin systems;\nSCMF: self-consistent mean field theory for complex fermionic systems;\nED: exact diagonalization for complex-fermionic/hard-core-bosonic/local-spin systems;\nCPT/VCA: cluster perturbation theory and variational cluster approach for complex fermionic and local spin systems;\nDMRG: density matrix renormalization group for complex-fermionic/hard-core-bosonic/local-spin systems based on TensorKit and MPSKit;\nRPA: random phase approximation for complex fermionic systems.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tutorials: unitcell description\nTutorials: advanced topics","category":"page"},{"location":"#Note","page":"Home","title":"Note","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Due to the fast development of this package, releases with different minor version numbers are not guaranteed to be compatible with previous ones before the release of v1.0.0. Comments are welcomed in the GitHub issues.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"waltergu1989@gmail.com","category":"page"},{"location":"#Python-counterpart","page":"Home","title":"Python counterpart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HamiltonianPy: in fact, the authors of this Julia package worked on the python package at first and only turned to Julia later.","category":"page"}]
}
